module.exports = /** *** */ (function(modules) {
  // webpackBootstrap
  /** *** */ // The module cache
  /** *** */ const installedModules = {} // The require function
  /** *** */
  /** *** */ /** *** */ function __webpack_require__(moduleId) {
    /** *** */
    /** *** */ // Check if module is in cache
    /** *** */ if (installedModules[moduleId]) {
      /** *** */ return installedModules[moduleId].exports
      /** *** */
    } // Create a new module (and put it into the cache)
    /** *** */ /** *** */ const module = (installedModules[moduleId] = {
      /** *** */ i: moduleId,
      /** *** */ l: false,
      /** *** */ exports: {},
      /** *** */
    }) // Execute the module function
    /** *** */
    /** *** */ /** *** */ modules[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    ) // Flag the module as loaded
    /** *** */
    /** *** */ /** *** */ module.l = true // Return the exports of the module
    /** *** */
    /** *** */ /** *** */ return module.exports
    /** *** */
  } // expose the modules object (__webpack_modules__)
  /** *** */
  /** *** */
  /** *** */ /** *** */ __webpack_require__.m = modules // expose the module cache
  /** *** */
  /** *** */ /** *** */ __webpack_require__.c = installedModules // define getter function for harmony exports
  /** *** */
  /** *** */ /** *** */ __webpack_require__.d = function(
    exports,
    name,
    getter
  ) {
    /** *** */ if (!__webpack_require__.o(exports, name)) {
      /** *** */ Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter,
      })
      /** *** */
    }
    /** *** */
  } // define __esModule on exports
  /** *** */
  /** *** */ /** *** */ __webpack_require__.r = function(exports) {
    /** *** */ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /** *** */ Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module',
      })
      /** *** */
    }
    /** *** */ Object.defineProperty(exports, '__esModule', {value: true})
    /** *** */
  } // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
  /** *** */
  /** *** */ /** *** */ /** *** */ /** *** */ /** *** */ /** *** */ __webpack_require__.t = function(
    value,
    mode
  ) {
    /** *** */ if (mode & 1) {
      value = __webpack_require__(value)
    }
    /** *** */ if (mode & 8) {
      return value
    }
    /** *** */ if (
      mode & 4 &&
      typeof value === 'object' &&
      value &&
      value.__esModule
    ) {
      return value
    }
    /** *** */ const ns = Object.create(null)
    /** *** */ __webpack_require__.r(ns)
    /** *** */ Object.defineProperty(ns, 'default', {
      enumerable: true,
      value,
    })
    /** *** */ if (mode & 2 && typeof value !== 'string') {
      for (const key in value) {
        __webpack_require__.d(
          ns,
          key,
          function(key) {
            return value[key]
          }.bind(null, key)
        )
      }
    }
    /** *** */ return ns
    /** *** */
  } // getDefaultExport function for compatibility with non-harmony modules
  /** *** */
  /** *** */ /** *** */ __webpack_require__.n = function(module) {
    /** *** */ const getter =
      module && module.__esModule
        ? /** *** */ function getDefault() {
            return module.default
          }
        : /** *** */ function getModuleExports() {
            return module
          }
    /** *** */ __webpack_require__.d(getter, 'a', getter)
    /** *** */ return getter
    /** *** */
  } // Object.prototype.hasOwnProperty.call
  /** *** */
  /** *** */ /** *** */ __webpack_require__.o = function(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property)
  } // __webpack_public_path__
  /** *** */
  /** *** */ /** *** */ __webpack_require__.p = '' // Load entry module and return exports
  /** *** */
  /** *** */
  /** *** */ /** *** */ return __webpack_require__(
    (__webpack_require__.s = 150)
  )
  /** *** */
})(
  /** ********************************************************************* */
  /** *** */ [
    /* 0 */
    /** */ function(module, exports) {
      module.exports = function(originalModule) {
        if (!originalModule.webpackPolyfill) {
          var module = Object.create(originalModule) // module.parent = undefined by default

          if (!module.children) {
            module.children = []
          }
          Object.defineProperty(module, 'loaded', {
            enumerable: true,
            get: function get() {
              return module.l
            },
          })
          Object.defineProperty(module, 'id', {
            enumerable: true,
            get: function get() {
              return module.i
            },
          })
          Object.defineProperty(module, 'exports', {
            enumerable: true,
          })
          module.webpackPolyfill = 1
        }

        return module
      }

      /** */
    },
    /* 1 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        1
      )
      /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        3
      )

      const redefine = __webpack_require__(25)

      const toString = __webpack_require__(160)

      const ObjectPrototype = Object.prototype // `Object.prototype.toString` method
      // https://tc39.github.io/ecma262/#sec-object.prototype.tostring

      if (toString !== ObjectPrototype.toString) {
        redefine(ObjectPrototype, 'toString', toString, {
          unsafe: true,
        })
      }

      /** */
    },
    /* 2 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        2
      )

      const $ = __webpack_require__(6)

      const isObject = __webpack_require__(12)

      const isArray = __webpack_require__(60)

      const toAbsoluteIndex = __webpack_require__(84)

      const toLength = __webpack_require__(22)

      const toIndexedObject = __webpack_require__(29)

      const createProperty = __webpack_require__(57)

      const arrayMethodHasSpeciesSupport = __webpack_require__(58)

      const wellKnownSymbol = __webpack_require__(7)

      const SPECIES = wellKnownSymbol('species')
      const nativeSlice = [].slice
      const {max} = Math // `Array.prototype.slice` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.slice
      // fallback for not array-like ES3 strings and DOM objects

      $(
        {
          target: 'Array',
          proto: true,
          forced: !arrayMethodHasSpeciesSupport('slice'),
        },
        {
          slice: function slice(start, end) {
            const O = toIndexedObject(this)
            const length = toLength(O.length)
            let k = toAbsoluteIndex(start, length)
            const fin = toAbsoluteIndex(
              end === undefined ? length : end,
              length
            ) // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

            let Constructor
            let result
            let n

            if (isArray(O)) {
              Constructor = O.constructor // cross-realm fallback

              if (
                typeof Constructor === 'function' &&
                (Constructor === Array || isArray(Constructor.prototype))
              ) {
                Constructor = undefined
              } else if (isObject(Constructor)) {
                Constructor = Constructor[SPECIES]
                if (Constructor === null) {
                  Constructor = undefined
                }
              }

              if (Constructor === Array || Constructor === undefined) {
                return nativeSlice.call(O, k, fin)
              }
            }

            result = new (Constructor === undefined ? Array : Constructor)(
              max(fin - k, 0)
            )

            for (n = 0; k < fin; k++, n++) {
              if (k in O) {
                createProperty(result, n, O[k])
              }
            }

            result.length = n
            return result
          },
        }
      )

      /** */
    },
    /* 3 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        1
      )
      /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        16
      )
      /* harmony import */ const core_js_modules_es_regexp_flags__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        59
      )
      /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        3
      )

      const redefine = __webpack_require__(25)

      const anObject = __webpack_require__(17)

      const fails = __webpack_require__(9)

      const flags = __webpack_require__(72)

      const TO_STRING = 'toString'
      const RegExpPrototype = RegExp.prototype
      const nativeToString = RegExpPrototype[TO_STRING]
      const NOT_GENERIC = fails(function() {
        return (
          nativeToString.call({
            source: 'a',
            flags: 'b',
          }) != '/a/b'
        )
      }) // FF44- RegExp#toString has a wrong name

      const INCORRECT_NAME = nativeToString.name != TO_STRING // `RegExp.prototype.toString` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring

      if (NOT_GENERIC || INCORRECT_NAME) {
        redefine(
          RegExp.prototype,
          TO_STRING,
          function toString() {
            const R = anObject(this)
            const p = String(R.source)
            const rf = R.flags
            const f = String(
              rf === undefined &&
                R instanceof RegExp &&
                !('flags' in RegExpPrototype)
                ? flags.call(R)
                : rf
            )
            return `/${p}/${f}`
          },
          {
            unsafe: true,
          }
        )
      }

      /** */
    },
    /* 4 */
    /** */ function(module, exports, __webpack_require__) {
      const toIndexedObject = __webpack_require__(29)

      const addToUnscopables = __webpack_require__(112)

      const Iterators = __webpack_require__(56)

      const InternalStateModule = __webpack_require__(38)

      const defineIterator = __webpack_require__(119)

      const ARRAY_ITERATOR = 'Array Iterator'
      const setInternalState = InternalStateModule.set
      const getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR) // `Array.prototype.entries` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.entries
      // `Array.prototype.keys` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.keys
      // `Array.prototype.values` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.values
      // `Array.prototype[@@iterator]` method
      // https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
      // `CreateArrayIterator` internal method
      // https://tc39.github.io/ecma262/#sec-createarrayiterator

      module.exports = defineIterator(
        Array,
        'Array',
        function(iterated, kind) {
          setInternalState(this, {
            type: ARRAY_ITERATOR,
            target: toIndexedObject(iterated),
            // target
            index: 0,
            // next index
            kind, // kind
          }) // `%ArrayIteratorPrototype%.next` method
          // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
        },
        function() {
          const state = getInternalState(this)
          const {target} = state
          const {kind} = state
          const index = state.index++

          if (!target || index >= target.length) {
            state.target = undefined
            return {
              value: undefined,
              done: true,
            }
          }

          if (kind == 'keys') {
            return {
              value: index,
              done: false,
            }
          }
          if (kind == 'values') {
            return {
              value: target[index],
              done: false,
            }
          }
          return {
            value: [index, target[index]],
            done: false,
          }
        },
        'values'
      ) // argumentsList[@@iterator] is %ArrayProto_values%
      // https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
      // https://tc39.github.io/ecma262/#sec-createmappedargumentsobject

      Iterators.Arguments = Iterators.Array // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

      addToUnscopables('keys')
      addToUnscopables('values')
      addToUnscopables('entries')

      /** */
    },
    /* 5 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        5
      )
      /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        10
      )
      /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        11
      )
      /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        1
      )

      const $ = __webpack_require__(6)

      const global = __webpack_require__(8)

      const IS_PURE = __webpack_require__(45)

      const DESCRIPTORS = __webpack_require__(18)

      const NATIVE_SYMBOL = __webpack_require__(116)

      const fails = __webpack_require__(9)

      const has = __webpack_require__(20)

      const isArray = __webpack_require__(60)

      const isObject = __webpack_require__(12)

      const anObject = __webpack_require__(17)

      const toObject = __webpack_require__(31)

      const toIndexedObject = __webpack_require__(29)

      const toPrimitive = __webpack_require__(62)

      const createPropertyDescriptor = __webpack_require__(50)

      const nativeObjectCreate = __webpack_require__(64)

      const objectKeys = __webpack_require__(88)

      const getOwnPropertyNamesModule = __webpack_require__(63)

      const getOwnPropertyNamesExternal = __webpack_require__(152)

      const getOwnPropertySymbolsModule = __webpack_require__(87)

      const getOwnPropertyDescriptorModule = __webpack_require__(49)

      const definePropertyModule = __webpack_require__(19)

      const propertyIsEnumerableModule = __webpack_require__(77)

      const hide = __webpack_require__(30)

      const redefine = __webpack_require__(25)

      const shared = __webpack_require__(51)

      const sharedKey = __webpack_require__(65)

      const hiddenKeys = __webpack_require__(53)

      const uid = __webpack_require__(66)

      const wellKnownSymbol = __webpack_require__(7)

      const wrappedWellKnownSymbolModule = __webpack_require__(118)

      const defineWellKnownSymbol = __webpack_require__(89)

      const setToStringTag = __webpack_require__(40)

      const InternalStateModule = __webpack_require__(38)

      const $forEach = __webpack_require__(67).forEach

      const HIDDEN = sharedKey('hidden')
      const SYMBOL = 'Symbol'
      const PROTOTYPE = 'prototype'
      const TO_PRIMITIVE = wellKnownSymbol('toPrimitive')
      const setInternalState = InternalStateModule.set
      const getInternalState = InternalStateModule.getterFor(SYMBOL)
      const ObjectPrototype = Object[PROTOTYPE]
      let $Symbol = global.Symbol
      const {JSON} = global
      const nativeJSONStringify = JSON && JSON.stringify
      const nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f
      const nativeDefineProperty = definePropertyModule.f
      const nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f
      const nativePropertyIsEnumerable = propertyIsEnumerableModule.f
      const AllSymbols = shared('symbols')
      const ObjectPrototypeSymbols = shared('op-symbols')
      const StringToSymbolRegistry = shared('string-to-symbol-registry')
      const SymbolToStringRegistry = shared('symbol-to-string-registry')
      const WellKnownSymbolsStore = shared('wks')
      const {QObject} = global // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

      let USE_SETTER =
        !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

      const setSymbolDescriptor =
        DESCRIPTORS &&
        fails(function() {
          return (
            nativeObjectCreate(
              nativeDefineProperty({}, 'a', {
                get: function get() {
                  return nativeDefineProperty(this, 'a', {
                    value: 7,
                  }).a
                },
              })
            ).a != 7
          )
        })
          ? function(O, P, Attributes) {
              const ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(
                ObjectPrototype,
                P
              )
              if (ObjectPrototypeDescriptor) {
                delete ObjectPrototype[P]
              }
              nativeDefineProperty(O, P, Attributes)

              if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
                nativeDefineProperty(
                  ObjectPrototype,
                  P,
                  ObjectPrototypeDescriptor
                )
              }
            }
          : nativeDefineProperty

      const wrap = function wrap(tag, description) {
        const symbol = (AllSymbols[tag] = nativeObjectCreate(
          $Symbol[PROTOTYPE]
        ))
        setInternalState(symbol, {
          type: SYMBOL,
          tag,
          description,
        })
        if (!DESCRIPTORS) {
          symbol.description = description
        }
        return symbol
      }

      const isSymbol =
        NATIVE_SYMBOL && typeof $Symbol.iterator === 'symbol'
          ? function(it) {
              return typeof it === 'symbol'
            }
          : function(it) {
              return new Object(it) instanceof $Symbol
            }

      var $defineProperty = function defineProperty(O, P, Attributes) {
        if (O === ObjectPrototype) {
          $defineProperty(ObjectPrototypeSymbols, P, Attributes)
        }
        anObject(O)
        const key = toPrimitive(P, true)
        anObject(Attributes)

        if (has(AllSymbols, key)) {
          if (!Attributes.enumerable) {
            if (!has(O, HIDDEN)) {
              nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}))
            }
            O[HIDDEN][key] = true
          } else {
            if (has(O, HIDDEN) && O[HIDDEN][key]) {
              O[HIDDEN][key] = false
            }
            Attributes = nativeObjectCreate(Attributes, {
              enumerable: createPropertyDescriptor(0, false),
            })
          }

          return setSymbolDescriptor(O, key, Attributes)
        }

        return nativeDefineProperty(O, key, Attributes)
      }

      const $defineProperties = function defineProperties(O, Properties) {
        anObject(O)
        const properties = toIndexedObject(Properties)
        const keys = objectKeys(properties).concat(
          $getOwnPropertySymbols(properties)
        )
        $forEach(keys, function(key) {
          if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) {
            $defineProperty(O, key, properties[key])
          }
        })
        return O
      }

      const $create = function create(O, Properties) {
        return Properties === undefined
          ? nativeObjectCreate(O)
          : $defineProperties(nativeObjectCreate(O), Properties)
      }

      var $propertyIsEnumerable = function propertyIsEnumerable(V) {
        const P = toPrimitive(V, true)
        const enumerable = nativePropertyIsEnumerable.call(this, P)
        if (
          this === ObjectPrototype &&
          has(AllSymbols, P) &&
          !has(ObjectPrototypeSymbols, P)
        ) {
          return false
        }
        return enumerable ||
          !has(this, P) ||
          !has(AllSymbols, P) ||
          (has(this, HIDDEN) && this[HIDDEN][P])
          ? enumerable
          : true
      }

      const $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(
        O,
        P
      ) {
        const it = toIndexedObject(O)
        const key = toPrimitive(P, true)
        if (
          it === ObjectPrototype &&
          has(AllSymbols, key) &&
          !has(ObjectPrototypeSymbols, key)
        ) {
          return
        }
        const descriptor = nativeGetOwnPropertyDescriptor(it, key)

        if (
          descriptor &&
          has(AllSymbols, key) &&
          !(has(it, HIDDEN) && it[HIDDEN][key])
        ) {
          descriptor.enumerable = true
        }

        return descriptor
      }

      const $getOwnPropertyNames = function getOwnPropertyNames(O) {
        const names = nativeGetOwnPropertyNames(toIndexedObject(O))
        const result = []
        $forEach(names, function(key) {
          if (!has(AllSymbols, key) && !has(hiddenKeys, key)) {
            result.push(key)
          }
        })
        return result
      }

      var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
        const IS_OBJECT_PROTOTYPE = O === ObjectPrototype
        const names = nativeGetOwnPropertyNames(
          IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O)
        )
        const result = []
        $forEach(names, function(key) {
          if (
            has(AllSymbols, key) &&
            (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))
          ) {
            result.push(AllSymbols[key])
          }
        })
        return result
      } // `Symbol` constructor
      // https://tc39.github.io/ecma262/#sec-symbol-constructor

      if (!NATIVE_SYMBOL) {
        $Symbol = function Symbol() {
          if (this instanceof $Symbol) {
            throw new TypeError('Symbol is not a constructor')
          }
          const description =
            !arguments.length || arguments[0] === undefined
              ? undefined
              : String(arguments[0])
          const tag = uid(description)

          const setter = function setter(value) {
            if (this === ObjectPrototype) {
              setter.call(ObjectPrototypeSymbols, value)
            }
            if (has(this, HIDDEN) && has(this[HIDDEN], tag)) {
              this[HIDDEN][tag] = false
            }
            setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value))
          }

          if (DESCRIPTORS && USE_SETTER) {
            setSymbolDescriptor(ObjectPrototype, tag, {
              configurable: true,
              set: setter,
            })
          }
          return wrap(tag, description)
        }

        redefine($Symbol[PROTOTYPE], 'toString', function toString() {
          return getInternalState(this).tag
        })
        propertyIsEnumerableModule.f = $propertyIsEnumerable
        definePropertyModule.f = $defineProperty
        getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor
        getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames
        getOwnPropertySymbolsModule.f = $getOwnPropertySymbols

        if (DESCRIPTORS) {
          // https://github.com/tc39/proposal-Symbol-description
          nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
            configurable: true,
            get: function description() {
              return getInternalState(this).description
            },
          })

          if (!IS_PURE) {
            redefine(
              ObjectPrototype,
              'propertyIsEnumerable',
              $propertyIsEnumerable,
              {
                unsafe: true,
              }
            )
          }
        }

        wrappedWellKnownSymbolModule.f = function(name) {
          return wrap(wellKnownSymbol(name), name)
        }
      }

      $(
        {
          global: true,
          wrap: true,
          forced: !NATIVE_SYMBOL,
          sham: !NATIVE_SYMBOL,
        },
        {
          Symbol: $Symbol,
        }
      )
      $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
        defineWellKnownSymbol(name)
      })
      $(
        {
          target: SYMBOL,
          stat: true,
          forced: !NATIVE_SYMBOL,
        },
        {
          // `Symbol.for` method
          // https://tc39.github.io/ecma262/#sec-symbol.for
          for: function _for(key) {
            const string = String(key)
            if (has(StringToSymbolRegistry, string)) {
              return StringToSymbolRegistry[string]
            }
            const symbol = $Symbol(string)
            StringToSymbolRegistry[string] = symbol
            SymbolToStringRegistry[symbol] = string
            return symbol
          },
          // `Symbol.keyFor` method
          // https://tc39.github.io/ecma262/#sec-symbol.keyfor
          keyFor: function keyFor(sym) {
            if (!isSymbol(sym)) {
              throw new TypeError(`${sym} is not a symbol`)
            }
            if (has(SymbolToStringRegistry, sym)) {
              return SymbolToStringRegistry[sym]
            }
          },
          useSetter: function useSetter() {
            USE_SETTER = true
          },
          useSimple: function useSimple() {
            USE_SETTER = false
          },
        }
      )
      $(
        {
          target: 'Object',
          stat: true,
          forced: !NATIVE_SYMBOL,
          sham: !DESCRIPTORS,
        },
        {
          // `Object.create` method
          // https://tc39.github.io/ecma262/#sec-object.create
          create: $create,
          // `Object.defineProperty` method
          // https://tc39.github.io/ecma262/#sec-object.defineproperty
          defineProperty: $defineProperty,
          // `Object.defineProperties` method
          // https://tc39.github.io/ecma262/#sec-object.defineproperties
          defineProperties: $defineProperties,
          // `Object.getOwnPropertyDescriptor` method
          // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
          getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
        }
      )
      $(
        {
          target: 'Object',
          stat: true,
          forced: !NATIVE_SYMBOL,
        },
        {
          // `Object.getOwnPropertyNames` method
          // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
          getOwnPropertyNames: $getOwnPropertyNames,
          // `Object.getOwnPropertySymbols` method
          // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
          getOwnPropertySymbols: $getOwnPropertySymbols,
        }
      ) // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
      // https://bugs.chromium.org/p/v8/issues/detail?id=3443

      $(
        {
          target: 'Object',
          stat: true,
          forced: fails(function() {
            getOwnPropertySymbolsModule.f(1)
          }),
        },
        {
          getOwnPropertySymbols: function getOwnPropertySymbols(it) {
            return getOwnPropertySymbolsModule.f(toObject(it))
          },
        }
      ) // `JSON.stringify` method behavior with symbols
      // https://tc39.github.io/ecma262/#sec-json.stringify

      JSON &&
        $(
          {
            target: 'JSON',
            stat: true,
            forced:
              !NATIVE_SYMBOL ||
              fails(function() {
                const symbol = $Symbol() // MS Edge converts symbol values to JSON as {}

                return (
                  nativeJSONStringify([symbol]) != '[null]' || // WebKit converts symbol values to JSON as null
                  nativeJSONStringify({
                    a: symbol,
                  }) != '{}' || // V8 throws on boxed symbols
                  nativeJSONStringify(new Object(symbol)) != '{}'
                )
              }),
          },
          {
            stringify: function stringify(it) {
              const arguments_ = [it]
              let index = 1
              let replacer
              let $replacer

              while (arguments.length > index) {
                arguments_.push(arguments[index++])
              }

              $replacer = replacer = arguments_[1]
              if ((!isObject(replacer) && it === undefined) || isSymbol(it)) {
                return
              } // IE8 returns string on undefined

              if (!isArray(replacer)) {
                replacer = function replacer(key, value) {
                  if (typeof $replacer === 'function') {
                    value = $replacer.call(this, key, value)
                  }
                  if (!isSymbol(value)) {
                    return value
                  }
                }
              }
              arguments_[1] = replacer
              return nativeJSONStringify.apply(JSON, arguments_)
            },
          }
        ) // `Symbol.prototype[@@toPrimitive]` method
      // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive

      if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
        hide($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf)
      } // `Symbol.prototype[@@toStringTag]` property
      // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag

      setToStringTag($Symbol, SYMBOL)
      hiddenKeys[HIDDEN] = true

      /** */
    },
    /* 6 */
    /** */ function(module, exports, __webpack_require__) {
      const global = __webpack_require__(8)

      const getOwnPropertyDescriptor = __webpack_require__(49).f

      const hide = __webpack_require__(30)

      const redefine = __webpack_require__(25)

      const setGlobal = __webpack_require__(81)

      const copyConstructorProperties = __webpack_require__(113)

      const isForced = __webpack_require__(61)
      /*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/

      module.exports = function(options, source) {
        const TARGET = options.target
        const GLOBAL = options.global
        const STATIC = options.stat
        let FORCED
        let target
        let key
        let targetProperty
        let sourceProperty
        let descriptor

        if (GLOBAL) {
          target = global
        } else if (STATIC) {
          target = global[TARGET] || setGlobal(TARGET, {})
        } else {
          target = (global[TARGET] || {}).prototype
        }

        if (target) {
          for (key in source) {
            sourceProperty = source[key]

            if (options.noTargetGet) {
              descriptor = getOwnPropertyDescriptor(target, key)
              targetProperty = descriptor && descriptor.value
            } else {
              targetProperty = target[key]
            }

            FORCED = isForced(
              GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key,
              options.forced
            ) // contained in target

            if (!FORCED && targetProperty !== undefined) {
              if (typeof sourceProperty === typeof targetProperty) {
                continue
              }
              copyConstructorProperties(sourceProperty, targetProperty)
            } // add a flag to not completely full polyfills

            if (options.sham || (targetProperty && targetProperty.sham)) {
              hide(sourceProperty, 'sham', true)
            } // extend global

            redefine(target, key, sourceProperty, options)
          }
        }
      }

      /** */
    },
    /* 7 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          1
        )

        const global = __webpack_require__(8)

        const shared = __webpack_require__(51)

        const uid = __webpack_require__(66)

        const NATIVE_SYMBOL = __webpack_require__(116)

        const {Symbol} = global
        const store = shared('wks')

        module.exports = function(name) {
          return (
            store[name] ||
            (store[name] =
              (NATIVE_SYMBOL && Symbol[name]) ||
              (NATIVE_SYMBOL ? Symbol : uid)(`Symbol.${name}`))
          )
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 8 */
    /** */ function(module, exports) {
      const O = 'object'

      const check = function check(it) {
        return it && it.Math == Math && it
      } // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028

      module.exports = // eslint-disable-next-line no-undef
        check(typeof globalThis === O && globalThis) ||
        check(typeof window === O && window) ||
        check(typeof self === O && self) ||
        check(typeof global === O && global) || // eslint-disable-next-line no-new-func
        new Function('return this')()

      /** */
    },
    /* 9 */
    /** */ function(module, exports) {
      module.exports = function(exec) {
        try {
          return !!exec()
        } catch (error) {
          return true
        }
      }

      /** */
    },
    /* 10 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        5
      )
      /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        10
      )
      /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        2
      )
      /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        1
      )
      /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
        3
      )
      /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
        14
      )
      // `Symbol.prototype.description` getter
      // https://tc39.github.io/ecma262/#sec-symbol.prototype.description

      const $ = __webpack_require__(6)

      const DESCRIPTORS = __webpack_require__(18)

      const global = __webpack_require__(8)

      const has = __webpack_require__(20)

      const isObject = __webpack_require__(12)

      const defineProperty = __webpack_require__(19).f

      const copyConstructorProperties = __webpack_require__(113)

      const NativeSymbol = global.Symbol

      if (
        DESCRIPTORS &&
        typeof NativeSymbol === 'function' &&
        (!('description' in NativeSymbol.prototype) || // Safari 12 bug
          NativeSymbol().description !== undefined)
      ) {
        const EmptyStringDescriptionStore = {} // wrap Symbol constructor for correct work with undefined description

        var SymbolWrapper = function Symbol() {
          const description =
            arguments.length === 0 || arguments[0] === undefined
              ? undefined
              : String(arguments[0])
          const result =
            this instanceof SymbolWrapper
              ? new NativeSymbol(description) // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
              : description === undefined
              ? NativeSymbol()
              : NativeSymbol(description)
          if (description === '') {
            EmptyStringDescriptionStore[result] = true
          }
          return result
        }

        copyConstructorProperties(SymbolWrapper, NativeSymbol)
        const symbolPrototype = (SymbolWrapper.prototype =
          NativeSymbol.prototype)
        symbolPrototype.constructor = SymbolWrapper
        const symbolToString = symbolPrototype.toString
        const native = String(NativeSymbol('test')) == 'Symbol(test)'
        const regexp = /^Symbol\((.*)\)[^)]+$/
        defineProperty(symbolPrototype, 'description', {
          configurable: true,
          get: function description() {
            const symbol = isObject(this) ? this.valueOf() : this
            const string = symbolToString.call(symbol)
            if (has(EmptyStringDescriptionStore, symbol)) {
              return ''
            }
            const desc = native
              ? string.slice(7, -1)
              : string.replace(regexp, '$1')
            return desc === '' ? undefined : desc
          },
        })
        $(
          {
            global: true,
            forced: true,
          },
          {
            Symbol: SymbolWrapper,
          }
        )
      }

      /** */
    },
    /* 11 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        11
      )

      const $ = __webpack_require__(6)

      const fails = __webpack_require__(9)

      const isArray = __webpack_require__(60)

      const isObject = __webpack_require__(12)

      const toObject = __webpack_require__(31)

      const toLength = __webpack_require__(22)

      const createProperty = __webpack_require__(57)

      const arraySpeciesCreate = __webpack_require__(90)

      const arrayMethodHasSpeciesSupport = __webpack_require__(58)

      const wellKnownSymbol = __webpack_require__(7)

      const IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable')
      const MAX_SAFE_INTEGER = 0x1fffffffffffff
      const MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded'
      const IS_CONCAT_SPREADABLE_SUPPORT = !fails(function() {
        const array = []
        array[IS_CONCAT_SPREADABLE] = false
        return array.concat()[0] !== array
      })
      const SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat')

      const isConcatSpreadable = function isConcatSpreadable(O) {
        if (!isObject(O)) {
          return false
        }
        const spreadable = O[IS_CONCAT_SPREADABLE]
        return spreadable !== undefined ? !!spreadable : isArray(O)
      }

      const FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT // `Array.prototype.concat` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.concat
      // with adding support of @@isConcatSpreadable and @@species

      $(
        {
          target: 'Array',
          proto: true,
          forced: FORCED,
        },
        {
          concat: function concat(argument) {
            // eslint-disable-line no-unused-vars
            const O = toObject(this)
            const A = arraySpeciesCreate(O, 0)
            let n = 0
            let i
            let k
            let length
            let length_
            let E

            for (i = -1, length = arguments.length; i < length; i++) {
              E = i === -1 ? O : arguments[i]

              if (isConcatSpreadable(E)) {
                length_ = toLength(E.length)
                if (n + length_ > MAX_SAFE_INTEGER) {
                  throw new TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED)
                }

                for (k = 0; k < length_; k++, n++) {
                  if (k in E) {
                    createProperty(A, n, E[k])
                  }
                }
              } else {
                if (n >= MAX_SAFE_INTEGER) {
                  throw new TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED)
                }
                createProperty(A, n++, E)
              }
            }

            A.length = n
            return A
          },
        }
      )

      /** */
    },
    /* 12 */
    /** */ function(module, exports) {
      module.exports = function(it) {
        return typeof it === 'object' ? it !== null : typeof it === 'function'
      }

      /** */
    },
    /* 13 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        13
      )

      const $ = __webpack_require__(6)

      const $filter = __webpack_require__(67).filter

      const arrayMethodHasSpeciesSupport = __webpack_require__(58) // `Array.prototype.filter` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.filter
      // with adding support of @@species

      $(
        {
          target: 'Array',
          proto: true,
          forced: !arrayMethodHasSpeciesSupport('filter'),
        },
        {
          filter: function filter(
            callbackfn
            /* , thisArg */
          ) {
            return $filter(
              this,
              callbackfn,
              arguments.length > 1 ? arguments[1] : undefined
            )
          },
        }
      )

      /** */
    },
    /* 14 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        11
      )
      /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        2
      )

      const fixRegExpWellKnownSymbolLogic = __webpack_require__(79)

      const anObject = __webpack_require__(17)

      const toObject = __webpack_require__(31)

      const toLength = __webpack_require__(22)

      const toInteger = __webpack_require__(39)

      const requireObjectCoercible = __webpack_require__(26)

      const advanceStringIndex = __webpack_require__(96)

      const regExpExec = __webpack_require__(97)

      const {max} = Math
      const {min} = Math
      const {floor} = Math
      const SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g
      const SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g

      const maybeToString = function maybeToString(it) {
        return it === undefined ? it : String(it)
      } // @@replace logic

      fixRegExpWellKnownSymbolLogic('replace', 2, function(
        REPLACE,
        nativeReplace,
        maybeCallNative
      ) {
        return [
          // `String.prototype.replace` method
          // https://tc39.github.io/ecma262/#sec-string.prototype.replace
          function replace(searchValue, replaceValue) {
            const O = requireObjectCoercible(this)
            const replacer =
              searchValue == undefined ? undefined : searchValue[REPLACE]
            return replacer !== undefined
              ? replacer.call(searchValue, O, replaceValue)
              : nativeReplace.call(String(O), searchValue, replaceValue)
          }, // `RegExp.prototype[@@replace]` method
          // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
          function(regexp, replaceValue) {
            const res = maybeCallNative(
              nativeReplace,
              regexp,
              this,
              replaceValue
            )
            if (res.done) {
              return res.value
            }
            const rx = anObject(regexp)
            const S = String(this)
            const functionalReplace = typeof replaceValue === 'function'
            if (!functionalReplace) {
              replaceValue = String(replaceValue)
            }
            const {global} = rx

            if (global) {
              var fullUnicode = rx.unicode
              rx.lastIndex = 0
            }

            const results = []

            while (true) {
              var result = regExpExec(rx, S)
              if (result === null) {
                break
              }
              results.push(result)
              if (!global) {
                break
              }
              const matchString = String(result[0])
              if (matchString === '') {
                rx.lastIndex = advanceStringIndex(
                  S,
                  toLength(rx.lastIndex),
                  fullUnicode
                )
              }
            }

            let accumulatedResult = ''
            let nextSourcePosition = 0

            for (const element of results) {
              result = element
              const matched = String(result[0])
              const position = max(min(toInteger(result.index), S.length), 0)
              const captures = [] // NOTE: This is equivalent to
              //   captures = result.slice(1).map(maybeToString)
              // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
              // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
              // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

              for (let j = 1; j < result.length; j++) {
                captures.push(maybeToString(result[j]))
              }

              const namedCaptures = result.groups

              if (functionalReplace) {
                const replacerArguments = [matched].concat(
                  captures,
                  position,
                  S
                )
                if (namedCaptures !== undefined) {
                  replacerArguments.push(namedCaptures)
                }
                var replacement = String(
                  replaceValue.apply(undefined, replacerArguments)
                )
              } else {
                replacement = getSubstitution(
                  matched,
                  S,
                  position,
                  captures,
                  namedCaptures,
                  replaceValue
                )
              }

              if (position >= nextSourcePosition) {
                accumulatedResult +=
                  S.slice(nextSourcePosition, position) + replacement
                nextSourcePosition = position + matched.length
              }
            }

            return accumulatedResult + S.slice(nextSourcePosition)
          },
        ] // https://tc39.github.io/ecma262/#sec-getsubstitution

        function getSubstitution(
          matched,
          string,
          position,
          captures,
          namedCaptures,
          replacement
        ) {
          const tailPos = position + matched.length
          const m = captures.length
          let symbols = SUBSTITUTION_SYMBOLS_NO_NAMED

          if (namedCaptures !== undefined) {
            namedCaptures = toObject(namedCaptures)
            symbols = SUBSTITUTION_SYMBOLS
          }

          return nativeReplace.call(replacement, symbols, function(match, ch) {
            let capture

            switch (ch.charAt(0)) {
              case '$':
                return '$'

              case '&':
                return matched

              case '`':
                return string.slice(0, position)

              case "'":
                return string.slice(tailPos)

              case '<':
                capture = namedCaptures[ch.slice(1, -1)]
                break

              default:
                // \d\d?
                var n = Number(ch)
                if (n === 0) {
                  return match
                }

                if (n > m) {
                  const f = floor(n / 10)
                  if (f === 0) {
                    return match
                  }
                  if (f <= m) {
                    return captures[f - 1] === undefined
                      ? ch.charAt(1)
                      : captures[f - 1] + ch.charAt(1)
                  }
                  return match
                }

                capture = captures[n - 1]
            }

            return capture === undefined ? '' : capture
          })
        }
      })

      /** */
    },
    /* 15 */
    /** */ function(module, exports) {
      module.exports = require('path')

      /** */
    },
    /* 16 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        16
      )
      /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        3
      )

      const DESCRIPTORS = __webpack_require__(18)

      const global = __webpack_require__(8)

      const isForced = __webpack_require__(61)

      const inheritIfRequired = __webpack_require__(127)

      const defineProperty = __webpack_require__(19).f

      const getOwnPropertyNames = __webpack_require__(63).f

      const isRegExp = __webpack_require__(98)

      const getFlags = __webpack_require__(72)

      const redefine = __webpack_require__(25)

      const fails = __webpack_require__(9)

      const setSpecies = __webpack_require__(99)

      const wellKnownSymbol = __webpack_require__(7)

      const MATCH = wellKnownSymbol('match')
      const NativeRegExp = global.RegExp
      const RegExpPrototype = NativeRegExp.prototype
      const re1 = /a/g
      const re2 = /a/g // "new" should create a new object, old webkit bug

      const CORRECT_NEW = new NativeRegExp(re1) !== re1
      const FORCED =
        DESCRIPTORS &&
        isForced(
          'RegExp',
          !CORRECT_NEW ||
            fails(function() {
              re2[MATCH] = false // RegExp constructor can alter flags and IsRegExp works correct with @@match

              return (
                NativeRegExp(re1) != re1 ||
                NativeRegExp(re2) == re2 ||
                NativeRegExp(re1, 'i') != '/a/i'
              )
            })
        ) // `RegExp` constructor
      // https://tc39.github.io/ecma262/#sec-regexp-constructor

      if (FORCED) {
        var RegExpWrapper = function RegExp(pattern, flags) {
          const thisIsRegExp = this instanceof RegExpWrapper
          let patternIsRegExp = isRegExp(pattern)
          const flagsAreUndefined = flags === undefined
          return !thisIsRegExp &&
            patternIsRegExp &&
            pattern.constructor === RegExpWrapper &&
            flagsAreUndefined
            ? pattern
            : inheritIfRequired(
                CORRECT_NEW
                  ? new NativeRegExp(
                      patternIsRegExp && !flagsAreUndefined
                        ? pattern.source
                        : pattern,
                      flags
                    )
                  : NativeRegExp(
                      (patternIsRegExp = pattern instanceof RegExpWrapper)
                        ? pattern.source
                        : pattern,
                      patternIsRegExp && flagsAreUndefined
                        ? getFlags.call(pattern)
                        : flags
                    ),
                thisIsRegExp ? this : RegExpPrototype,
                RegExpWrapper
              )
        }

        const proxy = function proxy(key) {
          key in RegExpWrapper ||
            defineProperty(RegExpWrapper, key, {
              configurable: true,
              get: function get() {
                return NativeRegExp[key]
              },
              set: function set(it) {
                NativeRegExp[key] = it
              },
            })
        }

        const keys = getOwnPropertyNames(NativeRegExp)
        let index = 0

        while (keys.length > index) {
          proxy(keys[index++])
        }

        RegExpPrototype.constructor = RegExpWrapper
        RegExpWrapper.prototype = RegExpPrototype
        redefine(global, 'RegExp', RegExpWrapper)
      } // https://tc39.github.io/ecma262/#sec-get-regexp-@@species

      setSpecies('RegExp')

      /** */
    },
    /* 17 */
    /** */ function(module, exports, __webpack_require__) {
      const isObject = __webpack_require__(12)

      module.exports = function(it) {
        if (!isObject(it)) {
          throw new TypeError(`${String(it)} is not an object`)
        }

        return it
      }

      /** */
    },
    /* 18 */
    /** */ function(module, exports, __webpack_require__) {
      const fails = __webpack_require__(9) // Thank's IE8 for his funny defineProperty

      module.exports = !fails(function() {
        return (
          Object.defineProperty({}, 'a', {
            get: function get() {
              return 7
            },
          }).a != 7
        )
      })

      /** */
    },
    /* 19 */
    /** */ function(module, exports, __webpack_require__) {
      const DESCRIPTORS = __webpack_require__(18)

      const IE8_DOM_DEFINE = __webpack_require__(110)

      const anObject = __webpack_require__(17)

      const toPrimitive = __webpack_require__(62)

      const nativeDefineProperty = Object.defineProperty // `Object.defineProperty` method
      // https://tc39.github.io/ecma262/#sec-object.defineproperty

      exports.f = DESCRIPTORS
        ? nativeDefineProperty
        : function defineProperty(O, P, Attributes) {
            anObject(O)
            P = toPrimitive(P, true)
            anObject(Attributes)
            if (IE8_DOM_DEFINE) {
              try {
                return nativeDefineProperty(O, P, Attributes)
              } catch (error) {
                /* empty */
              }
            }
            if ('get' in Attributes || 'set' in Attributes) {
              throw new TypeError('Accessors not supported')
            }
            if ('value' in Attributes) {
              O[P] = Attributes.value
            }
            return O
          }

      /** */
    },
    /* 20 */
    /** */ function(module, exports) {
      const {hasOwnProperty} = {}

      module.exports = function(it, key) {
        return hasOwnProperty.call(it, key)
      }

      /** */
    },
    /* 21 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        21
      )

      const $ = __webpack_require__(6)

      const $indexOf = __webpack_require__(83).indexOf

      const sloppyArrayMethod = __webpack_require__(85)

      const nativeIndexOf = [].indexOf
      const NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0
      const SLOPPY_METHOD = sloppyArrayMethod('indexOf') // `Array.prototype.indexOf` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.indexof

      $(
        {
          target: 'Array',
          proto: true,
          forced: NEGATIVE_ZERO || SLOPPY_METHOD,
        },
        {
          indexOf: function indexOf(
            searchElement
            /* , fromIndex = 0 */
          ) {
            return NEGATIVE_ZERO // convert -0 to +0
              ? Reflect.apply(nativeIndexOf, this, arguments) || 0
              : $indexOf(
                  this,
                  searchElement,
                  arguments.length > 1 ? arguments[1] : undefined
                )
          },
        }
      )

      /** */
    },
    /* 22 */
    /** */ function(module, exports, __webpack_require__) {
      const toInteger = __webpack_require__(39)

      const {min} = Math // `ToLength` abstract operation
      // https://tc39.github.io/ecma262/#sec-tolength

      module.exports = function(argument) {
        return argument > 0 ? min(toInteger(argument), 0x1fffffffffffff) : 0 // 2 ** 53 - 1 == 9007199254740991
      }

      /** */
    },
    /* 23 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        23
      )

      const $ = __webpack_require__(6)

      const $map = __webpack_require__(67).map

      const arrayMethodHasSpeciesSupport = __webpack_require__(58) // `Array.prototype.map` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.map
      // with adding support of @@species

      $(
        {
          target: 'Array',
          proto: true,
          forced: !arrayMethodHasSpeciesSupport('map'),
        },
        {
          map: function map(
            callbackfn
            /* , thisArg */
          ) {
            return $map(
              this,
              callbackfn,
              arguments.length > 1 ? arguments[1] : undefined
            )
          },
        }
      )

      /** */
    },
    /* 24 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        2
      )
      /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        16
      )
      /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        3
      )
      /* harmony import */ const core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        24
      )

      const fixRegExpWellKnownSymbolLogic = __webpack_require__(79)

      const isRegExp = __webpack_require__(98)

      const anObject = __webpack_require__(17)

      const requireObjectCoercible = __webpack_require__(26)

      const speciesConstructor = __webpack_require__(100)

      const advanceStringIndex = __webpack_require__(96)

      const toLength = __webpack_require__(22)

      const callRegExpExec = __webpack_require__(97)

      const regexpExec = __webpack_require__(95)

      const fails = __webpack_require__(9)

      const arrayPush = [].push
      const {min} = Math
      const MAX_UINT32 = 0xffffffff // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

      const SUPPORTS_Y = !fails(function() {
        return !new RegExp(MAX_UINT32, 'y')
      }) // @@split logic

      fixRegExpWellKnownSymbolLogic(
        'split',
        2,
        function(SPLIT, nativeSplit, maybeCallNative) {
          let internalSplit

          if (
            'abbc'.split(/(b)*/)[1] == 'c' ||
            'test'.split(/(?:)/, -1).length != 4 ||
            'ab'.split(/(?:ab)*/).length != 2 ||
            '.'.split(/(.?)(.?)/).length != 4 ||
            '.'.split(/()()/).length > 1 ||
            ''.split(/.?/).length
          ) {
            // based on es5-shim implementation, need to rework it
            internalSplit = function internalSplit(separator, limit) {
              const string = String(requireObjectCoercible(this))
              const lim = limit === undefined ? MAX_UINT32 : limit >>> 0
              if (lim === 0) {
                return []
              }
              if (separator === undefined) {
                return [string]
              } // If `separator` is not a regex, use native split

              if (!isRegExp(separator)) {
                return nativeSplit.call(string, separator, lim)
              }

              const output = []
              const flags =
                (separator.ignoreCase ? 'i' : '') +
                (separator.multiline ? 'm' : '') +
                (separator.unicode ? 'u' : '') +
                (separator.sticky ? 'y' : '')
              let lastLastIndex = 0 // Make `global` and avoid `lastIndex` issues by working with a copy

              const separatorCopy = new RegExp(separator.source, `${flags}g`)
              let match
              let lastIndex
              let lastLength

              while ((match = regexpExec.call(separatorCopy, string))) {
                lastIndex = separatorCopy.lastIndex

                if (lastIndex > lastLastIndex) {
                  output.push(string.slice(lastLastIndex, match.index))
                  if (match.length > 1 && match.index < string.length) {
                    arrayPush.apply(output, match.slice(1))
                  }
                  lastLength = match[0].length
                  lastLastIndex = lastIndex
                  if (output.length >= lim) {
                    break
                  }
                }

                if (separatorCopy.lastIndex === match.index) {
                  separatorCopy.lastIndex++
                } // Avoid an infinite loop
              }

              if (lastLastIndex === string.length) {
                if (lastLength || !separatorCopy.test('')) {
                  output.push('')
                }
              } else {
                output.push(string.slice(lastLastIndex))
              }

              return output.length > lim ? output.slice(0, lim) : output
            } // Chakra, V8
          } else if ('0'.split(undefined, 0).length) {
            internalSplit = function internalSplit(separator, limit) {
              return separator === undefined && limit === 0
                ? []
                : nativeSplit.call(this, separator, limit)
            }
          } else {
            internalSplit = nativeSplit
          }

          return [
            // `String.prototype.split` method
            // https://tc39.github.io/ecma262/#sec-string.prototype.split
            function split(separator, limit) {
              const O = requireObjectCoercible(this)
              const splitter =
                separator == undefined ? undefined : separator[SPLIT]
              return splitter !== undefined
                ? splitter.call(separator, O, limit)
                : internalSplit.call(String(O), separator, limit)
            }, // `RegExp.prototype[@@split]` method
            // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
            //
            // NOTE: This cannot be properly polyfilled in engines that don't support
            // the 'y' flag.
            function(regexp, limit) {
              const res = maybeCallNative(
                internalSplit,
                regexp,
                this,
                limit,
                internalSplit !== nativeSplit
              )
              if (res.done) {
                return res.value
              }
              const rx = anObject(regexp)
              const S = String(this)
              const C = speciesConstructor(rx, RegExp)
              const unicodeMatching = rx.unicode
              const flags =
                (rx.ignoreCase ? 'i' : '') +
                (rx.multiline ? 'm' : '') +
                (rx.unicode ? 'u' : '') +
                (SUPPORTS_Y ? 'y' : 'g') // ^(? + rx + ) is needed, in combination with some S slicing, to
              // simulate the 'y' flag.

              const splitter = new C(
                SUPPORTS_Y ? rx : `^(?:${rx.source})`,
                flags
              )
              const lim = limit === undefined ? MAX_UINT32 : limit >>> 0
              if (lim === 0) {
                return []
              }
              if (S.length === 0) {
                return callRegExpExec(splitter, S) === null ? [S] : []
              }
              let p = 0
              let q = 0
              const A = []

              while (q < S.length) {
                splitter.lastIndex = SUPPORTS_Y ? q : 0
                const z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q))
                var e

                if (
                  z === null ||
                  (e = min(
                    toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)),
                    S.length
                  )) === p
                ) {
                  q = advanceStringIndex(S, q, unicodeMatching)
                } else {
                  A.push(S.slice(p, q))
                  if (A.length === lim) {
                    return A
                  }

                  for (let i = 1; i <= z.length - 1; i++) {
                    A.push(z[i])
                    if (A.length === lim) {
                      return A
                    }
                  }

                  q = p = e
                }
              }

              A.push(S.slice(p))
              return A
            },
          ]
        },
        !SUPPORTS_Y
      )

      /** */
    },
    /* 25 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          24
        )

        const global = __webpack_require__(8)

        const shared = __webpack_require__(51)

        const hide = __webpack_require__(30)

        const has = __webpack_require__(20)

        const setGlobal = __webpack_require__(81)

        const nativeFunctionToString = __webpack_require__(111)

        const InternalStateModule = __webpack_require__(38)

        const getInternalState = InternalStateModule.get
        const enforceInternalState = InternalStateModule.enforce
        const TEMPLATE = String(nativeFunctionToString).split('toString')
        shared('inspectSource', function(it) {
          return nativeFunctionToString.call(it)
        })
        ;(module.exports = function(O, key, value, options) {
          const unsafe = options ? !!options.unsafe : false
          let simple = options ? !!options.enumerable : false
          const noTargetGet = options ? !!options.noTargetGet : false

          if (typeof value === 'function') {
            if (typeof key === 'string' && !has(value, 'name')) {
              hide(value, 'name', key)
            }
            enforceInternalState(value).source = TEMPLATE.join(
              typeof key === 'string' ? key : ''
            )
          }

          if (O === global) {
            if (simple) {
              O[key] = value
            } else {
              setGlobal(key, value)
            }
            return
          }
          if (!unsafe) {
            delete O[key]
          } else if (!noTargetGet && O[key]) {
            simple = true
          }

          if (simple) {
            O[key] = value
          } else {
            hide(O, key, value)
          } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
        })(Function.prototype, 'toString', function toString() {
          return (
            (typeof this === 'function' && getInternalState(this).source) ||
            nativeFunctionToString.call(this)
          )
        })
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 26 */
    /** */ function(module, exports) {
      // `RequireObjectCoercible` abstract operation
      // https://tc39.github.io/ecma262/#sec-requireobjectcoercible
      module.exports = function(it) {
        if (it == undefined) {
          throw new TypeError(`Can't call method on ${it}`)
        }
        return it
      }

      /** */
    },
    /* 27 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        27
      )

      const $ = __webpack_require__(6)

      const from = __webpack_require__(157)

      const checkCorrectnessOfIteration = __webpack_require__(93)

      const INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(
        iterable
      ) {
        Array.from(iterable)
      }) // `Array.from` method
      // https://tc39.github.io/ecma262/#sec-array.from

      $(
        {
          target: 'Array',
          stat: true,
          forced: INCORRECT_ITERATION,
        },
        {
          from,
        }
      )

      /** */
    },
    /* 28 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        16
      )
      /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        3
      )

      const fixRegExpWellKnownSymbolLogic = __webpack_require__(79)

      const anObject = __webpack_require__(17)

      const toLength = __webpack_require__(22)

      const requireObjectCoercible = __webpack_require__(26)

      const advanceStringIndex = __webpack_require__(96)

      const regExpExec = __webpack_require__(97) // @@match logic

      fixRegExpWellKnownSymbolLogic('match', 1, function(
        MATCH,
        nativeMatch,
        maybeCallNative
      ) {
        return [
          // `String.prototype.match` method
          // https://tc39.github.io/ecma262/#sec-string.prototype.match
          function match(regexp) {
            const O = requireObjectCoercible(this)
            const matcher = regexp == undefined ? undefined : regexp[MATCH]
            return matcher !== undefined
              ? matcher.call(regexp, O)
              : new RegExp(regexp)[MATCH](String(O))
          }, // `RegExp.prototype[@@match]` method
          // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
          function(regexp) {
            const res = maybeCallNative(nativeMatch, regexp, this)
            if (res.done) {
              return res.value
            }
            const rx = anObject(regexp)
            const S = String(this)
            if (!rx.global) {
              return regExpExec(rx, S)
            }
            const fullUnicode = rx.unicode
            rx.lastIndex = 0
            const A = []
            let n = 0
            let result

            while ((result = regExpExec(rx, S)) !== null) {
              const matchString = String(result[0])
              A[n] = matchString
              if (matchString === '') {
                rx.lastIndex = advanceStringIndex(
                  S,
                  toLength(rx.lastIndex),
                  fullUnicode
                )
              }
              n++
            }

            return n === 0 ? null : A
          },
        ]
      })

      /** */
    },
    /* 29 */
    /** */ function(module, exports, __webpack_require__) {
      // toObject with fallback for non-array-like ES3 strings
      const IndexedObject = __webpack_require__(78)

      const requireObjectCoercible = __webpack_require__(26)

      module.exports = function(it) {
        return IndexedObject(requireObjectCoercible(it))
      }

      /** */
    },
    /* 30 */
    /** */ function(module, exports, __webpack_require__) {
      const DESCRIPTORS = __webpack_require__(18)

      const definePropertyModule = __webpack_require__(19)

      const createPropertyDescriptor = __webpack_require__(50)

      module.exports = DESCRIPTORS
        ? function(object, key, value) {
            return definePropertyModule.f(
              object,
              key,
              createPropertyDescriptor(1, value)
            )
          }
        : function(object, key, value) {
            object[key] = value
            return object
          }

      /** */
    },
    /* 31 */
    /** */ function(module, exports, __webpack_require__) {
      const requireObjectCoercible = __webpack_require__(26) // `ToObject` abstract operation
      // https://tc39.github.io/ecma262/#sec-toobject

      module.exports = function(argument) {
        return new Object(requireObjectCoercible(argument))
      }

      /** */
    },
    /* 32 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        32
      )

      const $ = __webpack_require__(6)

      const assign = __webpack_require__(161) // `Object.assign` method
      // https://tc39.github.io/ecma262/#sec-object.assign

      $(
        {
          target: 'Object',
          stat: true,
          forced: Object.assign !== assign,
        },
        {
          assign,
        }
      )

      /** */
    },
    /* 33 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          1
        )

        const {toString} = {}

        module.exports = function(it) {
          return toString.call(it).slice(8, -1)
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 34 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        34
      )
      /* harmony import */ const core_js_modules_es_string_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        41
      )

      const $ = __webpack_require__(6)

      const $includes = __webpack_require__(83).includes

      const addToUnscopables = __webpack_require__(112) // `Array.prototype.includes` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.includes

      $(
        {
          target: 'Array',
          proto: true,
        },
        {
          includes: function includes(
            element
            /* , fromIndex = 0 */
          ) {
            return $includes(
              this,
              element,
              arguments.length > 1 ? arguments[1] : undefined
            )
          },
        }
      ) // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

      addToUnscopables('includes')

      /** */
    },
    /* 35 */
    /** */ function(module, exports) {
      module.exports = require('fs')

      /** */
    },
    /* 36 */
    /** */ function(module, exports) {
      module.exports = require('util')

      /** */
    },
    /* 37 */
    /** */ function(module, exports, __webpack_require__) {
      const collection = __webpack_require__(92)

      const collectionStrong = __webpack_require__(141) // `Set` constructor
      // https://tc39.github.io/ecma262/#sec-set-objects

      module.exports = collection(
        'Set',
        function(get) {
          return function Set() {
            return get(this, arguments.length ? arguments[0] : undefined)
          }
        },
        collectionStrong
      )

      /** */
    },
    /* 38 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          91
        )
        /* harmony import */ const core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_2___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_2__
        )

        const NATIVE_WEAK_MAP = __webpack_require__(128)

        const global = __webpack_require__(8)

        const isObject = __webpack_require__(12)

        const hide = __webpack_require__(30)

        const objectHas = __webpack_require__(20)

        const sharedKey = __webpack_require__(65)

        const hiddenKeys = __webpack_require__(53)

        const {WeakMap} = global
        let set
        let get
        let has

        const enforce = function enforce(it) {
          return has(it) ? get(it) : set(it, {})
        }

        const getterFor = function getterFor(TYPE) {
          return function(it) {
            let state

            if (!isObject(it) || (state = get(it)).type !== TYPE) {
              throw new TypeError(`Incompatible receiver, ${TYPE} required`)
            }

            return state
          }
        }

        if (NATIVE_WEAK_MAP) {
          const store = new WeakMap()
          const wmget = store.get
          const wmhas = store.has
          const wmset = store.set

          set = function set(it, metadata) {
            wmset.call(store, it, metadata)
            return metadata
          }

          get = function get(it) {
            return wmget.call(store, it) || {}
          }

          has = function has(it) {
            return wmhas.call(store, it)
          }
        } else {
          const STATE = sharedKey('state')
          hiddenKeys[STATE] = true

          set = function set(it, metadata) {
            hide(it, STATE, metadata)
            return metadata
          }

          get = function get(it) {
            return objectHas(it, STATE) ? it[STATE] : {}
          }

          has = function has(it) {
            return objectHas(it, STATE)
          }
        }

        module.exports = {
          set,
          get,
          has,
          enforce,
          getterFor,
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 39 */
    /** */ function(module, exports) {
      const {ceil} = Math
      const {floor} = Math // `ToInteger` abstract operation
      // https://tc39.github.io/ecma262/#sec-tointeger

      module.exports = function(argument) {
        return isNaN((argument = Number(argument)))
          ? 0
          : (argument > 0 ? floor : ceil)(argument)
      }

      /** */
    },
    /* 40 */
    /** */ function(module, exports, __webpack_require__) {
      const defineProperty = __webpack_require__(19).f

      const has = __webpack_require__(20)

      const wellKnownSymbol = __webpack_require__(7)

      const TO_STRING_TAG = wellKnownSymbol('toStringTag')

      module.exports = function(it, TAG, STATIC) {
        if (it && !has((it = STATIC ? it : it.prototype), TO_STRING_TAG)) {
          defineProperty(it, TO_STRING_TAG, {
            configurable: true,
            value: TAG,
          })
        }
      }

      /** */
    },
    /* 41 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        21
      )

      const $ = __webpack_require__(6)

      const notARegExp = __webpack_require__(129)

      const requireObjectCoercible = __webpack_require__(26)

      const correctIsRegExpLogic = __webpack_require__(130) // `String.prototype.includes` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.includes

      $(
        {
          target: 'String',
          proto: true,
          forced: !correctIsRegExpLogic('includes'),
        },
        {
          includes: function includes(
            searchString
            /* , position = 0 */
          ) {
            return !!~String(requireObjectCoercible(this)).indexOf(
              notARegExp(searchString),
              arguments.length > 1 ? arguments[1] : undefined
            )
          },
        }
      )

      /** */
    },
    /* 42 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_array_sort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        42
      )

      const $ = __webpack_require__(6)

      const aFunction = __webpack_require__(55)

      const toObject = __webpack_require__(31)

      const fails = __webpack_require__(9)

      const sloppyArrayMethod = __webpack_require__(85)

      const nativeSort = [].sort
      const test = [1, 2, 3] // IE8-

      const FAILS_ON_UNDEFINED = fails(function() {
        test.sort(undefined)
      }) // V8 bug

      const FAILS_ON_NULL = fails(function() {
        test.sort(null)
      }) // Old WebKit

      const SLOPPY_METHOD = sloppyArrayMethod('sort')
      const FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || SLOPPY_METHOD // `Array.prototype.sort` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.sort

      $(
        {
          target: 'Array',
          proto: true,
          forced: FORCED,
        },
        {
          sort: function sort(comparefn) {
            return comparefn === undefined
              ? nativeSort.call(toObject(this))
              : nativeSort.call(toObject(this), aFunction(comparefn))
          },
        }
      )

      /** */
    },
    /* 43 */
    /** */ function(module, exports, __webpack_require__) {
      const $ = __webpack_require__(6)

      const DESCRIPTORS = __webpack_require__(18)

      const ownKeys = __webpack_require__(114)

      const toIndexedObject = __webpack_require__(29)

      const getOwnPropertyDescriptorModule = __webpack_require__(49)

      const createProperty = __webpack_require__(57) // `Object.getOwnPropertyDescriptors` method
      // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors

      $(
        {
          target: 'Object',
          stat: true,
          sham: !DESCRIPTORS,
        },
        {
          getOwnPropertyDescriptors: function getOwnPropertyDescriptors(
            object
          ) {
            const O = toIndexedObject(object)
            const getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f
            const keys = ownKeys(O)
            const result = {}
            let index = 0
            let key
            let descriptor

            while (keys.length > index) {
              descriptor = getOwnPropertyDescriptor(O, (key = keys[index++]))
              if (descriptor !== undefined) {
                createProperty(result, key, descriptor)
              }
            }

            return result
          },
        }
      )

      /** */
    },
    /* 44 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.index-of.js
      const es_array_index_of = __webpack_require__(21)

      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
      const es_object_to_string = __webpack_require__(1)

      // CONCATENATED MODULE: ./node_modules/core-js/modules/es.promise.finally.js

      const $ = __webpack_require__(6)

      const IS_PURE = __webpack_require__(45)

      const NativePromise = __webpack_require__(142)

      const getBuiltIn = __webpack_require__(52)

      const speciesConstructor = __webpack_require__(100)

      const promiseResolve = __webpack_require__(143)

      const redefine = __webpack_require__(25) // `Promise.prototype.finally` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.finally

      $(
        {
          target: 'Promise',
          proto: true,
          real: true,
        },
        {
          finally: function _finally(onFinally) {
            const C = speciesConstructor(this, getBuiltIn('Promise'))
            const isFunction = typeof onFinally === 'function'
            return this.then(
              isFunction
                ? function(x) {
                    return promiseResolve(C, onFinally()).then(function() {
                      return x
                    })
                  }
                : onFinally,
              isFunction
                ? function(e) {
                    return promiseResolve(C, onFinally()).then(function() {
                      throw e
                    })
                  }
                : onFinally
            )
          },
        }
      ) // patch native Promise.prototype for native async functions

      if (
        !IS_PURE &&
        typeof NativePromise === 'function' &&
        !NativePromise.prototype.finally
      ) {
        redefine(
          NativePromise.prototype,
          'finally',
          getBuiltIn('Promise').prototype.finally
        )
      }
      // CONCATENATED MODULE: ./node_modules/core-js/modules/es.promise.js

      const es_promise_$ = __webpack_require__(6)

      const es_promise_IS_PURE = __webpack_require__(45)

      const global = __webpack_require__(8)

      const path = __webpack_require__(82)

      const es_promise_NativePromise = __webpack_require__(142)

      const es_promise_redefine = __webpack_require__(25)

      const redefineAll = __webpack_require__(68)

      const setToStringTag = __webpack_require__(40)

      const setSpecies = __webpack_require__(99)

      const isObject = __webpack_require__(12)

      const aFunction = __webpack_require__(55)

      const anInstance = __webpack_require__(71)

      const classof = __webpack_require__(33)

      const iterate = __webpack_require__(70)

      const checkCorrectnessOfIteration = __webpack_require__(93)

      const es_promise_speciesConstructor = __webpack_require__(100)

      const task = __webpack_require__(145).set

      const microtask = __webpack_require__(182)

      const es_promise_promiseResolve = __webpack_require__(143)

      const hostReportErrors = __webpack_require__(183)

      const newPromiseCapabilityModule = __webpack_require__(144)

      const perform = __webpack_require__(184)

      const userAgent = __webpack_require__(105)

      const InternalStateModule = __webpack_require__(38)

      const isForced = __webpack_require__(61)

      const wellKnownSymbol = __webpack_require__(7)

      const SPECIES = wellKnownSymbol('species')
      const PROMISE = 'Promise'
      const getInternalState = InternalStateModule.get
      const setInternalState = InternalStateModule.set
      const getInternalPromiseState = InternalStateModule.getterFor(PROMISE)
      let PromiseConstructor = es_promise_NativePromise
      const {TypeError} = global
      const es_promise_document = global.document
      const {process} = global
      const $fetch = global.fetch
      const versions = process && process.versions
      const v8 = (versions && versions.v8) || ''
      let newPromiseCapability = newPromiseCapabilityModule.f
      const newGenericPromiseCapability = newPromiseCapability
      const IS_NODE = classof(process) == 'process'
      const DISPATCH_EVENT = !!(
        es_promise_document &&
        es_promise_document.createEvent &&
        global.dispatchEvent
      )
      const UNHANDLED_REJECTION = 'unhandledrejection'
      const REJECTION_HANDLED = 'rejectionhandled'
      const PENDING = 0
      const FULFILLED = 1
      const REJECTED = 2
      const HANDLED = 1
      const UNHANDLED = 2
      let Internal
      let OwnPromiseCapability
      let PromiseWrapper
      let nativeThen
      const FORCED = isForced(PROMISE, function() {
        // correct subclassing with @@species support
        const promise = PromiseConstructor.resolve(1)

        const empty = function empty() {
          /* empty */
        }

        const FakePromise = ((promise.constructor = {})[SPECIES] = function(
          exec
        ) {
          exec(empty, empty)
        }) // unhandled rejections tracking support, NodeJS Promise without it fails @@species test

        return !(
          (IS_NODE || typeof PromiseRejectionEvent === 'function') &&
          (!es_promise_IS_PURE || promise.finally) &&
          promise.then(empty) instanceof FakePromise && // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
          // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
          // we can't detect it synchronously, so just check versions
          v8.indexOf('6.6') !== 0 &&
          !userAgent.includes('Chrome/66')
        )
      })
      const INCORRECT_ITERATION =
        FORCED ||
        !checkCorrectnessOfIteration(function(iterable) {
          PromiseConstructor.all(iterable).catch(function() {
            /* empty */
          })
        }) // helpers

      const isThenable = function isThenable(it) {
        let then
        return isObject(it) && typeof (then = it.then) === 'function'
          ? then
          : false
      }

      const notify = function notify(promise, state, isReject) {
        if (state.notified) {
          return
        }
        state.notified = true
        const chain = state.reactions
        microtask(function() {
          const {value} = state
          const ok = state.state == FULFILLED
          let index = 0 // variable length - can't use forEach

          while (chain.length > index) {
            const reaction = chain[index++]
            const handler = ok ? reaction.ok : reaction.fail
            const {resolve} = reaction
            const {reject} = reaction
            const {domain} = reaction
            var result
            var then
            var exited

            try {
              if (handler) {
                if (!ok) {
                  if (state.rejection === UNHANDLED) {
                    onHandleUnhandled(promise, state)
                  }
                  state.rejection = HANDLED
                }

                if (handler === true) {
                  result = value
                } else {
                  if (domain) {
                    domain.enter()
                  }
                  result = handler(value) // can throw

                  if (domain) {
                    domain.exit()
                    exited = true
                  }
                }

                if (result === reaction.promise) {
                  reject(TypeError('Promise-chain cycle'))
                } else if ((then = isThenable(result))) {
                  then.call(result, resolve, reject)
                } else {
                  resolve(result)
                }
              } else {
                reject(value)
              }
            } catch (error) {
              if (domain && !exited) {
                domain.exit()
              }
              reject(error)
            }
          }

          state.reactions = []
          state.notified = false
          if (isReject && !state.rejection) {
            onUnhandled(promise, state)
          }
        })
      }

      const dispatchEvent = function dispatchEvent(name, promise, reason) {
        let event
        let handler

        if (DISPATCH_EVENT) {
          event = es_promise_document.createEvent('Event')
          event.promise = promise
          event.reason = reason
          event.initEvent(name, false, true)
          global.dispatchEvent(event)
        } else {
          event = {
            promise,
            reason,
          }
        }

        if ((handler = global[`on${name}`])) {
          handler(event)
        } else if (name === UNHANDLED_REJECTION) {
          hostReportErrors('Unhandled promise rejection', reason)
        }
      }

      var onUnhandled = function onUnhandled(promise, state) {
        task.call(global, function() {
          const {value} = state
          const IS_UNHANDLED = isUnhandled(state)
          let result

          if (IS_UNHANDLED) {
            result = perform(function() {
              if (IS_NODE) {
                process.emit('unhandledRejection', value, promise)
              } else {
                dispatchEvent(UNHANDLED_REJECTION, promise, value)
              }
            }) // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

            state.rejection =
              IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED
            if (result.error) {
              throw result.value
            }
          }
        })
      }

      var isUnhandled = function isUnhandled(state) {
        return state.rejection !== HANDLED && !state.parent
      }

      var onHandleUnhandled = function onHandleUnhandled(promise, state) {
        task.call(global, function() {
          if (IS_NODE) {
            process.emit('rejectionHandled', promise)
          } else {
            dispatchEvent(REJECTION_HANDLED, promise, state.value)
          }
        })
      }

      const bind = function bind(fn, promise, state, unwrap) {
        return function(value) {
          fn(promise, state, value, unwrap)
        }
      }

      const internalReject = function internalReject(
        promise,
        state,
        value,
        unwrap
      ) {
        if (state.done) {
          return
        }
        state.done = true
        if (unwrap) {
          state = unwrap
        }
        state.value = value
        state.state = REJECTED
        notify(promise, state, true)
      }

      const internalResolve = function internalResolve(
        promise,
        state,
        value,
        unwrap
      ) {
        if (state.done) {
          return
        }
        state.done = true
        if (unwrap) {
          state = unwrap
        }

        try {
          if (promise === value) {
            throw new TypeError("Promise can't be resolved itself")
          }
          const then = isThenable(value)

          if (then) {
            microtask(function() {
              const wrapper = {
                done: false,
              }

              try {
                then.call(
                  value,
                  bind(internalResolve, promise, wrapper, state),
                  bind(internalReject, promise, wrapper, state)
                )
              } catch (error) {
                internalReject(promise, wrapper, error, state)
              }
            })
          } else {
            state.value = value
            state.state = FULFILLED
            notify(promise, state, false)
          }
        } catch (error) {
          internalReject(
            promise,
            {
              done: false,
            },
            error,
            state
          )
        }
      } // constructor polyfill

      if (FORCED) {
        // 25.4.3.1 Promise(executor)
        PromiseConstructor = function Promise(executor) {
          anInstance(this, PromiseConstructor, PROMISE)
          aFunction(executor)
          Internal.call(this)
          const state = getInternalState(this)

          try {
            executor(
              bind(internalResolve, this, state),
              bind(internalReject, this, state)
            )
          } catch (error) {
            internalReject(this, state, error)
          }
        } // eslint-disable-next-line no-unused-vars

        Internal = function Promise(executor) {
          setInternalState(this, {
            type: PROMISE,
            done: false,
            notified: false,
            parent: false,
            reactions: [],
            rejection: false,
            state: PENDING,
            value: undefined,
          })
        }

        Internal.prototype = redefineAll(PromiseConstructor.prototype, {
          // `Promise.prototype.then` method
          // https://tc39.github.io/ecma262/#sec-promise.prototype.then
          then: function then(onFulfilled, onRejected) {
            const state = getInternalPromiseState(this)
            const reaction = newPromiseCapability(
              es_promise_speciesConstructor(this, PromiseConstructor)
            )
            reaction.ok = typeof onFulfilled === 'function' ? onFulfilled : true
            reaction.fail = typeof onRejected === 'function' && onRejected
            reaction.domain = IS_NODE ? process.domain : undefined
            state.parent = true
            state.reactions.push(reaction)
            if (state.state != PENDING) {
              notify(this, state, false)
            }
            return reaction.promise
          },
          // `Promise.prototype.catch` method
          // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
          catch: function _catch(onRejected) {
            return this.then(undefined, onRejected)
          },
        })

        OwnPromiseCapability = function OwnPromiseCapability() {
          const promise = new Internal()
          const state = getInternalState(promise)
          this.promise = promise
          this.resolve = bind(internalResolve, promise, state)
          this.reject = bind(internalReject, promise, state)
        }

        newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(
          C
        ) {
          return C === PromiseConstructor || C === PromiseWrapper
            ? new OwnPromiseCapability(C)
            : newGenericPromiseCapability(C)
        }

        if (
          !es_promise_IS_PURE &&
          typeof es_promise_NativePromise === 'function'
        ) {
          nativeThen = es_promise_NativePromise.prototype.then // wrap native Promise#then for native async functions

          es_promise_redefine(
            es_promise_NativePromise.prototype,
            'then',
            function then(onFulfilled, onRejected) {
              const that = this
              return new PromiseConstructor(function(resolve, reject) {
                nativeThen.call(that, resolve, reject)
              }).then(onFulfilled, onRejected)
            }
          ) // wrap fetch result

          if (typeof $fetch === 'function') {
            es_promise_$(
              {
                global: true,
                enumerable: true,
                forced: true,
              },
              {
                // eslint-disable-next-line no-unused-vars
                fetch: function fetch(input) {
                  return es_promise_promiseResolve(
                    PromiseConstructor,
                    $fetch.apply(global, arguments)
                  )
                },
              }
            )
          }
        }
      }

      es_promise_$(
        {
          global: true,
          wrap: true,
          forced: FORCED,
        },
        {
          Promise: PromiseConstructor,
        }
      )
      setToStringTag(PromiseConstructor, PROMISE, false, true)
      setSpecies(PROMISE)
      PromiseWrapper = path[PROMISE] // statics

      es_promise_$(
        {
          target: PROMISE,
          stat: true,
          forced: FORCED,
        },
        {
          // `Promise.reject` method
          // https://tc39.github.io/ecma262/#sec-promise.reject
          reject: function reject(r) {
            const capability = newPromiseCapability(this)
            capability.reject.call(undefined, r)
            return capability.promise
          },
        }
      )
      es_promise_$(
        {
          target: PROMISE,
          stat: true,
          forced: es_promise_IS_PURE || FORCED,
        },
        {
          // `Promise.resolve` method
          // https://tc39.github.io/ecma262/#sec-promise.resolve
          resolve: function resolve(x) {
            return es_promise_promiseResolve(
              es_promise_IS_PURE && this === PromiseWrapper
                ? PromiseConstructor
                : this,
              x
            )
          },
        }
      )
      es_promise_$(
        {
          target: PROMISE,
          stat: true,
          forced: INCORRECT_ITERATION,
        },
        {
          // `Promise.all` method
          // https://tc39.github.io/ecma262/#sec-promise.all
          all: function all(iterable) {
            const C = this
            const capability = newPromiseCapability(C)
            const {resolve} = capability
            const {reject} = capability
            const result = perform(function() {
              const $promiseResolve = aFunction(C.resolve)
              const values = []
              let counter = 0
              let remaining = 1
              iterate(iterable, function(promise) {
                const index = counter++
                let alreadyCalled = false
                values.push(undefined)
                remaining++
                $promiseResolve.call(C, promise).then(function(value) {
                  if (alreadyCalled) {
                    return
                  }
                  alreadyCalled = true
                  values[index] = value
                  --remaining || resolve(values)
                }, reject)
              })
              --remaining || resolve(values)
            })
            if (result.error) {
              reject(result.value)
            }
            return capability.promise
          },
          // `Promise.race` method
          // https://tc39.github.io/ecma262/#sec-promise.race
          race: function race(iterable) {
            const C = this
            const capability = newPromiseCapability(C)
            const {reject} = capability
            const result = perform(function() {
              const $promiseResolve = aFunction(C.resolve)
              iterate(iterable, function(promise) {
                $promiseResolve
                  .call(C, promise)
                  .then(capability.resolve, reject)
              })
            })
            if (result.error) {
              reject(result.value)
            }
            return capability.promise
          },
        }
      )

      /** */
    },
    /* 45 */
    /** */ function(module, exports) {
      module.exports = false

      /** */
    },
    /* 46 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_string_trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        46
      )

      const $ = __webpack_require__(6)

      const $trim = __webpack_require__(163).trim

      const forcedStringTrimMethod = __webpack_require__(164) // `String.prototype.trim` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.trim

      $(
        {
          target: 'String',
          proto: true,
          forced: forcedStringTrimMethod('trim'),
        },
        {
          trim: function trim() {
            return $trim(this)
          },
        }
      )

      /** */
    },
    /* 47 */
    /** */ function(module, exports) {
      module.exports = require('typescript')

      /** */
    },
    /* 48 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_array_last_index_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        48
      )

      const $ = __webpack_require__(6)

      const lastIndexOf = __webpack_require__(175) // `Array.prototype.lastIndexOf` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof

      $(
        {
          target: 'Array',
          proto: true,
          forced: lastIndexOf !== [].lastIndexOf,
        },
        {
          lastIndexOf,
        }
      )

      /** */
    },
    /* 49 */
    /** */ function(module, exports, __webpack_require__) {
      const DESCRIPTORS = __webpack_require__(18)

      const propertyIsEnumerableModule = __webpack_require__(77)

      const createPropertyDescriptor = __webpack_require__(50)

      const toIndexedObject = __webpack_require__(29)

      const toPrimitive = __webpack_require__(62)

      const has = __webpack_require__(20)

      const IE8_DOM_DEFINE = __webpack_require__(110)

      const nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor // `Object.getOwnPropertyDescriptor` method
      // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

      exports.f = DESCRIPTORS
        ? nativeGetOwnPropertyDescriptor
        : function getOwnPropertyDescriptor(O, P) {
            O = toIndexedObject(O)
            P = toPrimitive(P, true)
            if (IE8_DOM_DEFINE) {
              try {
                return nativeGetOwnPropertyDescriptor(O, P)
              } catch (error) {
                /* empty */
              }
            }
            if (has(O, P)) {
              return createPropertyDescriptor(
                !propertyIsEnumerableModule.f.call(O, P),
                O[P]
              )
            }
          }

      /** */
    },
    /* 50 */
    /** */ function(module, exports) {
      module.exports = function(bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value,
        }
      }

      /** */
    },
    /* 51 */
    /** */ function(module, exports, __webpack_require__) {
      const global = __webpack_require__(8)

      const setGlobal = __webpack_require__(81)

      const IS_PURE = __webpack_require__(45)

      const SHARED = '__core-js_shared__'
      const store = global[SHARED] || setGlobal(SHARED, {})
      ;(module.exports = function(key, value) {
        return store[key] || (store[key] = value !== undefined ? value : {})
      })('versions', []).push({
        version: '3.2.1',
        mode: IS_PURE ? 'pure' : 'global',
        copyright: ' 2019 Denis Pushkarev (zloirock.ru)',
      })

      /** */
    },
    /* 52 */
    /** */ function(module, exports, __webpack_require__) {
      const path = __webpack_require__(82)

      const global = __webpack_require__(8)

      const aFunction = function aFunction(variable) {
        return typeof variable === 'function' ? variable : undefined
      }

      module.exports = function(namespace, method) {
        return arguments.length < 2
          ? aFunction(path[namespace]) || aFunction(global[namespace])
          : (path[namespace] && path[namespace][method]) ||
              (global[namespace] && global[namespace][method])
      }

      /** */
    },
    /* 53 */
    /** */ function(module, exports) {
      module.exports = {}

      /** */
    },
    /* 54 */
    /** */ function(module, exports, __webpack_require__) {
      const aFunction = __webpack_require__(55) // optional / simple context binding

      module.exports = function(fn, that, length) {
        aFunction(fn)
        if (that === undefined) {
          return fn
        }

        switch (length) {
          case 0:
            return function() {
              return fn.call(that)
            }

          case 1:
            return function(a) {
              return fn.call(that, a)
            }

          case 2:
            return function(a, b) {
              return fn.call(that, a, b)
            }

          case 3:
            return function(a, b, c) {
              return fn.call(that, a, b, c)
            }
        }

        return function() /* ...args */
        {
          return fn.apply(that, arguments)
        }
      }

      /** */
    },
    /* 55 */
    /** */ function(module, exports) {
      module.exports = function(it) {
        if (typeof it !== 'function') {
          throw new TypeError(`${String(it)} is not a function`)
        }

        return it
      }

      /** */
    },
    /* 56 */
    /** */ function(module, exports) {
      module.exports = {}

      /** */
    },
    /* 57 */
    /** */ function(module, exports, __webpack_require__) {
      const toPrimitive = __webpack_require__(62)

      const definePropertyModule = __webpack_require__(19)

      const createPropertyDescriptor = __webpack_require__(50)

      module.exports = function(object, key, value) {
        const propertyKey = toPrimitive(key)
        if (propertyKey in object) {
          definePropertyModule.f(
            object,
            propertyKey,
            createPropertyDescriptor(0, value)
          )
        } else {
          object[propertyKey] = value
        }
      }

      /** */
    },
    /* 58 */
    /** */ function(module, exports, __webpack_require__) {
      const fails = __webpack_require__(9)

      const wellKnownSymbol = __webpack_require__(7)

      const SPECIES = wellKnownSymbol('species')

      module.exports = function(METHOD_NAME) {
        return !fails(function() {
          const array = []
          const constructor = (array.constructor = {})

          constructor[SPECIES] = function() {
            return {
              foo: 1,
            }
          }

          return array[METHOD_NAME](Boolean).foo !== 1
        })
      }

      /** */
    },
    /* 59 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        16
      )
      /* harmony import */ const core_js_modules_es_regexp_flags__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        59
      )
      /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        3
      )

      const DESCRIPTORS = __webpack_require__(18)

      const objectDefinePropertyModule = __webpack_require__(19)

      const regExpFlags = __webpack_require__(72) // `RegExp.prototype.flags` getter
      // https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags

      if (DESCRIPTORS && /./g.flags != 'g') {
        objectDefinePropertyModule.f(RegExp.prototype, 'flags', {
          configurable: true,
          get: regExpFlags,
        })
      }

      /** */
    },
    /* 60 */
    /** */ function(module, exports, __webpack_require__) {
      const classof = __webpack_require__(33) // `IsArray` abstract operation
      // https://tc39.github.io/ecma262/#sec-isarray

      module.exports =
        Array.isArray ||
        function isArray(argument) {
          return classof(argument) == 'Array'
        }

      /** */
    },
    /* 61 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          14
        )

        const fails = __webpack_require__(9)

        const replacement = /#|\.prototype\./

        const isForced = function isForced(feature, detection) {
          const value = data[normalize(feature)]
          return value == POLYFILL
            ? true
            : value == NATIVE
            ? false
            : typeof detection === 'function'
            ? fails(detection)
            : !!detection
        }

        var normalize = (isForced.normalize = function(string) {
          return String(string)
            .replace(replacement, '.')
            .toLowerCase()
        })

        var data = (isForced.data = {})
        var NATIVE = (isForced.NATIVE = 'N')
        var POLYFILL = (isForced.POLYFILL = 'P')
        module.exports = isForced
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 62 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          3
        )

        const isObject = __webpack_require__(12) // `ToPrimitive` abstract operation
        // https://tc39.github.io/ecma262/#sec-toprimitive
        // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string

        module.exports = function(input, PREFERRED_STRING) {
          if (!isObject(input)) {
            return input
          }
          let fn
          let value
          if (
            PREFERRED_STRING &&
            typeof (fn = input.toString) === 'function' &&
            !isObject((value = fn.call(input)))
          ) {
            return value
          }
          if (
            typeof (fn = input.valueOf) === 'function' &&
            !isObject((value = fn.call(input)))
          ) {
            return value
          }
          if (
            !PREFERRED_STRING &&
            typeof (fn = input.toString) === 'function' &&
            !isObject((value = fn.call(input)))
          ) {
            return value
          }
          throw new TypeError("Can't convert object to primitive value")
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 63 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        11
      )

      const internalObjectKeys = __webpack_require__(115)

      const enumBugKeys = __webpack_require__(86)

      const hiddenKeys = enumBugKeys.concat('length', 'prototype') // `Object.getOwnPropertyNames` method
      // https://tc39.github.io/ecma262/#sec-object.getownpropertynames

      exports.f =
        Object.getOwnPropertyNames ||
        function getOwnPropertyNames(O) {
          return internalObjectKeys(O, hiddenKeys)
        }

      /** */
    },
    /* 64 */
    /** */ function(module, exports, __webpack_require__) {
      const anObject = __webpack_require__(17)

      const defineProperties = __webpack_require__(151)

      const enumBugKeys = __webpack_require__(86)

      const hiddenKeys = __webpack_require__(53)

      const html = __webpack_require__(117)

      const documentCreateElement = __webpack_require__(80)

      const sharedKey = __webpack_require__(65)

      const IE_PROTO = sharedKey('IE_PROTO')
      const PROTOTYPE = 'prototype'

      const Empty = function Empty() {
        /* empty */
      } // Create object with fake `null` prototype: use iframe Object with cleared prototype

      var _createDict = function createDict() {
        // Thrash, waste and sodomy: IE GC bug
        const iframe = documentCreateElement('iframe')
        let {length} = enumBugKeys
        const lt = '<'
        const script = 'script'
        const gt = '>'
        const js = `java${script}:`
        let iframeDocument
        iframe.style.display = 'none'
        html.appendChild(iframe)
        iframe.src = String(js)
        iframeDocument = iframe.contentWindow.document
        iframeDocument.open()
        iframeDocument.write(
          `${lt + script + gt}document.F=Object${lt}/${script}${gt}`
        )
        iframeDocument.close()
        _createDict = iframeDocument.F

        while (length--) {
          delete _createDict[PROTOTYPE][enumBugKeys[length]]
        }

        return _createDict()
      } // `Object.create` method
      // https://tc39.github.io/ecma262/#sec-object.create

      module.exports =
        Object.create ||
        function create(O, Properties) {
          let result

          if (O !== null) {
            Empty[PROTOTYPE] = anObject(O)
            result = new Empty()
            Empty[PROTOTYPE] = null // add "__proto__" for Object.getPrototypeOf polyfill

            result[IE_PROTO] = O
          } else {
            result = _createDict()
          }

          return Properties === undefined
            ? result
            : defineProperties(result, Properties)
        }

      hiddenKeys[IE_PROTO] = true

      /** */
    },
    /* 65 */
    /** */ function(module, exports, __webpack_require__) {
      const shared = __webpack_require__(51)

      const uid = __webpack_require__(66)

      const keys = shared('keys')

      module.exports = function(key) {
        return keys[key] || (keys[key] = uid(key))
      }

      /** */
    },
    /* 66 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          3
        )

        let id = 0
        const postfix = Math.random()

        module.exports = function(key) {
          return `Symbol(${String(key === undefined ? '' : key)})_${(
            ++id + postfix
          ).toString(36)}`
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 67 */
    /** */ function(module, exports, __webpack_require__) {
      const bind = __webpack_require__(54)

      const IndexedObject = __webpack_require__(78)

      const toObject = __webpack_require__(31)

      const toLength = __webpack_require__(22)

      const arraySpeciesCreate = __webpack_require__(90)

      const {push} = [] // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation

      const createMethod = function createMethod(TYPE) {
        const IS_MAP = TYPE == 1
        const IS_FILTER = TYPE == 2
        const IS_SOME = TYPE == 3
        const IS_EVERY = TYPE == 4
        const IS_FIND_INDEX = TYPE == 6
        const NO_HOLES = TYPE == 5 || IS_FIND_INDEX
        return function($this, callbackfn, that, specificCreate) {
          const O = toObject($this)
          const self = IndexedObject(O)
          const boundFunction = bind(callbackfn, that, 3)
          const length = toLength(self.length)
          let index = 0
          const create = specificCreate || arraySpeciesCreate
          const target = IS_MAP
            ? create($this, length)
            : IS_FILTER
            ? create($this, 0)
            : undefined
          let value
          let result

          for (; length > index; index++) {
            if (NO_HOLES || index in self) {
              value = self[index]
              result = boundFunction(value, index, O)

              if (TYPE) {
                if (IS_MAP) {
                  target[index] = result
                }
                // map
                else if (result) {
                  switch (TYPE) {
                    case 3:
                      return true
                    // some

                    case 5:
                      return value
                    // find

                    case 6:
                      return index
                    // findIndex

                    case 2:
                      push.call(target, value)
                    // filter
                  }
                } else if (IS_EVERY) {
                  return false
                } // every
              }
            }
          }

          return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target
        }
      }

      module.exports = {
        // `Array.prototype.forEach` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
        forEach: createMethod(0),
        // `Array.prototype.map` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.map
        map: createMethod(1),
        // `Array.prototype.filter` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.filter
        filter: createMethod(2),
        // `Array.prototype.some` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.some
        some: createMethod(3),
        // `Array.prototype.every` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.every
        every: createMethod(4),
        // `Array.prototype.find` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.find
        find: createMethod(5),
        // `Array.prototype.findIndex` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
        findIndex: createMethod(6),
      }

      /** */
    },
    /* 68 */
    /** */ function(module, exports, __webpack_require__) {
      const redefine = __webpack_require__(25)

      module.exports = function(target, source, options) {
        for (const key in source) {
          redefine(target, key, source[key], options)
        }

        return target
      }

      /** */
    },
    /* 69 */
    /** */ function(module, exports, __webpack_require__) {
      const hiddenKeys = __webpack_require__(53)

      const isObject = __webpack_require__(12)

      const has = __webpack_require__(20)

      const defineProperty = __webpack_require__(19).f

      const uid = __webpack_require__(66)

      const FREEZING = __webpack_require__(156)

      const METADATA = uid('meta')
      let id = 0

      const isExtensible =
        Object.isExtensible ||
        function() {
          return true
        }

      const setMetadata = function setMetadata(it) {
        defineProperty(it, METADATA, {
          value: {
            objectID: `O${++id}`,
            // object ID
            weakData: {}, // weak collections IDs
          },
        })
      }

      const fastKey = function fastKey(it, create) {
        // return a primitive with prefix
        if (!isObject(it)) {
          return typeof it === 'symbol'
            ? it
            : (typeof it === 'string' ? 'S' : 'P') + it
        }

        if (!has(it, METADATA)) {
          // can't set metadata to uncaught frozen object
          if (!isExtensible(it)) {
            return 'F'
          } // not necessary to add metadata

          if (!create) {
            return 'E'
          } // add missing metadata

          setMetadata(it) // return object ID
        }

        return it[METADATA].objectID
      }

      const getWeakData = function getWeakData(it, create) {
        if (!has(it, METADATA)) {
          // can't set metadata to uncaught frozen object
          if (!isExtensible(it)) {
            return true
          } // not necessary to add metadata

          if (!create) {
            return false
          } // add missing metadata

          setMetadata(it) // return the store of weak collections IDs
        }

        return it[METADATA].weakData
      } // add metadata on freeze-family methods calling

      const onFreeze = function onFreeze(it) {
        if (
          FREEZING &&
          meta.REQUIRED &&
          isExtensible(it) &&
          !has(it, METADATA)
        ) {
          setMetadata(it)
        }
        return it
      }

      var meta = (module.exports = {
        REQUIRED: false,
        fastKey,
        getWeakData,
        onFreeze,
      })
      hiddenKeys[METADATA] = true

      /** */
    },
    /* 70 */
    /** */ function(module, exports, __webpack_require__) {
      const anObject = __webpack_require__(17)

      const isArrayIteratorMethod = __webpack_require__(123)

      const toLength = __webpack_require__(22)

      const bind = __webpack_require__(54)

      const getIteratorMethod = __webpack_require__(124)

      const callWithSafeIterationClosing = __webpack_require__(126)

      const Result = function Result(stopped, result) {
        this.stopped = stopped
        this.result = result
      }

      const iterate = (module.exports = function(
        iterable,
        fn,
        that,
        AS_ENTRIES,
        IS_ITERATOR
      ) {
        const boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1)
        let iterator
        let iterFn
        let index
        let length
        let result
        let step

        if (IS_ITERATOR) {
          iterator = iterable
        } else {
          iterFn = getIteratorMethod(iterable)
          if (typeof iterFn !== 'function') {
            throw new TypeError('Target is not iterable')
          } // optimisation for array iterators

          if (isArrayIteratorMethod(iterFn)) {
            for (
              index = 0, length = toLength(iterable.length);
              length > index;
              index++
            ) {
              result = AS_ENTRIES
                ? boundFunction(anObject((step = iterable[index]))[0], step[1])
                : boundFunction(iterable[index])
              if (result && result instanceof Result) {
                return result
              }
            }

            return new Result(false)
          }

          iterator = iterFn.call(iterable)
        }

        while (!(step = iterator.next()).done) {
          result = callWithSafeIterationClosing(
            iterator,
            boundFunction,
            step.value,
            AS_ENTRIES
          )
          if (result && result instanceof Result) {
            return result
          }
        }

        return new Result(false)
      })

      iterate.stop = function(result) {
        return new Result(true, result)
      }

      /** */
    },
    /* 71 */
    /** */ function(module, exports) {
      module.exports = function(it, Constructor, name) {
        if (!(it instanceof Constructor)) {
          throw new TypeError(`Incorrect ${name ? `${name} ` : ''}invocation`)
        }

        return it
      }

      /** */
    },
    /* 72 */
    /** */ function(module, exports, __webpack_require__) {
      const anObject = __webpack_require__(17) // `RegExp.prototype.flags` getter implementation
      // https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags

      module.exports = function() {
        const that = anObject(this)
        let result = ''
        if (that.global) {
          result += 'g'
        }
        if (that.ignoreCase) {
          result += 'i'
        }
        if (that.multiline) {
          result += 'm'
        }
        if (that.dotAll) {
          result += 's'
        }
        if (that.unicode) {
          result += 'u'
        }
        if (that.sticky) {
          result += 'y'
        }
        return result
      }

      /** */
    },
    /* 73 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ const core_js_modules_es_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        34
      )
      /* harmony import */ const core_js_modules_es_array_last_index_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        48
      )
      /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        2
      )
      /* harmony import */ const core_js_modules_es_regexp_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        59
      )
      /* harmony import */ const core_js_modules_es_string_includes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
        41
      )

      const __importDefault =
        (undefined && undefined.__importDefault) ||
        function(module_) {
          return module_ && module_.__esModule
            ? module_
            : {
                default: module_,
              }
        }

      const __importStar =
        (undefined && undefined.__importStar) ||
        function(module_) {
          if (module_ && module_.__esModule) {
            return module_
          }
          const result = {}
          if (module_ != null) {
            for (const k in module_) {
              if (Object.hasOwnProperty.call(module_, k)) {
                result[k] = module_[k]
              }
            }
          }
          result.default = module_
          return result
        }

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })

      const lodash_unescape_1 = __importDefault(__webpack_require__(176))

      const ts = __importStar(__webpack_require__(47)) // leave this as * as ts so people using util package don't need syntheticDefaultImports

      const ts_estree_1 = __webpack_require__(104)

      const {SyntaxKind} = ts
      const ASSIGNMENT_OPERATORS = [
        SyntaxKind.EqualsToken,
        SyntaxKind.PlusEqualsToken,
        SyntaxKind.MinusEqualsToken,
        SyntaxKind.AsteriskEqualsToken,
        SyntaxKind.AsteriskAsteriskEqualsToken,
        SyntaxKind.SlashEqualsToken,
        SyntaxKind.PercentEqualsToken,
        SyntaxKind.LessThanLessThanEqualsToken,
        SyntaxKind.GreaterThanGreaterThanEqualsToken,
        SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,
        SyntaxKind.AmpersandEqualsToken,
        SyntaxKind.BarEqualsToken,
        SyntaxKind.CaretEqualsToken,
      ]
      const LOGICAL_OPERATORS = [
        SyntaxKind.BarBarToken,
        SyntaxKind.AmpersandAmpersandToken,
        SyntaxKind.QuestionQuestionToken,
      ]
      const TOKEN_TO_TEXT = {
        [SyntaxKind.OpenBraceToken]: '{',
        [SyntaxKind.CloseBraceToken]: '}',
        [SyntaxKind.OpenParenToken]: '(',
        [SyntaxKind.CloseParenToken]: ')',
        [SyntaxKind.OpenBracketToken]: '[',
        [SyntaxKind.CloseBracketToken]: ']',
        [SyntaxKind.DotToken]: '.',
        [SyntaxKind.DotDotDotToken]: '...',
        [SyntaxKind.SemicolonToken]: ',',
        [SyntaxKind.CommaToken]: ',',
        [SyntaxKind.LessThanToken]: '<',
        [SyntaxKind.GreaterThanToken]: '>',
        [SyntaxKind.LessThanEqualsToken]: '<=',
        [SyntaxKind.GreaterThanEqualsToken]: '>=',
        [SyntaxKind.EqualsEqualsToken]: '==',
        [SyntaxKind.ExclamationEqualsToken]: '!=',
        [SyntaxKind.EqualsEqualsEqualsToken]: '===',
        [SyntaxKind.InstanceOfKeyword]: 'instanceof',
        [SyntaxKind.ExclamationEqualsEqualsToken]: '!==',
        [SyntaxKind.EqualsGreaterThanToken]: '=>',
        [SyntaxKind.PlusToken]: '+',
        [SyntaxKind.MinusToken]: '-',
        [SyntaxKind.AsteriskToken]: '*',
        [SyntaxKind.AsteriskAsteriskToken]: '**',
        [SyntaxKind.SlashToken]: '/',
        [SyntaxKind.PercentToken]: '%',
        [SyntaxKind.PlusPlusToken]: '++',
        [SyntaxKind.MinusMinusToken]: '--',
        [SyntaxKind.LessThanLessThanToken]: '<<',
        [SyntaxKind.LessThanSlashToken]: '</',
        [SyntaxKind.GreaterThanGreaterThanToken]: '>>',
        [SyntaxKind.GreaterThanGreaterThanGreaterThanToken]: '>>>',
        [SyntaxKind.AmpersandToken]: '&',
        [SyntaxKind.BarToken]: '|',
        [SyntaxKind.CaretToken]: '^',
        [SyntaxKind.ExclamationToken]: '!',
        [SyntaxKind.TildeToken]: '~',
        [SyntaxKind.AmpersandAmpersandToken]: '&&',
        [SyntaxKind.BarBarToken]: '||',
        [SyntaxKind.QuestionToken]: '?',
        [SyntaxKind.ColonToken]: ':',
        [SyntaxKind.EqualsToken]: '=',
        [SyntaxKind.PlusEqualsToken]: '+=',
        [SyntaxKind.MinusEqualsToken]: '-=',
        [SyntaxKind.AsteriskEqualsToken]: '*=',
        [SyntaxKind.AsteriskAsteriskEqualsToken]: '**=',
        [SyntaxKind.SlashEqualsToken]: '/=',
        [SyntaxKind.PercentEqualsToken]: '%=',
        [SyntaxKind.LessThanLessThanEqualsToken]: '<<=',
        [SyntaxKind.GreaterThanGreaterThanEqualsToken]: '>>=',
        [SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken]: '>>>=',
        [SyntaxKind.AmpersandEqualsToken]: '&=',
        [SyntaxKind.BarEqualsToken]: '|=',
        [SyntaxKind.CaretEqualsToken]: '^=',
        [SyntaxKind.AtToken]: '@',
        [SyntaxKind.InKeyword]: 'in',
        [SyntaxKind.UniqueKeyword]: 'unique',
        [SyntaxKind.KeyOfKeyword]: 'keyof',
        [SyntaxKind.NewKeyword]: 'new',
        [SyntaxKind.ImportKeyword]: 'import',
        [SyntaxKind.ReadonlyKeyword]: 'readonly',
        [SyntaxKind.QuestionQuestionToken]: '??',
        [SyntaxKind.QuestionDotToken]: '?.',
      }
      /**
       * Returns true if the given ts.Token is the assignment operator
       * @param operator the operator token
       * @returns is assignment
       */

      function isAssignmentOperator(operator) {
        return ASSIGNMENT_OPERATORS.includes(operator.kind)
      }

      exports.isAssignmentOperator = isAssignmentOperator
      /**
       * Returns true if the given ts.Token is a logical operator
       * @param operator the operator token
       * @returns is a logical operator
       */

      function isLogicalOperator(operator) {
        return LOGICAL_OPERATORS.includes(operator.kind)
      }

      exports.isLogicalOperator = isLogicalOperator
      /**
       * Returns the string form of the given TSToken SyntaxKind
       * @param kind the token's SyntaxKind
       * @returns the token applicable token as a string
       */

      function getTextForTokenKind(kind) {
        return TOKEN_TO_TEXT[kind]
      }

      exports.getTextForTokenKind = getTextForTokenKind
      /**
       * Returns true if the given ts.Node is a valid ESTree class member
       * @param node TypeScript AST node
       * @returns is valid ESTree class member
       */

      function isESTreeClassMember(node) {
        return node.kind !== SyntaxKind.SemicolonClassElement
      }

      exports.isESTreeClassMember = isESTreeClassMember
      /**
       * Checks if a ts.Node has a modifier
       * @param modifierKind TypeScript SyntaxKind modifier
       * @param node TypeScript AST node
       * @returns has the modifier specified
       */

      function hasModifier(modifierKind, node) {
        return (
          !!node.modifiers &&
          !!node.modifiers.length &&
          node.modifiers.some(function(modifier) {
            return modifier.kind === modifierKind
          })
        )
      }

      exports.hasModifier = hasModifier
      /**
       * Get last last modifier in ast
       * @param node TypeScript AST node
       * @returns returns last modifier if present or null
       */

      function getLastModifier(node) {
        return (
          (!!node.modifiers &&
            !!node.modifiers.length &&
            node.modifiers[node.modifiers.length - 1]) ||
          null
        )
      }

      exports.getLastModifier = getLastModifier
      /**
       * Returns true if the given ts.Token is a comma
       * @param token the TypeScript token
       * @returns is comma
       */

      function isComma(token) {
        return token.kind === SyntaxKind.CommaToken
      }

      exports.isComma = isComma
      /**
       * Returns true if the given ts.Node is a comment
       * @param node the TypeScript node
       * @returns is comment
       */

      function isComment(node) {
        return (
          node.kind === SyntaxKind.SingleLineCommentTrivia ||
          node.kind === SyntaxKind.MultiLineCommentTrivia
        )
      }

      exports.isComment = isComment
      /**
       * Returns true if the given ts.Node is a JSDoc comment
       * @param node the TypeScript node
       * @returns is JSDoc comment
       */

      function isJSDocumentComment(node) {
        return node.kind === SyntaxKind.JSDocComment
      }

      exports.isJSDocComment = isJSDocumentComment
      /**
       * Returns the binary expression type of the given ts.Token
       * @param operator the operator token
       * @returns the binary expression type
       */

      function getBinaryExpressionType(operator) {
        if (isAssignmentOperator(operator)) {
          return ts_estree_1.AST_NODE_TYPES.AssignmentExpression
        }
        if (isLogicalOperator(operator)) {
          return ts_estree_1.AST_NODE_TYPES.LogicalExpression
        }

        return ts_estree_1.AST_NODE_TYPES.BinaryExpression
      }

      exports.getBinaryExpressionType = getBinaryExpressionType
      /**
       * Returns line and column data for the given positions,
       * @param pos position to check
       * @param ast the AST object
       * @returns line and column
       */

      function getLineAndCharacterFor(pos, ast) {
        const loc = ast.getLineAndCharacterOfPosition(pos)
        return {
          line: loc.line + 1,
          column: loc.character,
        }
      }

      exports.getLineAndCharacterFor = getLineAndCharacterFor
      /**
       * Returns line and column data for the given start and end positions,
       * for the given AST
       * @param start start data
       * @param end   end data
       * @param ast   the AST object
       * @returns the loc data
       */

      function getLocFor(start, end, ast) {
        return {
          start: getLineAndCharacterFor(start, ast),
          end: getLineAndCharacterFor(end, ast),
        }
      }

      exports.getLocFor = getLocFor
      /**
       * Check whatever node can contain directive
       * @param node
       * @returns returns true if node can contain directive
       */

      function canContainDirective(node) {
        if (node.kind === ts.SyntaxKind.Block) {
          switch (node.parent.kind) {
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.ArrowFunction:
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.MethodDeclaration:
              return true

            default:
              return false
          }
        }

        return true
      }

      exports.canContainDirective = canContainDirective
      /**
       * Returns range for the given ts.Node
       * @param node the ts.Node or ts.Token
       * @param ast the AST object
       * @returns the range data
       */

      function getRange(node, ast) {
        return [node.getStart(ast), node.getEnd()]
      }

      exports.getRange = getRange
      /**
       * Returns true if a given ts.Node is a token
       * @param node the ts.Node
       * @returns is a token
       */

      function isToken(node) {
        return (
          node.kind >= SyntaxKind.FirstToken &&
          node.kind <= SyntaxKind.LastToken
        )
      }

      exports.isToken = isToken
      /**
       * Returns true if a given ts.Node is a JSX token
       * @param node ts.Node to be checked
       * @returns is a JSX token
       */

      function isJSXToken(node) {
        return (
          node.kind >= SyntaxKind.JsxElement &&
          node.kind <= SyntaxKind.JsxAttribute
        )
      }

      exports.isJSXToken = isJSXToken
      /**
       * Returns the declaration kind of the given ts.Node
       * @param node TypeScript AST node
       * @returns declaration kind
       */

      function getDeclarationKind(node) {
        if (node.flags & ts.NodeFlags.Let) {
          return 'let'
        }

        if (node.flags & ts.NodeFlags.Const) {
          return 'const'
        }

        return 'var'
      }

      exports.getDeclarationKind = getDeclarationKind
      /**
       * Gets a ts.Node's accessibility level
       * @param node The ts.Node
       * @returns accessibility "public", "protected", "private", or null
       */

      function getTSNodeAccessibility(node) {
        const {modifiers} = node

        if (!modifiers) {
          return null
        }

        for (const modifier of modifiers) {
          switch (modifier.kind) {
            case SyntaxKind.PublicKeyword:
              return 'public'

            case SyntaxKind.ProtectedKeyword:
              return 'protected'

            case SyntaxKind.PrivateKeyword:
              return 'private'

            default:
              break
          }
        }

        return null
      }

      exports.getTSNodeAccessibility = getTSNodeAccessibility
      /**
       * Finds the next token based on the previous one and its parent
       * Had to copy this from TS instead of using TS's version because theirs doesn't pass the ast to getChildren
       * @param previousToken The previous TSToken
       * @param parent The parent TSNode
       * @param ast The TS AST
       * @returns the next TSToken
       */

      function findNextToken(previousToken, parent, ast) {
        return find(parent)

        function find(n) {
          if (ts.isToken(n) && n.pos === previousToken.end) {
            // this is token that starts at the end of previous token - return it
            return n
          }

          return firstDefined(n.getChildren(ast), function(child) {
            const shouldDiveInChildNode = // previous token is enclosed somewhere in the child
              (child.pos <= previousToken.pos &&
                child.end > previousToken.end) || // previous token ends exactly at the beginning of child
              child.pos === previousToken.end
            return shouldDiveInChildNode && nodeHasTokens(child, ast)
              ? find(child)
              : undefined
          })
        }
      }

      exports.findNextToken = findNextToken
      /**
       * Find the first matching ancestor based on the given predicate function.
       * @param node The current ts.Node
       * @param predicate The predicate function to apply to each checked ancestor
       * @returns a matching parent ts.Node
       */

      function findFirstMatchingAncestor(node, predicate) {
        while (node) {
          if (predicate(node)) {
            return node
          }

          node = node.parent
        }

        return undefined
      }

      exports.findFirstMatchingAncestor = findFirstMatchingAncestor
      /**
       * Returns true if a given ts.Node has a JSX token within its hierarchy
       * @param node ts.Node to be checked
       * @returns has JSX ancestor
       */

      function hasJSXAncestor(node) {
        return !!findFirstMatchingAncestor(node, isJSXToken)
      }

      exports.hasJSXAncestor = hasJSXAncestor
      /**
       * Unescape the text content of string literals, e.g. &amp; -> &
       * @param text The escaped string literal text.
       * @returns The unescaped string literal text.
       */

      function unescapeStringLiteralText(text) {
        return lodash_unescape_1.default(text)
      }

      exports.unescapeStringLiteralText = unescapeStringLiteralText
      /**
       * Returns true if a given ts.Node is a computed property
       * @param node ts.Node to be checked
       * @returns is Computed Property
       */

      function isComputedProperty(node) {
        return node.kind === SyntaxKind.ComputedPropertyName
      }

      exports.isComputedProperty = isComputedProperty
      /**
       * Returns true if a given ts.Node is optional (has QuestionToken)
       * @param node ts.Node to be checked
       * @returns is Optional
       */

      function isOptional(node) {
        return node.questionToken
          ? node.questionToken.kind === SyntaxKind.QuestionToken
          : false
      }

      exports.isOptional = isOptional
      /**
       * Returns the type of a given ts.Token
       * @param token the ts.Token
       * @returns the token type
       */
      // ts.Node types are ugly
      // eslint-disable-next-line @typescript-eslint/no-explicit-any

      function getTokenType(token) {
        // Need two checks for keywords since some are also identifiers
        if (token.originalKeywordKind) {
          switch (token.originalKeywordKind) {
            case SyntaxKind.NullKeyword:
              return ts_estree_1.AST_TOKEN_TYPES.Null

            case SyntaxKind.GetKeyword:
            case SyntaxKind.SetKeyword:
            case SyntaxKind.TypeKeyword:
            case SyntaxKind.ModuleKeyword:
            case SyntaxKind.AsyncKeyword:
            case SyntaxKind.IsKeyword:
              return ts_estree_1.AST_TOKEN_TYPES.Identifier

            default:
              return ts_estree_1.AST_TOKEN_TYPES.Keyword
          }
        }

        if (
          token.kind >= SyntaxKind.FirstKeyword &&
          token.kind <= SyntaxKind.LastFutureReservedWord
        ) {
          if (
            token.kind === SyntaxKind.FalseKeyword ||
            token.kind === SyntaxKind.TrueKeyword
          ) {
            return ts_estree_1.AST_TOKEN_TYPES.Boolean
          }

          return ts_estree_1.AST_TOKEN_TYPES.Keyword
        }

        if (
          token.kind >= SyntaxKind.FirstPunctuation &&
          token.kind <= SyntaxKind.LastBinaryOperator
        ) {
          return ts_estree_1.AST_TOKEN_TYPES.Punctuator
        }

        if (
          token.kind >= SyntaxKind.NoSubstitutionTemplateLiteral &&
          token.kind <= SyntaxKind.TemplateTail
        ) {
          return ts_estree_1.AST_TOKEN_TYPES.Template
        }

        switch (token.kind) {
          case SyntaxKind.NumericLiteral:
            return ts_estree_1.AST_TOKEN_TYPES.Numeric

          case SyntaxKind.JsxText:
            return ts_estree_1.AST_TOKEN_TYPES.JSXText

          case SyntaxKind.StringLiteral:
            // A TypeScript-StringLiteral token with a TypeScript-JsxAttribute or TypeScript-JsxElement parent,
            // must actually be an ESTree-JSXText token
            if (
              token.parent &&
              (token.parent.kind === SyntaxKind.JsxAttribute ||
                token.parent.kind === SyntaxKind.JsxElement)
            ) {
              return ts_estree_1.AST_TOKEN_TYPES.JSXText
            }

            return ts_estree_1.AST_TOKEN_TYPES.String

          case SyntaxKind.RegularExpressionLiteral:
            return ts_estree_1.AST_TOKEN_TYPES.RegularExpression

          case SyntaxKind.Identifier:
          case SyntaxKind.ConstructorKeyword:
          case SyntaxKind.GetKeyword:
          case SyntaxKind.SetKeyword: // falls through

          default:
        } // Some JSX tokens have to be determined based on their parent

        if (token.parent && token.kind === SyntaxKind.Identifier) {
          if (isJSXToken(token.parent)) {
            return ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier
          }

          if (
            token.parent.kind === SyntaxKind.PropertyAccessExpression &&
            hasJSXAncestor(token)
          ) {
            return ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier
          }
        }

        return ts_estree_1.AST_TOKEN_TYPES.Identifier
      }

      exports.getTokenType = getTokenType
      /**
       * Extends and formats a given ts.Token, for a given AST
       * @param token the ts.Token
       * @param ast   the AST object
       * @returns the converted Token
       */

      function convertToken(token, ast) {
        const start =
          token.kind === SyntaxKind.JsxText
            ? token.getFullStart()
            : token.getStart(ast)
        const end = token.getEnd()
        const value = ast.text.slice(start, end)
        const newToken = {
          type: getTokenType(token),
          value,
          range: [start, end],
          loc: getLocFor(start, end, ast),
        }

        if (newToken.type === 'RegularExpression') {
          newToken.regex = {
            pattern: value.slice(1, value.lastIndexOf('/')),
            flags: value.slice(value.lastIndexOf('/') + 1),
          }
        }

        return newToken
      }

      exports.convertToken = convertToken
      /**
       * Converts all tokens for the given AST
       * @param ast the AST object
       * @returns the converted Tokens
       */

      function convertTokens(ast) {
        const result = []
        /**
         * @param node the ts.Node
         */

        function walk(node) {
          // TypeScript generates tokens for types in JSDoc blocks. Comment tokens
          // and their children should not be walked or added to the resulting tokens list.
          if (isComment(node) || isJSDocumentComment(node)) {
            return
          }

          if (isToken(node) && node.kind !== SyntaxKind.EndOfFileToken) {
            const converted = convertToken(node, ast)

            if (converted) {
              result.push(converted)
            }
          } else {
            node.getChildren(ast).forEach(walk)
          }
        }

        walk(ast)
        return result
      }

      exports.convertTokens = convertTokens
      /**
       * Get container token node between range
       * @param ast the AST object
       * @param start The index at which the comment starts.
       * @param end The index at which the comment ends.
       * @returns typescript container token
       * @private
       */

      function getNodeContainer(ast, start, end) {
        let container = null
        /**
         * @param node the ts.Node
         */

        function walk(node) {
          const nodeStart = node.pos
          const nodeEnd = node.end

          if (start >= nodeStart && end <= nodeEnd) {
            if (isToken(node)) {
              container = node
            } else {
              node.getChildren().forEach(walk)
            }
          }
        }

        walk(ast)
        return container
      }

      exports.getNodeContainer = getNodeContainer
      /**
       * @param ast     the AST object
       * @param start      the index at which the error starts
       * @param message the error message
       * @returns converted error object
       */

      function createError(ast, start, message) {
        const loc = ast.getLineAndCharacterOfPosition(start)
        return {
          index: start,
          lineNumber: loc.line + 1,
          column: loc.character,
          message,
        }
      }

      exports.createError = createError
      /**
       * @param n the TSNode
       * @param ast the TS AST
       */

      function nodeHasTokens(n, ast) {
        // If we have a token or node that has a non-zero width, it must have tokens.
        // Note: getWidth() does not take trivia into account.
        return n.kind === SyntaxKind.EndOfFileToken // eslint-disable-next-line @typescript-eslint/no-explicit-any
          ? !!n.jsDoc
          : n.getWidth(ast) !== 0
      }

      exports.nodeHasTokens = nodeHasTokens
      /**
       * Like `forEach`, but suitable for use with numbers and strings (which may be falsy).
       * @template T
       * @template U
       * @param array
       * @param callback
       */

      function firstDefined(array, callback) {
        if (array === undefined) {
          return undefined
        }

        for (const [i, element] of array.entries()) {
          const result = callback(element, i)

          if (result !== undefined) {
            return result
          }
        }

        return undefined
      }

      exports.firstDefined = firstDefined

      /** */
    },
    /* 74 */
    /** */ function(module, exports, __webpack_require__) {
      const collection = __webpack_require__(92)

      const collectionStrong = __webpack_require__(141) // `Map` constructor
      // https://tc39.github.io/ecma262/#sec-map-objects

      module.exports = collection(
        'Map',
        function(get) {
          return function Map() {
            return get(this, arguments.length ? arguments[0] : undefined)
          }
        },
        collectionStrong,
        true
      )

      /** */
    },
    /* 75 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          185
        )
        /* harmony import */ const core_js_modules_es_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_2___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_2__
        )
        /* harmony import */ const core_js_modules_es_symbol_to_string_tag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          186
        )
        /* harmony import */ const core_js_modules_es_symbol_to_string_tag__WEBPACK_IMPORTED_MODULE_3___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_symbol_to_string_tag__WEBPACK_IMPORTED_MODULE_3__
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4__
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_json_to_string_tag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          187
        )
        /* harmony import */ const core_js_modules_es_json_to_string_tag__WEBPACK_IMPORTED_MODULE_6___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_json_to_string_tag__WEBPACK_IMPORTED_MODULE_6__
        )
        /* harmony import */ const core_js_modules_es_math_to_string_tag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          188
        )
        /* harmony import */ const core_js_modules_es_math_to_string_tag__WEBPACK_IMPORTED_MODULE_7___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_math_to_string_tag__WEBPACK_IMPORTED_MODULE_7__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          44
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
          3
        )

        /**
         * Copyright (c) 2014-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        const runtime = (function(exports) {
          const Op = Object.prototype
          const hasOwn = Op.hasOwnProperty
          let undefined // More compressible than void 0.

          const $Symbol = typeof Symbol === 'function' ? Symbol : {}
          const iteratorSymbol = $Symbol.iterator || '@@iterator'
          const asyncIteratorSymbol = $Symbol.asyncIterator || '@@asyncIterator'
          const toStringTagSymbol = $Symbol.toStringTag || '@@toStringTag'

          function wrap(innerFn, outerFn, self, tryLocsList) {
            // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
            const protoGenerator =
              outerFn && outerFn.prototype instanceof Generator
                ? outerFn
                : Generator
            const generator = Object.create(protoGenerator.prototype)
            const context = new Context(tryLocsList || []) // The ._invoke method unifies the implementations of the .next,
            // .throw, and .return methods.

            generator._invoke = makeInvokeMethod(innerFn, self, context)
            return generator
          }

          exports.wrap = wrap // Try/catch helper to minimize deoptimizations. Returns a completion
          // record like context.tryEntries[i].completion. This interface could
          // have been (and was previously) designed to take a closure to be
          // invoked without arguments, but in all the cases we care about we
          // already have an existing method we want to call, so there's no need
          // to create a new function object. We can even get away with assuming
          // the method takes exactly one argument, since that happens to be true
          // in every case, so we don't have to touch the arguments object. The
          // only additional allocation required is the completion record, which
          // has a stable shape and so hopefully should be cheap to allocate.

          function tryCatch(fn, object, argument) {
            try {
              return {
                type: 'normal',
                arg: fn.call(object, argument),
              }
            } catch (error) {
              return {
                type: 'throw',
                arg: error,
              }
            }
          }

          const GenStateSuspendedStart = 'suspendedStart'
          const GenStateSuspendedYield = 'suspendedYield'
          const GenStateExecuting = 'executing'
          const GenStateCompleted = 'completed' // Returning this object from the innerFn has the same effect as
          // breaking out of the dispatch switch statement.

          const ContinueSentinel = {} // Dummy constructor functions that we use as the .constructor and
          // .constructor.prototype properties for functions that return Generator
          // objects. For full spec compliance, you may wish to configure your
          // minifier not to mangle the names of these two functions.

          function Generator() {}

          function GeneratorFunction() {}

          function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
          // don't natively support it.

          let IteratorPrototype = {}

          IteratorPrototype[iteratorSymbol] = function() {
            return this
          }

          const getProto = Object.getPrototypeOf
          const NativeIteratorPrototype =
            getProto && getProto(getProto(values([])))

          if (
            NativeIteratorPrototype &&
            NativeIteratorPrototype !== Op &&
            hasOwn.call(NativeIteratorPrototype, iteratorSymbol)
          ) {
            // This environment has a native %IteratorPrototype%; use it instead
            // of the polyfill.
            IteratorPrototype = NativeIteratorPrototype
          }

          const Gp = (GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(
            IteratorPrototype
          ))
          GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype
          GeneratorFunctionPrototype.constructor = GeneratorFunction
          GeneratorFunctionPrototype[
            toStringTagSymbol
          ] = GeneratorFunction.displayName = 'GeneratorFunction' // Helper for defining the .next, .throw, and .return methods of the
          // Iterator interface in terms of a single ._invoke method.

          function defineIteratorMethods(prototype) {
            ;['next', 'throw', 'return'].forEach(function(method) {
              prototype[method] = function(argument) {
                return this._invoke(method, argument)
              }
            })
          }

          exports.isGeneratorFunction = function(genFun) {
            const ctor = typeof genFun === 'function' && genFun.constructor
            return ctor
              ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
                  // do is to check its .name property.
                  (ctor.displayName || ctor.name) === 'GeneratorFunction'
              : false
          }

          exports.mark = function(genFun) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(genFun, GeneratorFunctionPrototype)
            } else {
              genFun.__proto__ = GeneratorFunctionPrototype

              if (!(toStringTagSymbol in genFun)) {
                genFun[toStringTagSymbol] = 'GeneratorFunction'
              }
            }

            genFun.prototype = Object.create(Gp)
            return genFun
          } // Within the body of any async function, `await x` is transformed to
          // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
          // `hasOwn.call(value, "__await")` to determine if the yielded value is
          // meant to be awaited.

          exports.awrap = function(argument) {
            return {
              __await: argument,
            }
          }

          function AsyncIterator(generator) {
            function invoke(method, argument, resolve, reject) {
              const record = tryCatch(generator[method], generator, argument)

              if (record.type === 'throw') {
                reject(record.arg)
              } else {
                const result = record.arg
                const {value} = result

                if (
                  value &&
                  typeof value === 'object' &&
                  hasOwn.call(value, '__await')
                ) {
                  return Promise.resolve(value.__await).then(
                    function(value) {
                      invoke('next', value, resolve, reject)
                    },
                    function(error) {
                      invoke('throw', error, resolve, reject)
                    }
                  )
                }

                return Promise.resolve(value).then(
                  function(unwrapped) {
                    // When a yielded Promise is resolved, its final value becomes
                    // the .value of the Promise<{value,done}> result for the
                    // current iteration.
                    result.value = unwrapped
                    resolve(result)
                  },
                  function(error) {
                    // If a rejected Promise was yielded, throw the rejection back
                    // into the async generator function so it can be handled there.
                    return invoke('throw', error, resolve, reject)
                  }
                )
              }
            }

            let previousPromise

            function enqueue(method, argument) {
              function callInvokeWithMethodAndArgument() {
                return new Promise(function(resolve, reject) {
                  invoke(method, argument, resolve, reject)
                })
              }

              return (previousPromise = // If enqueue has been called before, then we want to wait until
                // all previous Promises have been resolved before calling invoke,
                // so that results are always delivered in the correct order. If
                // enqueue has not been called before, then it is important to
                // call invoke immediately, without waiting on a callback to fire,
                // so that the async generator function has the opportunity to do
                // any necessary setup in a predictable way. This predictability
                // is why the Promise constructor synchronously invokes its
                // executor callback, and why async functions synchronously
                // execute code before the first await. Since we implement simple
                // async functions in terms of async generators, it is especially
                // important to get this right, even though it requires care.
                previousPromise
                  ? previousPromise.then(
                      callInvokeWithMethodAndArgument, // Avoid propagating failures to Promises returned by later
                      // invocations of the iterator.
                      callInvokeWithMethodAndArgument
                    )
                  : callInvokeWithMethodAndArgument())
            } // Define the unified helper method that is used to implement .next,
            // .throw, and .return (see defineIteratorMethods).

            this._invoke = enqueue
          }

          defineIteratorMethods(AsyncIterator.prototype)

          AsyncIterator.prototype[asyncIteratorSymbol] = function() {
            return this
          }

          exports.AsyncIterator = AsyncIterator // Note that simple async functions are implemented on top of
          // AsyncIterator objects; they just return a Promise for the value of
          // the final result produced by the iterator.

          exports.async = function(innerFn, outerFn, self, tryLocsList) {
            const iter = new AsyncIterator(
              wrap(innerFn, outerFn, self, tryLocsList)
            )
            return exports.isGeneratorFunction(outerFn)
              ? iter // If outerFn is a generator, return the full iterator.
              : iter.next().then(function(result) {
                  return result.done ? result.value : iter.next()
                })
          }

          function makeInvokeMethod(innerFn, self, context) {
            let state = GenStateSuspendedStart
            return function invoke(method, argument) {
              if (state === GenStateExecuting) {
                throw new Error('Generator is already running')
              }

              if (state === GenStateCompleted) {
                if (method === 'throw') {
                  throw argument
                } // Be forgiving, per 25.3.3.3.3 of the spec:
                // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume

                return doneResult()
              }

              context.method = method
              context.arg = argument

              while (true) {
                const {delegate} = context

                if (delegate) {
                  const delegateResult = maybeInvokeDelegate(delegate, context)

                  if (delegateResult) {
                    if (delegateResult === ContinueSentinel) {
                      continue
                    }
                    return delegateResult
                  }
                }

                if (context.method === 'next') {
                  // Setting context._sent for legacy support of Babel's
                  // function.sent implementation.
                  context.sent = context._sent = context.arg
                } else if (context.method === 'throw') {
                  if (state === GenStateSuspendedStart) {
                    state = GenStateCompleted
                    throw context.arg
                  }

                  context.dispatchException(context.arg)
                } else if (context.method === 'return') {
                  context.abrupt('return', context.arg)
                }

                state = GenStateExecuting
                const record = tryCatch(innerFn, self, context)

                if (record.type === 'normal') {
                  // If an exception is thrown from innerFn, we leave state ===
                  // GenStateExecuting and loop back for another invocation.
                  state = context.done
                    ? GenStateCompleted
                    : GenStateSuspendedYield

                  if (record.arg === ContinueSentinel) {
                    continue
                  }

                  return {
                    value: record.arg,
                    done: context.done,
                  }
                }
                if (record.type === 'throw') {
                  state = GenStateCompleted // Dispatch the exception by looping back around to the
                  // context.dispatchException(context.arg) call above.

                  context.method = 'throw'
                  context.arg = record.arg
                }
              }
            }
          } // Call delegate.iterator[context.method](context.arg) and handle the
          // result, either by returning a { value, done } result from the
          // delegate iterator, or by modifying context.method and context.arg,
          // setting context.delegate to null, and returning the ContinueSentinel.

          function maybeInvokeDelegate(delegate, context) {
            const method = delegate.iterator[context.method]

            if (method === undefined) {
              // A .throw or .return when the delegate iterator has no .throw
              // method always terminates the yield* loop.
              context.delegate = null

              if (context.method === 'throw') {
                // Note: ["return"] must be used for ES3 parsing compatibility.
                if (delegate.iterator.return) {
                  // If the delegate iterator has a return method, give it a
                  // chance to clean up.
                  context.method = 'return'
                  context.arg = undefined
                  maybeInvokeDelegate(delegate, context)

                  if (context.method === 'throw') {
                    // If maybeInvokeDelegate(context) changed context.method from
                    // "return" to "throw", let that override the TypeError below.
                    return ContinueSentinel
                  }
                }

                context.method = 'throw'
                context.arg = new TypeError(
                  "The iterator does not provide a 'throw' method"
                )
              }

              return ContinueSentinel
            }

            const record = tryCatch(method, delegate.iterator, context.arg)

            if (record.type === 'throw') {
              context.method = 'throw'
              context.arg = record.arg
              context.delegate = null
              return ContinueSentinel
            }

            const info = record.arg

            if (!info) {
              context.method = 'throw'
              context.arg = new TypeError('iterator result is not an object')
              context.delegate = null
              return ContinueSentinel
            }

            if (info.done) {
              // Assign the result of the finished delegate to the temporary
              // variable specified by delegate.resultName (see delegateYield).
              context[delegate.resultName] = info.value // Resume execution at the desired location (see delegateYield).

              context.next = delegate.nextLoc // If context.method was "throw" but the delegate handled the
              // exception, let the outer generator proceed normally. If
              // context.method was "next", forget context.arg since it has been
              // "consumed" by the delegate iterator. If context.method was
              // "return", allow the original .return call to continue in the
              // outer generator.

              if (context.method !== 'return') {
                context.method = 'next'
                context.arg = undefined
              }
            } else {
              // Re-yield the result returned by the delegate method.
              return info
            } // The delegate iterator is finished, so forget it and continue with
            // the outer generator.

            context.delegate = null
            return ContinueSentinel
          } // Define Generator.prototype.{next,throw,return} in terms of the
          // unified ._invoke helper method.

          defineIteratorMethods(Gp)
          Gp[toStringTagSymbol] = 'Generator' // A Generator should always return itself as the iterator object when the
          // @@iterator function is called on it. Some browsers' implementations of the
          // iterator prototype chain incorrectly implement this, causing the Generator
          // object to not be returned from this call. This ensures that doesn't happen.
          // See https://github.com/facebook/regenerator/issues/274 for more details.

          Gp[iteratorSymbol] = function() {
            return this
          }

          Gp.toString = function() {
            return '[object Generator]'
          }

          function pushTryEntry(locs) {
            const entry = {
              tryLoc: locs[0],
            }

            if (1 in locs) {
              entry.catchLoc = locs[1]
            }

            if (2 in locs) {
              entry.finallyLoc = locs[2]
              entry.afterLoc = locs[3]
            }

            this.tryEntries.push(entry)
          }

          function resetTryEntry(entry) {
            const record = entry.completion || {}
            record.type = 'normal'
            delete record.arg
            entry.completion = record
          }

          function Context(tryLocsList) {
            // The root entry object (effectively a try statement without a catch
            // or a finally block) gives us a place to store values thrown from
            // locations where there is no enclosing try statement.
            this.tryEntries = [
              {
                tryLoc: 'root',
              },
            ]
            tryLocsList.forEach(pushTryEntry, this)
            this.reset(true)
          }

          exports.keys = function(object) {
            const keys = []

            for (const key in object) {
              keys.push(key)
            }

            keys.reverse() // Rather than returning an object with a next method, we keep
            // things simple and return the next function itself.

            return function next() {
              while (keys.length) {
                const key = keys.pop()

                if (key in object) {
                  next.value = key
                  next.done = false
                  return next
                }
              } // To avoid creating an additional object, we just hang the .value
              // and .done properties off the next function object itself. This
              // also ensures that the minifier will not anonymize the function.

              next.done = true
              return next
            }
          }

          function values(iterable) {
            if (iterable) {
              const iteratorMethod = iterable[iteratorSymbol]

              if (iteratorMethod) {
                return iteratorMethod.call(iterable)
              }

              if (typeof iterable.next === 'function') {
                return iterable
              }

              if (!isNaN(iterable.length)) {
                let i = -1
                const next = function next() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next.value = iterable[i]
                      next.done = false
                      return next
                    }
                  }

                  next.value = undefined
                  next.done = true
                  return next
                }

                return (next.next = next)
              }
            } // Return an iterator with no values.

            return {
              next: doneResult,
            }
          }

          exports.values = values

          function doneResult() {
            return {
              value: undefined,
              done: true,
            }
          }

          Context.prototype = {
            constructor: Context,
            reset: function reset(skipTemporaryReset) {
              this.prev = 0
              this.next = 0 // Resetting context._sent for legacy support of Babel's
              // function.sent implementation.

              this.sent = this._sent = undefined
              this.done = false
              this.delegate = null
              this.method = 'next'
              this.arg = undefined
              this.tryEntries.forEach(resetTryEntry)

              if (!skipTemporaryReset) {
                for (const name in this) {
                  // Not sure about the optimal order of these conditions:
                  if (
                    name.charAt(0) === 't' &&
                    hasOwn.call(this, name) &&
                    !isNaN(Number(name.slice(1)))
                  ) {
                    this[name] = undefined
                  }
                }
              }
            },
            stop: function stop() {
              this.done = true
              const rootEntry = this.tryEntries[0]
              const rootRecord = rootEntry.completion

              if (rootRecord.type === 'throw') {
                throw rootRecord.arg
              }

              return this.rval
            },
            dispatchException: function dispatchException(exception) {
              if (this.done) {
                throw exception
              }

              const context = this

              function handle(loc, caught) {
                record.type = 'throw'
                record.arg = exception
                context.next = loc

                if (caught) {
                  // If the dispatched exception was caught by a catch block,
                  // then let that catch block handle the exception normally.
                  context.method = 'next'
                  context.arg = undefined
                }

                return !!caught
              }

              for (let i = this.tryEntries.length - 1; i >= 0; --i) {
                const entry = this.tryEntries[i]
                var record = entry.completion

                if (entry.tryLoc === 'root') {
                  // Exception thrown outside of any try block that could handle
                  // it, so set the completion value of the entire function to
                  // throw the exception.
                  return handle('end')
                }

                if (entry.tryLoc <= this.prev) {
                  const hasCatch = hasOwn.call(entry, 'catchLoc')
                  const hasFinally = hasOwn.call(entry, 'finallyLoc')

                  if (hasCatch && hasFinally) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true)
                    }
                    if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc)
                    }
                  } else if (hasCatch) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true)
                    }
                  } else if (hasFinally) {
                    if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc)
                    }
                  } else {
                    throw new Error('try statement without catch or finally')
                  }
                }
              }
            },
            abrupt: function abrupt(type, argument) {
              for (let i = this.tryEntries.length - 1; i >= 0; --i) {
                const entry = this.tryEntries[i]

                if (
                  entry.tryLoc <= this.prev &&
                  hasOwn.call(entry, 'finallyLoc') &&
                  this.prev < entry.finallyLoc
                ) {
                  var finallyEntry = entry
                  break
                }
              }

              if (
                finallyEntry &&
                (type === 'break' || type === 'continue') &&
                finallyEntry.tryLoc <= argument &&
                argument <= finallyEntry.finallyLoc
              ) {
                // Ignore the finally entry if control is not jumping to a
                // location outside the try/catch block.
                finallyEntry = null
              }

              const record = finallyEntry ? finallyEntry.completion : {}
              record.type = type
              record.arg = argument

              if (finallyEntry) {
                this.method = 'next'
                this.next = finallyEntry.finallyLoc
                return ContinueSentinel
              }

              return this.complete(record)
            },
            complete: function complete(record, afterLoc) {
              if (record.type === 'throw') {
                throw record.arg
              }

              if (record.type === 'break' || record.type === 'continue') {
                this.next = record.arg
              } else if (record.type === 'return') {
                this.rval = this.arg = record.arg
                this.method = 'return'
                this.next = 'end'
              } else if (record.type === 'normal' && afterLoc) {
                this.next = afterLoc
              }

              return ContinueSentinel
            },
            finish: function finish(finallyLoc) {
              for (let i = this.tryEntries.length - 1; i >= 0; --i) {
                const entry = this.tryEntries[i]

                if (entry.finallyLoc === finallyLoc) {
                  this.complete(entry.completion, entry.afterLoc)
                  resetTryEntry(entry)
                  return ContinueSentinel
                }
              }
            },
            catch: function _catch(tryLoc) {
              for (let i = this.tryEntries.length - 1; i >= 0; --i) {
                const entry = this.tryEntries[i]

                if (entry.tryLoc === tryLoc) {
                  const record = entry.completion

                  if (record.type === 'throw') {
                    var thrown = record.arg
                    resetTryEntry(entry)
                  }

                  return thrown
                }
              } // The context.catch method must only be called with a location
              // argument that corresponds to a known catch block.

              throw new Error('illegal catch attempt')
            },
            delegateYield: function delegateYield(
              iterable,
              resultName,
              nextLoc
            ) {
              this.delegate = {
                iterator: values(iterable),
                resultName,
                nextLoc,
              }

              if (this.method === 'next') {
                // Deliberately forget the last sent value so that we don't
                // accidentally pass it on to the delegate.
                this.arg = undefined
              }

              return ContinueSentinel
            },
          } // Regardless of whether this script is executing as a CommonJS module
          // or not, return the runtime object so that we can declare the variable
          // regeneratorRuntime in the outer scope, which allows this module to be
          // injected easily by `bin/regenerator --include-runtime script.js`.

          return exports
        })(
          // If this script is executing as a CommonJS module, use module.exports
          // as the regeneratorRuntime namespace. Otherwise create a new empty
          // object. Either way, the resulting object will be used to initialize
          // the regeneratorRuntime variable at the top of this file.
          true ? module.exports : undefined
        )

        try {
          regeneratorRuntime = runtime
        } catch (error) {
          // This module should not be running in strict mode, so the above
          // assignment should always work unless something is misconfigured. Just
          // in case runtime.js accidentally runs in strict mode, we can escape
          // strict mode using a global Function call. This could conceivably fail
          // if a Content Security Policy forbids using Function, but in that case
          // the proper solution is to fix the accidental strict mode problem. If
          // you've misconfigured your bundler to force strict mode and applied a
          // CSP to forbid Function, and you're not willing to fix either of those
          // problems, please detail your unique predicament in a GitHub issue.
          new Function('r', 'regeneratorRuntime = r')(runtime)
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 76 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          13
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          43
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_2___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_2__
        )

        function ownKeys(object, enumerableOnly) {
          const keys = Object.keys(object)
          if (Object.getOwnPropertySymbols) {
            let symbols = Object.getOwnPropertySymbols(object)
            if (enumerableOnly) {
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable
              })
            }
            keys.push.apply(keys, symbols)
          }
          return keys
        }

        function _objectSpread(target) {
          for (let i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {}
            if (i % 2) {
              ownKeys(source, true).forEach(function(key) {
                _defineProperty(target, key, source[key])
              })
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(
                target,
                Object.getOwnPropertyDescriptors(source)
              )
            } else {
              ownKeys(source).forEach(function(key) {
                Object.defineProperty(
                  target,
                  key,
                  Object.getOwnPropertyDescriptor(source, key)
                )
              })
            }
          }
          return target
        }

        function _defineProperty(object, key, value) {
          if (key in object) {
            Object.defineProperty(object, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true,
            })
          } else {
            object[key] = value
          }
          return object
        }

        const path = __webpack_require__(15)

        const WIN_SLASH = '\\\\/'
        const WIN_NO_SLASH = `[^${WIN_SLASH}]`
        /**
         * Posix glob regex
         */

        const DOT_LITERAL = '\\.'
        const PLUS_LITERAL = '\\+'
        const QMARK_LITERAL = '\\?'
        const SLASH_LITERAL = '\\/'
        const ONE_CHAR = '(?=.)'
        const QMARK = '[^/]'
        const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`
        const START_ANCHOR = `(?:^|${SLASH_LITERAL})`
        const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`
        const NO_DOT = `(?!${DOT_LITERAL})`
        const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`
        const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`
        const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`
        const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`
        const STAR = `${QMARK}*?`
        const POSIX_CHARS = {
          DOT_LITERAL,
          PLUS_LITERAL,
          QMARK_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          QMARK,
          END_ANCHOR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOTS,
          NO_DOT_SLASH,
          NO_DOTS_SLASH,
          QMARK_NO_DOT,
          STAR,
          START_ANCHOR,
        }
        /**
         * Windows glob regex
         */

        const WINDOWS_CHARS = _objectSpread({}, POSIX_CHARS, {
          SLASH_LITERAL: `[${WIN_SLASH}]`,
          QMARK: WIN_NO_SLASH,
          STAR: `${WIN_NO_SLASH}*?`,
          DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
          NO_DOT: `(?!${DOT_LITERAL})`,
          NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
          NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
          NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
          QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
          START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
          END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
        })
        /**
         * POSIX Bracket Regex
         */

        const POSIX_REGEX_SOURCE = {
          alnum: 'a-zA-Z0-9',
          alpha: 'a-zA-Z',
          ascii: '\\x00-\\x7F',
          blank: ' \\t',
          cntrl: '\\x00-\\x1F\\x7F',
          digit: '0-9',
          graph: '\\x21-\\x7E',
          lower: 'a-z',
          print: '\\x20-\\x7E ',
          punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
          space: ' \\t\\r\\n\\v\\f',
          upper: 'A-Z',
          word: 'A-Za-z0-9_',
          xdigit: 'A-Fa-f0-9',
        }
        module.exports = {
          MAX_LENGTH: 1024 * 64,
          POSIX_REGEX_SOURCE,
          // regular expressions
          REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
          REGEX_NON_SPECIAL_CHAR: /^[^@![\].,$*+?^{}()|\\/]+/,
          REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
          REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
          REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
          REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
          // Replace globs with equivalent patterns to reduce parsing time.
          REPLACEMENTS: {
            '***': '*',
            '**/**': '**',
            '**/**/**': '**',
          },
          // Digits
          CHAR_0: 48,

          /* 0 */
          CHAR_9: 57,

          /* 9 */
          // Alphabet chars.
          CHAR_UPPERCASE_A: 65,

          /* A */
          CHAR_LOWERCASE_A: 97,

          /* a */
          CHAR_UPPERCASE_Z: 90,

          /* Z */
          CHAR_LOWERCASE_Z: 122,

          /* z */
          CHAR_LEFT_PARENTHESES: 40,

          /* ( */
          CHAR_RIGHT_PARENTHESES: 41,

          /* ) */
          CHAR_ASTERISK: 42,

          /* * */
          // Non-alphabetic chars.
          CHAR_AMPERSAND: 38,

          /* & */
          CHAR_AT: 64,

          /* @ */
          CHAR_BACKWARD_SLASH: 92,

          /* \ */
          CHAR_CARRIAGE_RETURN: 13,

          /* \r */
          CHAR_CIRCUMFLEX_ACCENT: 94,

          /* ^ */
          CHAR_COLON: 58,

          /* : */
          CHAR_COMMA: 44,

          /* , */
          CHAR_DOT: 46,

          /* . */
          CHAR_DOUBLE_QUOTE: 34,

          /* " */
          CHAR_EQUAL: 61,

          /* = */
          CHAR_EXCLAMATION_MARK: 33,

          /* ! */
          CHAR_FORM_FEED: 12,

          /* \f */
          CHAR_FORWARD_SLASH: 47,

          /* / */
          CHAR_GRAVE_ACCENT: 96,

          /* ` */
          CHAR_HASH: 35,

          /* # */
          CHAR_HYPHEN_MINUS: 45,

          /* - */
          CHAR_LEFT_ANGLE_BRACKET: 60,

          /* < */
          CHAR_LEFT_CURLY_BRACE: 123,

          /* { */
          CHAR_LEFT_SQUARE_BRACKET: 91,

          /* [ */
          CHAR_LINE_FEED: 10,

          /* \n */
          CHAR_NO_BREAK_SPACE: 160,

          /* \u00A0 */
          CHAR_PERCENT: 37,

          /* % */
          CHAR_PLUS: 43,

          /* + */
          CHAR_QUESTION_MARK: 63,

          /* ? */
          CHAR_RIGHT_ANGLE_BRACKET: 62,

          /* > */
          CHAR_RIGHT_CURLY_BRACE: 125,

          /* } */
          CHAR_RIGHT_SQUARE_BRACKET: 93,

          /* ] */
          CHAR_SEMICOLON: 59,

          /* ; */
          CHAR_SINGLE_QUOTE: 39,

          /* ' */
          CHAR_SPACE: 32,

          /*   */
          CHAR_TAB: 9,

          /* \t */
          CHAR_UNDERSCORE: 95,

          /* _ */
          CHAR_VERTICAL_LINE: 124,

          /* | */
          CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,

          /* \uFEFF */
          SEP: path.sep,

          /**
           * Create EXTGLOB_CHARS
           */
          extglobChars(chars) {
            return {
              '!': {
                type: 'negate',
                open: '(?:(?!(?:',
                close: `))${chars.STAR})`,
              },
              '?': {
                type: 'qmark',
                open: '(?:',
                close: ')?',
              },
              '+': {
                type: 'plus',
                open: '(?:',
                close: ')+',
              },
              '*': {
                type: 'star',
                open: '(?:',
                close: ')*',
              },
              '@': {
                type: 'at',
                open: '(?:',
                close: ')',
              },
            }
          },

          /**
           * Create GLOB_CHARS
           */
          globChars(win32) {
            return win32 === true ? WINDOWS_CHARS : POSIX_CHARS
          },
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 77 */
    /** */ function(module, exports, __webpack_require__) {
      const nativePropertyIsEnumerable = {}.propertyIsEnumerable
      const {getOwnPropertyDescriptor} = Object // Nashorn ~ JDK8 bug

      const NASHORN_BUG =
        getOwnPropertyDescriptor &&
        !nativePropertyIsEnumerable.call(
          {
            1: 2,
          },
          1
        ) // `Object.prototype.propertyIsEnumerable` method implementation
      // https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

      exports.f = NASHORN_BUG
        ? function propertyIsEnumerable(V) {
            const descriptor = getOwnPropertyDescriptor(this, V)
            return !!descriptor && descriptor.enumerable
          }
        : nativePropertyIsEnumerable

      /** */
    },
    /* 78 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          24
        )

        const fails = __webpack_require__(9)

        const classof = __webpack_require__(33)

        const {split} = '' // fallback for non-array-like ES3 and non-enumerable old V8 strings

        module.exports = fails(function() {
          // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
          // eslint-disable-next-line no-prototype-builtins
          return !new Object('z').propertyIsEnumerable(0)
        })
          ? function(it) {
              return classof(it) == 'String'
                ? split.call(it, '')
                : new Object(it)
            }
          : Object
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 79 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          16
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          3
        )
        /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          14
        )
        /* harmony import */ const core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          24
        )

        const hide = __webpack_require__(30)

        const redefine = __webpack_require__(25)

        const fails = __webpack_require__(9)

        const wellKnownSymbol = __webpack_require__(7)

        const regexpExec = __webpack_require__(95)

        const SPECIES = wellKnownSymbol('species')
        const REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
          // #replace needs built-in support for named groups.
          // #match works fine because it just return the exec results, even if it has
          // a "grops" property.
          const re = /./

          re.exec = function() {
            const result = []
            result.groups = {
              a: '7',
            }
            return result
          }

          return ''.replace(re, '$<a>') !== '7'
        }) // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
        // Weex JS has frozen built-in prototypes, so use try / catch wrapper

        const SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
          const re = /(?:)/
          const originalExec = re.exec

          re.exec = function() {
            return Reflect.apply(originalExec, this, arguments)
          }

          const result = 'ab'.split(re)
          return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b'
        })

        module.exports = function(KEY, length, exec, sham) {
          const SYMBOL = wellKnownSymbol(KEY)
          const DELEGATES_TO_SYMBOL = !fails(function() {
            // String methods call symbol-named RegEp methods
            const O = {}

            O[SYMBOL] = function() {
              return 7
            }

            return ''[KEY](O) != 7
          })
          const DELEGATES_TO_EXEC =
            DELEGATES_TO_SYMBOL &&
            !fails(function() {
              // Symbol-named RegExp methods call .exec
              let execCalled = false
              const re = /a/

              re.exec = function() {
                execCalled = true
                return null
              }

              if (KEY === 'split') {
                // RegExp[@@split] doesn't call the regex's exec method, but first creates
                // a new one. We need to return the patched regex when creating the new one.
                re.constructor = {}

                re.constructor[SPECIES] = function() {
                  return re
                }
              }

              re[SYMBOL]('')
              return !execCalled
            })

          if (
            !DELEGATES_TO_SYMBOL ||
            !DELEGATES_TO_EXEC ||
            (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
            (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
          ) {
            const nativeRegExpMethod = /./[SYMBOL]
            const methods = exec(SYMBOL, ''[KEY], function(
              nativeMethod,
              regexp,
              string,
              argument2,
              forceStringMethod
            ) {
              if (regexp.exec === regexpExec) {
                if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                  // The native String method already delegates to @@method (this
                  // polyfilled function), leasing to infinite recursion.
                  // We avoid it by directly calling the native @@method method.
                  return {
                    done: true,
                    value: nativeRegExpMethod.call(regexp, string, argument2),
                  }
                }

                return {
                  done: true,
                  value: nativeMethod.call(string, regexp, argument2),
                }
              }

              return {
                done: false,
              }
            })
            const stringMethod = methods[0]
            const regexMethod = methods[1]
            redefine(String.prototype, KEY, stringMethod)
            redefine(
              RegExp.prototype,
              SYMBOL,
              length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
                ? // 21.2.5.11 RegExp.prototype[@@split](string, limit)
                  function(string, argument) {
                    return regexMethod.call(string, this, argument)
                  } // 21.2.5.6 RegExp.prototype[@@match](string)
                : // 21.2.5.9 RegExp.prototype[@@search](string)
                  function(string) {
                    return regexMethod.call(string, this)
                  }
            )
            if (sham) {
              hide(RegExp.prototype[SYMBOL], 'sham', true)
            }
          }
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 80 */
    /** */ function(module, exports, __webpack_require__) {
      const global = __webpack_require__(8)

      const isObject = __webpack_require__(12)

      const {document} = global // typeof document.createElement is 'object' in old IE

      const EXISTS = isObject(document) && isObject(document.createElement)

      module.exports = function(it) {
        return EXISTS ? document.createElement(it) : {}
      }

      /** */
    },
    /* 81 */
    /** */ function(module, exports, __webpack_require__) {
      const global = __webpack_require__(8)

      const hide = __webpack_require__(30)

      module.exports = function(key, value) {
        try {
          hide(global, key, value)
        } catch (error) {
          global[key] = value
        }

        return value
      }

      /** */
    },
    /* 82 */
    /** */ function(module, exports, __webpack_require__) {
      module.exports = __webpack_require__(8)

      /** */
    },
    /* 83 */
    /** */ function(module, exports, __webpack_require__) {
      const toIndexedObject = __webpack_require__(29)

      const toLength = __webpack_require__(22)

      const toAbsoluteIndex = __webpack_require__(84) // `Array.prototype.{ indexOf, includes }` methods implementation

      const createMethod = function createMethod(IS_INCLUDES) {
        return function($this, element, fromIndex) {
          const O = toIndexedObject($this)
          const length = toLength(O.length)
          let index = toAbsoluteIndex(fromIndex, length)
          let value // Array#includes uses SameValueZero equality algorithm
          // eslint-disable-next-line no-self-compare

          if (IS_INCLUDES && element != element) {
            while (length > index) {
              value = O[index++] // eslint-disable-next-line no-self-compare

              if (value != value) {
                return true
              } // Array#indexOf ignores holes, Array#includes - not
            }
          } else {
            for (; length > index; index++) {
              if ((IS_INCLUDES || index in O) && O[index] === element) {
                return IS_INCLUDES || index || 0
              }
            }
          }
          return !IS_INCLUDES && -1
        }
      }

      module.exports = {
        // `Array.prototype.includes` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.includes
        includes: createMethod(true),
        // `Array.prototype.indexOf` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
        indexOf: createMethod(false),
      }

      /** */
    },
    /* 84 */
    /** */ function(module, exports, __webpack_require__) {
      const toInteger = __webpack_require__(39)

      const {max} = Math
      const {min} = Math // Helper for a popular repeating case of the spec:
      // Let integer be ? ToInteger(index).
      // If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).

      module.exports = function(index, length) {
        const integer = toInteger(index)
        return integer < 0 ? max(integer + length, 0) : min(integer, length)
      }

      /** */
    },
    /* 85 */
    /** */ function(module, exports, __webpack_require__) {
      const fails = __webpack_require__(9)

      module.exports = function(METHOD_NAME, argument) {
        const method = [][METHOD_NAME]
        return (
          !method ||
          !fails(function() {
            // eslint-disable-next-line no-useless-call,no-throw-literal
            method.call(
              null,
              argument ||
                function() {
                  throw 1
                },
              1
            )
          })
        )
      }

      /** */
    },
    /* 86 */
    /** */ function(module, exports) {
      // IE8- don't enum bug keys
      module.exports = [
        'constructor',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'toLocaleString',
        'toString',
        'valueOf',
      ]

      /** */
    },
    /* 87 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        5
      )

      exports.f = Object.getOwnPropertySymbols

      /** */
    },
    /* 88 */
    /** */ function(module, exports, __webpack_require__) {
      const internalObjectKeys = __webpack_require__(115)

      const enumBugKeys = __webpack_require__(86) // `Object.keys` method
      // https://tc39.github.io/ecma262/#sec-object.keys

      module.exports =
        Object.keys ||
        function keys(O) {
          return internalObjectKeys(O, enumBugKeys)
        }

      /** */
    },
    /* 89 */
    /** */ function(module, exports, __webpack_require__) {
      const path = __webpack_require__(82)

      const has = __webpack_require__(20)

      const wrappedWellKnownSymbolModule = __webpack_require__(118)

      const defineProperty = __webpack_require__(19).f

      module.exports = function(NAME) {
        const Symbol = path.Symbol || (path.Symbol = {})
        if (!has(Symbol, NAME)) {
          defineProperty(Symbol, NAME, {
            value: wrappedWellKnownSymbolModule.f(NAME),
          })
        }
      }

      /** */
    },
    /* 90 */
    /** */ function(module, exports, __webpack_require__) {
      const isObject = __webpack_require__(12)

      const isArray = __webpack_require__(60)

      const wellKnownSymbol = __webpack_require__(7)

      const SPECIES = wellKnownSymbol('species') // `ArraySpeciesCreate` abstract operation
      // https://tc39.github.io/ecma262/#sec-arrayspeciescreate

      module.exports = function(originalArray, length) {
        let C

        if (isArray(originalArray)) {
          C = originalArray.constructor // cross-realm fallback

          if (
            typeof C === 'function' &&
            (C === Array || isArray(C.prototype))
          ) {
            C = undefined
          } else if (isObject(C)) {
            C = C[SPECIES]
            if (C === null) {
              C = undefined
            }
          }
        }

        return new (C === undefined ? Array : C)(length === 0 ? 0 : length)
      }

      /** */
    },
    /* 91 */
    /** */ function(module, exports, __webpack_require__) {
      const global = __webpack_require__(8)

      const redefineAll = __webpack_require__(68)

      const InternalMetadataModule = __webpack_require__(69)

      const collection = __webpack_require__(92)

      const collectionWeak = __webpack_require__(158)

      const isObject = __webpack_require__(12)

      const enforceIternalState = __webpack_require__(38).enforce

      const NATIVE_WEAK_MAP = __webpack_require__(128)

      const IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global
      const {isExtensible} = Object
      let InternalWeakMap

      const wrapper = function wrapper(get) {
        return function WeakMap() {
          return get(this, arguments.length ? arguments[0] : undefined)
        }
      } // `WeakMap` constructor
      // https://tc39.github.io/ecma262/#sec-weakmap-constructor

      const $WeakMap = (module.exports = collection(
        'WeakMap',
        wrapper,
        collectionWeak,
        true,
        true
      )) // IE11 WeakMap frozen keys fix
      // We can't use feature detection because it crash some old IE builds
      // https://github.com/zloirock/core-js/issues/485

      if (NATIVE_WEAK_MAP && IS_IE11) {
        InternalWeakMap = collectionWeak.getConstructor(
          wrapper,
          'WeakMap',
          true
        )
        InternalMetadataModule.REQUIRED = true
        const WeakMapPrototype = $WeakMap.prototype
        const nativeDelete = WeakMapPrototype.delete
        const nativeHas = WeakMapPrototype.has
        const nativeGet = WeakMapPrototype.get
        const nativeSet = WeakMapPrototype.set
        redefineAll(WeakMapPrototype, {
          delete: function _delete(key) {
            if (isObject(key) && !isExtensible(key)) {
              const state = enforceIternalState(this)
              if (!state.frozen) {
                state.frozen = new InternalWeakMap()
              }
              return nativeDelete.call(this, key) || state.frozen.delete(key)
            }

            return nativeDelete.call(this, key)
          },
          has: function has(key) {
            if (isObject(key) && !isExtensible(key)) {
              const state = enforceIternalState(this)
              if (!state.frozen) {
                state.frozen = new InternalWeakMap()
              }
              return nativeHas.call(this, key) || state.frozen.has(key)
            }

            return nativeHas.call(this, key)
          },
          get: function get(key) {
            if (isObject(key) && !isExtensible(key)) {
              const state = enforceIternalState(this)
              if (!state.frozen) {
                state.frozen = new InternalWeakMap()
              }
              return nativeHas.call(this, key)
                ? nativeGet.call(this, key)
                : state.frozen.get(key)
            }

            return nativeGet.call(this, key)
          },
          set: function set(key, value) {
            if (isObject(key) && !isExtensible(key)) {
              const state = enforceIternalState(this)
              if (!state.frozen) {
                state.frozen = new InternalWeakMap()
              }
              nativeHas.call(this, key)
                ? nativeSet.call(this, key, value)
                : state.frozen.set(key, value)
            } else {
              nativeSet.call(this, key, value)
            }

            return this
          },
        })
      }

      /** */
    },
    /* 92 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          1
        )

        const $ = __webpack_require__(6)

        const global = __webpack_require__(8)

        const isForced = __webpack_require__(61)

        const redefine = __webpack_require__(25)

        const InternalMetadataModule = __webpack_require__(69)

        const iterate = __webpack_require__(70)

        const anInstance = __webpack_require__(71)

        const isObject = __webpack_require__(12)

        const fails = __webpack_require__(9)

        const checkCorrectnessOfIteration = __webpack_require__(93)

        const setToStringTag = __webpack_require__(40)

        const inheritIfRequired = __webpack_require__(127)

        module.exports = function(
          CONSTRUCTOR_NAME,
          wrapper,
          common,
          IS_MAP,
          IS_WEAK
        ) {
          const NativeConstructor = global[CONSTRUCTOR_NAME]
          const NativePrototype =
            NativeConstructor && NativeConstructor.prototype
          let Constructor = NativeConstructor
          const ADDER = IS_MAP ? 'set' : 'add'
          const exported = {}

          const fixMethod = function fixMethod(KEY) {
            const nativeMethod = NativePrototype[KEY]
            redefine(
              NativePrototype,
              KEY,
              KEY == 'add'
                ? function add(value) {
                    nativeMethod.call(this, value === 0 ? 0 : value)
                    return this
                  }
                : KEY == 'delete'
                ? function(key) {
                    return IS_WEAK && !isObject(key)
                      ? false
                      : nativeMethod.call(this, key === 0 ? 0 : key)
                  }
                : KEY == 'get'
                ? function get(key) {
                    return IS_WEAK && !isObject(key)
                      ? undefined
                      : nativeMethod.call(this, key === 0 ? 0 : key)
                  }
                : KEY == 'has'
                ? function has(key) {
                    return IS_WEAK && !isObject(key)
                      ? false
                      : nativeMethod.call(this, key === 0 ? 0 : key)
                  }
                : function set(key, value) {
                    nativeMethod.call(this, key === 0 ? 0 : key, value)
                    return this
                  }
            )
          } // eslint-disable-next-line max-len

          if (
            isForced(
              CONSTRUCTOR_NAME,
              typeof NativeConstructor !== 'function' ||
                !(
                  IS_WEAK ||
                  (NativePrototype.forEach &&
                    !fails(function() {
                      new NativeConstructor().entries().next()
                    }))
                )
            )
          ) {
            // create collection constructor
            Constructor = common.getConstructor(
              wrapper,
              CONSTRUCTOR_NAME,
              IS_MAP,
              ADDER
            )
            InternalMetadataModule.REQUIRED = true
          } else if (isForced(CONSTRUCTOR_NAME, true)) {
            const instance = new Constructor() // early implementations not supports chaining

            const HASNT_CHAINING =
              instance[ADDER](IS_WEAK ? {} : -0, 1) != instance // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false

            const THROWS_ON_PRIMITIVES = fails(function() {
              instance.has(1)
            }) // most early implementations doesn't supports iterables, most modern - not close it correctly
            // eslint-disable-next-line no-new

            const ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(
              iterable
            ) {
              new NativeConstructor(iterable)
            }) // for early implementations -0 and +0 not the same

            const BUGGY_ZERO =
              !IS_WEAK &&
              fails(function() {
                // V8 ~ Chromium 42- fails only with 5+ elements
                const $instance = new NativeConstructor()
                let index = 5

                while (index--) {
                  $instance[ADDER](index, index)
                }

                return !$instance.has(-0)
              })

            if (!ACCEPT_ITERABLES) {
              Constructor = wrapper(function(dummy, iterable) {
                anInstance(dummy, Constructor, CONSTRUCTOR_NAME)
                const that = inheritIfRequired(
                  new NativeConstructor(),
                  dummy,
                  Constructor
                )
                if (iterable != undefined) {
                  iterate(iterable, that[ADDER], that, IS_MAP)
                }
                return that
              })
              Constructor.prototype = NativePrototype
              NativePrototype.constructor = Constructor
            }

            if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
              fixMethod('delete')
              fixMethod('has')
              IS_MAP && fixMethod('get')
            }

            if (BUGGY_ZERO || HASNT_CHAINING) {
              fixMethod(ADDER)
            } // weak collections should not contains .clear method

            if (IS_WEAK && NativePrototype.clear) {
              delete NativePrototype.clear
            }
          }

          exported[CONSTRUCTOR_NAME] = Constructor
          $(
            {
              global: true,
              forced: Constructor != NativeConstructor,
            },
            exported
          )
          setToStringTag(Constructor, CONSTRUCTOR_NAME)
          if (!IS_WEAK) {
            common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP)
          }
          return Constructor
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 93 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          27
        )

        const wellKnownSymbol = __webpack_require__(7)

        const ITERATOR = wellKnownSymbol('iterator')
        let SAFE_CLOSING = false

        try {
          let called = 0
          const iteratorWithReturn = {
            next: function next() {
              return {
                done: !!called++,
              }
            },
            return: function _return() {
              SAFE_CLOSING = true
            },
          }

          iteratorWithReturn[ITERATOR] = function() {
            return this
          } // eslint-disable-next-line no-throw-literal

          Array.from(iteratorWithReturn, function() {
            throw 2
          })
        } catch (error) {
          /* empty */
        }

        module.exports = function(exec, SKIP_CLOSING) {
          if (!SKIP_CLOSING && !SAFE_CLOSING) {
            return false
          }
          let ITERATION_SUPPORT = false

          try {
            const object = {}

            object[ITERATOR] = function() {
              return {
                next: function next() {
                  return {
                    done: (ITERATION_SUPPORT = true),
                  }
                },
              }
            }

            exec(object)
          } catch (error) {
            /* empty */
          }

          return ITERATION_SUPPORT
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 94 */
    /** */ function(module, exports, __webpack_require__) {
      const $ = __webpack_require__(6)

      const toAbsoluteIndex = __webpack_require__(84)

      const toInteger = __webpack_require__(39)

      const toLength = __webpack_require__(22)

      const toObject = __webpack_require__(31)

      const arraySpeciesCreate = __webpack_require__(90)

      const createProperty = __webpack_require__(57)

      const arrayMethodHasSpeciesSupport = __webpack_require__(58)

      const {max} = Math
      const {min} = Math
      const MAX_SAFE_INTEGER = 0x1fffffffffffff
      const MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded' // `Array.prototype.splice` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.splice
      // with adding support of @@species

      $(
        {
          target: 'Array',
          proto: true,
          forced: !arrayMethodHasSpeciesSupport('splice'),
        },
        {
          splice: function splice(
            start,
            deleteCount
            /* , ...items */
          ) {
            const O = toObject(this)
            const length_ = toLength(O.length)
            const actualStart = toAbsoluteIndex(start, length_)
            const argumentsLength = arguments.length
            let insertCount
            let actualDeleteCount
            let A
            let k
            let from
            let to

            if (argumentsLength === 0) {
              insertCount = actualDeleteCount = 0
            } else if (argumentsLength === 1) {
              insertCount = 0
              actualDeleteCount = length_ - actualStart
            } else {
              insertCount = argumentsLength - 2
              actualDeleteCount = min(
                max(toInteger(deleteCount), 0),
                length_ - actualStart
              )
            }

            if (length_ + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
              throw new TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED)
            }

            A = arraySpeciesCreate(O, actualDeleteCount)

            for (k = 0; k < actualDeleteCount; k++) {
              from = actualStart + k
              if (from in O) {
                createProperty(A, k, O[from])
              }
            }

            A.length = actualDeleteCount

            if (insertCount < actualDeleteCount) {
              for (k = actualStart; k < length_ - actualDeleteCount; k++) {
                from = k + actualDeleteCount
                to = k + insertCount
                if (from in O) {
                  O[to] = O[from]
                } else {
                  delete O[to]
                }
              }

              for (
                k = length_;
                k > length_ - actualDeleteCount + insertCount;
                k--
              ) {
                delete O[k - 1]
              }
            } else if (insertCount > actualDeleteCount) {
              for (k = length_ - actualDeleteCount; k > actualStart; k--) {
                from = k + actualDeleteCount - 1
                to = k + insertCount - 1
                if (from in O) {
                  O[to] = O[from]
                } else {
                  delete O[to]
                }
              }
            }

            for (k = 0; k < insertCount; k++) {
              O[k + actualStart] = arguments[k + 2]
            }

            O.length = length_ - actualDeleteCount + insertCount
            return A
          },
        }
      )

      /** */
    },
    /* 95 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          16
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          3
        )
        /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          14
        )

        const regexpFlags = __webpack_require__(72)

        const nativeExec = RegExp.prototype.exec // This always refers to the native implementation, because the
        // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
        // which loads this file before patching the method.

        const nativeReplace = String.prototype.replace
        let patchedExec = nativeExec

        const UPDATES_LAST_INDEX_WRONG = (function() {
          const re1 = /a/
          const re2 = /b*/g
          nativeExec.call(re1, 'a')
          nativeExec.call(re2, 'a')
          return re1.lastIndex !== 0 || re2.lastIndex !== 0
        })() // nonparticipating capturing group, copied from es5-shim's String#split patch.

        const NPCG_INCLUDED = /()??/.exec('')[1] !== undefined
        const PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED

        if (PATCH) {
          patchedExec = function exec(string) {
            const re = this
            let lastIndex
            let reCopy
            let match
            let i

            if (NPCG_INCLUDED) {
              reCopy = new RegExp(`^${re.source}$(?!\\s)`, regexpFlags.call(re))
            }

            if (UPDATES_LAST_INDEX_WRONG) {
              lastIndex = re.lastIndex
            }
            match = nativeExec.call(re, string)

            if (UPDATES_LAST_INDEX_WRONG && match) {
              re.lastIndex = re.global
                ? match.index + match[0].length
                : lastIndex
            }

            if (NPCG_INCLUDED && match && match.length > 1) {
              // Fix browsers whose `exec` methods don't consistently return `undefined`
              // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
              nativeReplace.call(match[0], reCopy, function() {
                for (i = 1; i < arguments.length - 2; i++) {
                  if (arguments[i] === undefined) {
                    match[i] = undefined
                  }
                }
              })
            }

            return match
          }
        }

        module.exports = patchedExec
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 96 */
    /** */ function(module, exports, __webpack_require__) {
      const {charAt} = __webpack_require__(159) // `AdvanceStringIndex` abstract operation
      // https://tc39.github.io/ecma262/#sec-advancestringindex

      module.exports = function(S, index, unicode) {
        return index + (unicode ? charAt(S, index).length : 1)
      }

      /** */
    },
    /* 97 */
    /** */ function(module, exports, __webpack_require__) {
      const classof = __webpack_require__(33)

      const regexpExec = __webpack_require__(95) // `RegExpExec` abstract operation
      // https://tc39.github.io/ecma262/#sec-regexpexec

      module.exports = function(R, S) {
        const {exec} = R

        if (typeof exec === 'function') {
          const result = exec.call(R, S)

          if (typeof result !== 'object') {
            throw new TypeError(
              'RegExp exec method returned something other than an Object or null'
            )
          }

          return result
        }

        if (classof(R) !== 'RegExp') {
          throw new TypeError('RegExp#exec called on incompatible receiver')
        }

        return regexpExec.call(R, S)
      }

      /** */
    },
    /* 98 */
    /** */ function(module, exports, __webpack_require__) {
      const isObject = __webpack_require__(12)

      const classof = __webpack_require__(33)

      const wellKnownSymbol = __webpack_require__(7)

      const MATCH = wellKnownSymbol('match') // `IsRegExp` abstract operation
      // https://tc39.github.io/ecma262/#sec-isregexp

      module.exports = function(it) {
        let isRegExp
        return (
          isObject(it) &&
          ((isRegExp = it[MATCH]) !== undefined
            ? !!isRegExp
            : classof(it) == 'RegExp')
        )
      }

      /** */
    },
    /* 99 */
    /** */ function(module, exports, __webpack_require__) {
      const getBuiltIn = __webpack_require__(52)

      const definePropertyModule = __webpack_require__(19)

      const wellKnownSymbol = __webpack_require__(7)

      const DESCRIPTORS = __webpack_require__(18)

      const SPECIES = wellKnownSymbol('species')

      module.exports = function(CONSTRUCTOR_NAME) {
        const Constructor = getBuiltIn(CONSTRUCTOR_NAME)
        const defineProperty = definePropertyModule.f

        if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
          defineProperty(Constructor, SPECIES, {
            configurable: true,
            get: function get() {
              return this
            },
          })
        }
      }

      /** */
    },
    /* 100 */
    /** */ function(module, exports, __webpack_require__) {
      const anObject = __webpack_require__(17)

      const aFunction = __webpack_require__(55)

      const wellKnownSymbol = __webpack_require__(7)

      const SPECIES = wellKnownSymbol('species') // `SpeciesConstructor` abstract operation
      // https://tc39.github.io/ecma262/#sec-speciesconstructor

      module.exports = function(O, defaultConstructor) {
        const C = anObject(O).constructor
        let S
        return C === undefined || (S = anObject(C)[SPECIES]) == undefined
          ? defaultConstructor
          : aFunction(S)
      }

      /** */
    },
    /* 101 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          13
        )
        /* harmony import */ const core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          21
        )
        /* harmony import */ const core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          23
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          16
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          3
        )
        /* harmony import */ const core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          28
        )
        /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          14
        )
        /* harmony import */ const core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          24
        )
        /* harmony import */ const core_js_modules_es_string_trim__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          46
        )

        module.exports = minimatch
        minimatch.Minimatch = Minimatch
        let path = {
          sep: '/',
        }

        try {
          path = __webpack_require__(15)
        } catch (error) {}

        const GLOBSTAR = (minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {})

        const expand = __webpack_require__(166)

        const plTypes = {
          '!': {
            open: '(?:(?!(?:',
            close: '))[^/]*?)',
          },
          '?': {
            open: '(?:',
            close: ')?',
          },
          '+': {
            open: '(?:',
            close: ')+',
          },
          '*': {
            open: '(?:',
            close: ')*',
          },
          '@': {
            open: '(?:',
            close: ')',
          },
        } // any single thing other than /
        // don't need to escape / when using new RegExp()

        const qmark = '[^/]' // * => any number of characters

        const star = `${qmark}*?` // ** when dots are allowed.  Anything goes, except .. and .
        // not (^ or / followed by one or two dots followed by $ or /),
        // followed by anything, any number of times.

        const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?' // not a ^ or / followed by a dot,
        // followed by anything, any number of times.

        const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?' // characters that need to be escaped in RegExp.

        const reSpecials = charSet('().*{}+?[]^$\\!') // "abc" -> { a:true, b:true, c:true }

        function charSet(s) {
          return s.split('').reduce(function(set, c) {
            set[c] = true
            return set
          }, {})
        } // normalizes slashes.

        const slashSplit = /\/+/
        minimatch.filter = filter

        function filter(pattern, options) {
          options = options || {}
          return function(p, i, list) {
            return minimatch(p, pattern, options)
          }
        }

        function extension(a, b) {
          a = a || {}
          b = b || {}
          const t = {}
          Object.keys(b).forEach(function(k) {
            t[k] = b[k]
          })
          Object.keys(a).forEach(function(k) {
            t[k] = a[k]
          })
          return t
        }

        minimatch.defaults = function(def) {
          if (!def || !Object.keys(def).length) {
            return minimatch
          }
          const orig = minimatch

          const m = function minimatch(p, pattern, options) {
            return orig.minimatch(p, pattern, extension(def, options))
          }

          m.Minimatch = function Minimatch(pattern, options) {
            return new orig.Minimatch(pattern, extension(def, options))
          }

          return m
        }

        Minimatch.defaults = function(def) {
          if (!def || !Object.keys(def).length) {
            return Minimatch
          }
          return minimatch.defaults(def).Minimatch
        }

        function minimatch(p, pattern, options) {
          if (typeof pattern !== 'string') {
            throw new TypeError('glob pattern string required')
          }

          if (!options) {
            options = {}
          } // shortcut: comments match nothing.

          if (!options.nocomment && pattern.charAt(0) === '#') {
            return false
          } // "" only matches ""

          if (pattern.trim() === '') {
            return p === ''
          }
          return new Minimatch(pattern, options).match(p)
        }

        function Minimatch(pattern, options) {
          if (!(this instanceof Minimatch)) {
            return new Minimatch(pattern, options)
          }

          if (typeof pattern !== 'string') {
            throw new TypeError('glob pattern string required')
          }

          if (!options) {
            options = {}
          }
          pattern = pattern.trim() // windows support: need to use /, not \

          if (path.sep !== '/') {
            pattern = pattern.split(path.sep).join('/')
          }

          this.options = options
          this.set = []
          this.pattern = pattern
          this.regexp = null
          this.negate = false
          this.comment = false
          this.empty = false // make the set of regexps etc.

          this.make()
        }

        Minimatch.prototype.debug = function() {}

        Minimatch.prototype.make = make

        function make() {
          // don't do it more than once.
          if (this._made) {
            return
          }
          const {pattern} = this
          const {options} = this // empty patterns and comments match nothing.

          if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true
            return
          }

          if (!pattern) {
            this.empty = true
            return
          } // step 1: figure out negation, etc.

          this.parseNegate() // step 2: expand braces

          let set = (this.globSet = this.braceExpand())
          if (options.debug) {
            this.debug = console.error
          }
          this.debug(this.pattern, set) // step 3: now we have a set, so turn each one into a series of path-portion
          // matching patterns.
          // These will be regexps, except in the case of "**", which is
          // set to the GLOBSTAR object for globstar behavior,
          // and will not contain any / characters

          set = this.globParts = set.map(function(s) {
            return s.split(slashSplit)
          })
          this.debug(this.pattern, set) // glob --> regexps

          set = set.map(function(s, si, set) {
            return s.map(this.parse, this)
          }, this)
          this.debug(this.pattern, set) // filter out everything that didn't compile properly.

          set = set.filter(function(s) {
            return !s.includes(false)
          })
          this.debug(this.pattern, set)
          this.set = set
        }

        Minimatch.prototype.parseNegate = parseNegate

        function parseNegate() {
          const {pattern} = this
          let negate = false
          const {options} = this
          let negateOffset = 0
          if (options.nonegate) {
            return
          }

          for (
            let i = 0, l = pattern.length;
            i < l && pattern.charAt(i) === '!';
            i++
          ) {
            negate = !negate
            negateOffset++
          }

          if (negateOffset) {
            this.pattern = pattern.substr(negateOffset)
          }
          this.negate = negate
        } // Brace expansion:
        // a{b,c}d -> abd acd
        // a{b,}c -> abc ac
        // a{0..3}d -> a0d a1d a2d a3d
        // a{b,c{d,e}f}g -> abg acdfg acefg
        // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
        //
        // Invalid sets are not expanded.
        // a{2..}b -> a{2..}b
        // a{b}c -> a{b}c

        minimatch.braceExpand = function(pattern, options) {
          return braceExpand(pattern, options)
        }

        Minimatch.prototype.braceExpand = braceExpand

        function braceExpand(pattern, options) {
          if (!options) {
            if (this instanceof Minimatch) {
              options = this.options
            } else {
              options = {}
            }
          }

          pattern = typeof pattern === 'undefined' ? this.pattern : pattern

          if (typeof pattern === 'undefined') {
            throw new TypeError('undefined pattern')
          }

          if (options.nobrace || !pattern.match(/\{.*\}/)) {
            // shortcut. no need to expand.
            return [pattern]
          }

          return expand(pattern)
        } // parse a component of the expanded set.
        // At this point, no pattern may contain "/" in it
        // so we're going to return a 2d array, where each entry is the full
        // pattern, split on '/', and then turned into a regular expression.
        // A regexp is made at the end which joins each array with an
        // escaped /, and another full one which joins each regexp with |.
        //
        // Following the lead of Bash 4.1, note that "**" only has special meaning
        // when it is the *only* thing in a path portion.  Otherwise, any series
        // of * is equivalent to a single *.  Globstar behavior is enabled by
        // default, and can be disabled by setting options.noglobstar.

        Minimatch.prototype.parse = parse
        const SUBPARSE = {}

        function parse(pattern, isSub) {
          if (pattern.length > 1024 * 64) {
            throw new TypeError('pattern is too long')
          }

          const {options} = this // shortcuts

          if (!options.noglobstar && pattern === '**') {
            return GLOBSTAR
          }
          if (pattern === '') {
            return ''
          }
          let re = ''
          let hasMagic = !!options.nocase
          let escaping = false // ? => one single character

          const patternListStack = []
          const negativeLists = []
          let stateChar
          let inClass = false
          let reClassStart = -1
          let classStart = -1 // . and .. never match anything that doesn't start with .,
          // even when options.dot is set.

          const patternStart =
            pattern.charAt(0) === '.'
              ? '' // anything
              : // not (start or / followed by . or .. followed by / or end)
              options.dot
              ? '(?!(?:^|\\/)\\.{1,2}(?:$|\\/))'
              : '(?!\\.)'
          const self = this

          function clearStateChar() {
            if (stateChar) {
              // we had some state-tracking character
              // that wasn't consumed by this pass.
              switch (stateChar) {
                case '*':
                  re += star
                  hasMagic = true
                  break

                case '?':
                  re += qmark
                  hasMagic = true
                  break

                default:
                  re += `\\${stateChar}`
                  break
              }

              self.debug('clearStateChar %j %j', stateChar, re)
              stateChar = false
            }
          }

          for (
            var i = 0, length_ = pattern.length, c;
            i < length_ && (c = pattern.charAt(i));
            i++
          ) {
            this.debug('%s\t%s %s %j', pattern, i, re, c) // skip over any that are escaped.

            if (escaping && reSpecials[c]) {
              re += `\\${c}`
              escaping = false
              continue
            }

            switch (c) {
              case '/':
                // completely not allowed, even escaped.
                // Should already be path-split by now.
                return false

              case '\\':
                clearStateChar()
                escaping = true
                continue
              // the various stateChar values
              // for the "extglob" stuff.

              case '?':
              case '*':
              case '+':
              case '@':
              case '!':
                this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c) // all of those are literals inside a class, except that
                // the glob [!a] means [^a] in regexp

                if (inClass) {
                  this.debug('  in class')
                  if (c === '!' && i === classStart + 1) {
                    c = '^'
                  }
                  re += c
                  continue
                } // if we already have a stateChar, then it means
                // that there was something like ** or +? in there.
                // Handle the stateChar, then proceed with this one.

                self.debug('call clearStateChar %j', stateChar)
                clearStateChar()
                stateChar = c // if extglob is disabled, then +(asdf|foo) isn't a thing.
                // just clear the statechar *now*, rather than even diving into
                // the patternList stuff.

                if (options.noext) {
                  clearStateChar()
                }
                continue

              case '(':
                if (inClass) {
                  re += '('
                  continue
                }

                if (!stateChar) {
                  re += '\\('
                  continue
                }

                patternListStack.push({
                  type: stateChar,
                  start: i - 1,
                  reStart: re.length,
                  open: plTypes[stateChar].open,
                  close: plTypes[stateChar].close,
                }) // negation is (?:(?!js)[^/]*)

                re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
                this.debug('plType %j %j', stateChar, re)
                stateChar = false
                continue

              case ')':
                if (inClass || !patternListStack.length) {
                  re += '\\)'
                  continue
                }

                clearStateChar()
                hasMagic = true
                var pl = patternListStack.pop() // negation is (?:(?!js)[^/]*)
                // The others are (?:<pattern>)<type>

                re += pl.close

                if (pl.type === '!') {
                  negativeLists.push(pl)
                }

                pl.reEnd = re.length
                continue

              case '|':
                if (inClass || !patternListStack.length || escaping) {
                  re += '\\|'
                  escaping = false
                  continue
                }

                clearStateChar()
                re += '|'
                continue
              // these are mostly the same in regexp and glob

              case '[':
                // swallow any state-tracking char before the [
                clearStateChar()

                if (inClass) {
                  re += `\\${c}`
                  continue
                }

                inClass = true
                classStart = i
                reClassStart = re.length
                re += c
                continue

              case ']':
                //  a right bracket shall lose its special
                //  meaning and represent itself in
                //  a bracket expression if it occurs
                //  first in the list.  -- POSIX.2 2.8.3.2
                if (i === classStart + 1 || !inClass) {
                  re += `\\${c}`
                  escaping = false
                  continue
                } // handle the case where we left a class open.
                // "[z-a]" is valid, equivalent to "\[z-a\]"

                if (inClass) {
                  // split where the last [ was, make sure we don't have
                  // an invalid re. if so, re-walk the contents of the
                  // would-be class to re-translate any characters that
                  // were passed through as-is
                  // TODO: It would probably be faster to determine this
                  // without a try/catch and a new RegExp, but it's tricky
                  // to do safely.  For now, this is safe and works.
                  var cs = pattern.substring(classStart + 1, i)

                  try {
                    new RegExp(`[${cs}]`)
                  } catch (error) {
                    // not a valid class!
                    var sp = this.parse(cs, SUBPARSE)
                    re = `${re.substr(0, reClassStart)}\\[${sp[0]}\\]`
                    hasMagic = hasMagic || sp[1]
                    inClass = false
                    continue
                  }
                } // finish up the class.

                hasMagic = true
                inClass = false
                re += c
                continue

              default:
                // swallow any state char that wasn't consumed
                clearStateChar()

                if (escaping) {
                  // no need
                  escaping = false
                } else if (reSpecials[c] && !(c === '^' && inClass)) {
                  re += '\\'
                }

                re += c
            } // switch
          } // for
          // handle the case where we left a class open.
          // "[abc" is valid, equivalent to "\[abc"

          if (inClass) {
            // split where the last [ was, and escape it
            // this is a huge pita.  We now have to re-walk
            // the contents of the would-be class to re-translate
            // any characters that were passed through as-is
            cs = pattern.substr(classStart + 1)
            sp = this.parse(cs, SUBPARSE)
            re = `${re.substr(0, reClassStart)}\\[${sp[0]}`
            hasMagic = hasMagic || sp[1]
          } // handle the case where we had a +( thing at the *end*
          // of the pattern.
          // each pattern list stack adds 3 chars, and we need to go through
          // and escape any | chars that were passed through as-is for the regexp.
          // Go through and escape them, taking care not to double-escape any
          // | chars that were already escaped.

          for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
            let tail = re.slice(pl.reStart + pl.open.length)
            this.debug('setting tail', re, pl) // maybe some even number of \, then maybe 1 \, followed by a |

            tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(
              _,
              $1,
              $2
            ) {
              if (!$2) {
                // the | isn't already escaped, so escape it.
                $2 = '\\'
              } // need to escape all those slashes *again*, without escaping the
              // one that we need for escaping the | character.  As it works out,
              // escaping an even number of slashes can be done by simply repeating
              // it exactly after itself.  That's why this trick works.
              //
              // I am sorry that you have to see this.

              return `${$1 + $1 + $2}|`
            })
            this.debug('tail=%j\n   %s', tail, tail, pl, re)
            const t =
              pl.type === '*' ? star : pl.type === '?' ? qmark : `\\${pl.type}`
            hasMagic = true
            re = `${re.slice(0, pl.reStart) + t}\\(${tail}`
          } // handle trailing things that only matter at the very end.

          clearStateChar()

          if (escaping) {
            // trailing \\
            re += '\\\\'
          } // only need to apply the nodot start if the re starts with
          // something that could conceivably capture a dot

          let addPatternStart = false

          switch (re.charAt(0)) {
            case '.':
            case '[':
            case '(':
              addPatternStart = true
          } // Hack to work around lack of negative lookbehind in JS
          // A pattern like: *.!(x).!(y|z) needs to ensure that a name
          // like 'a.xyz.yz' doesn't match.  So, the first negative
          // lookahead, has to look ALL the way ahead, to the end of
          // the pattern.

          for (let n = negativeLists.length - 1; n > -1; n--) {
            const nl = negativeLists[n]
            const nlBefore = re.slice(0, nl.reStart)
            const nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
            let nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
            let nlAfter = re.slice(nl.reEnd)
            nlLast += nlAfter // Handle nested stuff like *(*.js|!(*.json)), where open parens
            // mean that we should *not* include the ) in the bit that is considered
            // "after" the negated section.

            const openParensBefore = nlBefore.split('(').length - 1
            let cleanAfter = nlAfter

            for (i = 0; i < openParensBefore; i++) {
              cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
            }

            nlAfter = cleanAfter
            let dollar = ''

            if (nlAfter === '' && isSub !== SUBPARSE) {
              dollar = '$'
            }

            const newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
            re = newRe
          } // if the re is not "" at this point, then we need to make sure
          // it doesn't match against an empty path part.
          // Otherwise a/* will match a/, which it should not.

          if (re !== '' && hasMagic) {
            re = `(?=.)${re}`
          }

          if (addPatternStart) {
            re = patternStart + re
          } // parsing just a piece of a larger pattern.

          if (isSub === SUBPARSE) {
            return [re, hasMagic]
          } // skip the regexp for non-magical patterns
          // unescape anything in it, though, so that it'll be
          // an exact match against a file etc.

          if (!hasMagic) {
            return globUnescape(pattern)
          }

          const flags = options.nocase ? 'i' : ''

          try {
            var regExp = new RegExp(`^${re}$`, flags)
          } catch (error) {
            // If it was an invalid regular expression, then it can't match
            // anything.  This trick looks for a character after the end of
            // the string, which is of course impossible, except in multi-line
            // mode, but it's not a /m regex.
            return new RegExp('$.')
          }

          regExp._glob = pattern
          regExp._src = re
          return regExp
        }

        minimatch.makeRe = function(pattern, options) {
          return new Minimatch(pattern, options || {}).makeRe()
        }

        Minimatch.prototype.makeRe = makeRe

        function makeRe() {
          if (this.regexp || this.regexp === false) {
            return this.regexp
          } // at this point, this.set is a 2d array of partial
          // pattern strings, or "**".
          //
          // It's better to use .match().  This function shouldn't
          // be used, really, but it's pretty convenient sometimes,
          // when you just want to work with a regex.

          const {set} = this

          if (!set.length) {
            this.regexp = false
            return this.regexp
          }

          const {options} = this
          const twoStar = options.noglobstar
            ? star
            : options.dot
            ? twoStarDot
            : twoStarNoDot
          const flags = options.nocase ? 'i' : ''
          let re = set
            .map(function(pattern) {
              return pattern
                .map(function(p) {
                  return p === GLOBSTAR
                    ? twoStar
                    : typeof p === 'string'
                    ? regExpEscape(p)
                    : p._src
                })
                .join('\\/')
            })
            .join('|') // must match entire pattern
          // ending in a * or ** will make it less strict.

          re = `^(?:${re})$` // can match anything, as long as it's not this.

          if (this.negate) {
            re = `^(?!${re}).*$`
          }

          try {
            this.regexp = new RegExp(re, flags)
          } catch (error) {
            this.regexp = false
          }

          return this.regexp
        }

        minimatch.match = function(list, pattern, options) {
          options = options || {}
          const mm = new Minimatch(pattern, options)
          list = list.filter(function(f) {
            return mm.match(f)
          })

          if (mm.options.nonull && !list.length) {
            list.push(pattern)
          }

          return list
        }

        Minimatch.prototype.match = match

        function match(f, partial) {
          this.debug('match', f, this.pattern) // short-circuit in the case of busted things.
          // comments, etc.

          if (this.comment) {
            return false
          }
          if (this.empty) {
            return f === ''
          }
          if (f === '/' && partial) {
            return true
          }
          const {options} = this // windows: need to use /, not \

          if (path.sep !== '/') {
            f = f.split(path.sep).join('/')
          } // treat the test path as a set of pathparts.

          f = f.split(slashSplit)
          this.debug(this.pattern, 'split', f) // just ONE of the pattern sets in this.set needs to match
          // in order for it to be valid.  If negating, then just one
          // match means that we have failed.
          // Either way, return on the first hit.

          const {set} = this
          this.debug(this.pattern, 'set', set) // Find the basename of the path by looking for the last non-empty segment

          let filename
          let i

          for (i = f.length - 1; i >= 0; i--) {
            filename = f[i]
            if (filename) {
              break
            }
          }

          for (i = 0; i < set.length; i++) {
            const pattern = set[i]
            let file = f

            if (options.matchBase && pattern.length === 1) {
              file = [filename]
            }

            const hit = this.matchOne(file, pattern, partial)

            if (hit) {
              if (options.flipNegate) {
                return true
              }
              return !this.negate
            }
          } // didn't get any hits.  this is success if it's a negative
          // pattern, failure otherwise.

          if (options.flipNegate) {
            return false
          }
          return this.negate
        } // set partial to true to test if, for example,
        // "/a/b" matches the start of "/*/b/*/d"
        // Partial means, if you run out of file before you run
        // out of pattern, then that's fine, as long as all
        // the parts match.

        Minimatch.prototype.matchOne = function(file, pattern, partial) {
          const {options} = this
          this.debug('matchOne', {
            this: this,
            file,
            pattern,
          })
          this.debug('matchOne', file.length, pattern.length)

          for (
            var fi = 0, pi = 0, fl = file.length, pl = pattern.length;
            fi < fl && pi < pl;
            fi++, pi++
          ) {
            this.debug('matchOne loop')
            const p = pattern[pi]
            const f = file[fi]
            this.debug(pattern, p, f) // should be impossible.
            // some invalid regexp stuff in the set.

            if (p === false) {
              return false
            }

            if (p === GLOBSTAR) {
              this.debug('GLOBSTAR', [pattern, p, f]) // "**"
              // a/**/b/**/c would match the following:
              // a/b/x/y/z/c
              // a/x/y/z/b/c
              // a/b/x/b/x/c
              // a/b/c
              // To do this, take the rest of the pattern after
              // the **, and see if it would match the file remainder.
              // If so, return success.
              // If not, the ** "swallows" a segment, and try again.
              // This is recursively awful.
              //
              // a/**/b/**/c matching a/b/x/y/z/c
              // - a matches a
              // - doublestar
              //   - matchOne(b/x/y/z/c, b/**/c)
              //     - b matches b
              //     - doublestar
              //       - matchOne(x/y/z/c, c) -> no
              //       - matchOne(y/z/c, c) -> no
              //       - matchOne(z/c, c) -> no
              //       - matchOne(c, c) yes, hit

              let fr = fi
              const pr = pi + 1

              if (pr === pl) {
                this.debug('** at the end') // a ** at the end will just swallow the rest.
                // We have found a match.
                // however, it will not swallow /.x, unless
                // options.dot is set.
                // . and .. are *never* matched by **, for explosively
                // exponential reasons.

                for (; fi < fl; fi++) {
                  if (
                    file[fi] === '.' ||
                    file[fi] === '..' ||
                    (!options.dot && file[fi].charAt(0) === '.')
                  ) {
                    return false
                  }
                }

                return true
              } // ok, let's see if we can swallow whatever we can.

              while (fr < fl) {
                const swallowee = file[fr]
                this.debug('\nglobstar while', file, fr, pattern, pr, swallowee) // XXX remove this slice.  Just pass the start index.

                if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                  this.debug('globstar found match!', fr, fl, swallowee) // found a match.

                  return true
                }
                // can't swallow "." or ".." ever.
                // can only swallow ".foo" when explicitly asked.
                if (
                  swallowee === '.' ||
                  swallowee === '..' ||
                  (!options.dot && swallowee.charAt(0) === '.')
                ) {
                  this.debug('dot detected!', file, fr, pattern, pr)
                  break
                } // ** swallows a segment, and continue.

                this.debug('globstar swallow a segment, and continue')
                fr++
              } // no match was found.
              // However, in partial mode, we can't say this is necessarily over.
              // If there's more *pattern* left, then

              if (partial) {
                // ran out of file
                this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
                if (fr === fl) {
                  return true
                }
              }

              return false
            } // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.

            var hit

            if (typeof p === 'string') {
              if (options.nocase) {
                hit = f.toLowerCase() === p.toLowerCase()
              } else {
                hit = f === p
              }

              this.debug('string match', p, f, hit)
            } else {
              hit = f.match(p)
              this.debug('pattern match', p, f, hit)
            }

            if (!hit) {
              return false
            }
          } // Note: ending in / means that we'll get a final ""
          // at the end of the pattern.  This can only match a
          // corresponding "" at the end of the file.
          // If the file ends in /, then it can only match a
          // a pattern that ends in /, unless the pattern just
          // doesn't have any more for it. But, a/b/ should *not*
          // match "a/b/*", even though "" matches against the
          // [^/]*? pattern, except in partial mode, where it might
          // simply not be reached yet.
          // However, a/b/ should still satisfy a/*
          // now either we fell off the end of the pattern, or we're done.

          if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true
          }
          if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial
          }
          if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            const emptyFileEnd = fi === fl - 1 && file[fi] === ''
            return emptyFileEnd
          } // should be unreachable.

          throw new Error('wtf?')
        } // replace stuff like \* with *

        function globUnescape(s) {
          return s.replace(/\\(.)/g, '$1')
        }

        function regExpEscape(s) {
          return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 102 */
    /** */ function(module, exports, __webpack_require__) {
      function posix(path) {
        return path.charAt(0) === '/'
      }

      function win32(path) {
        // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
        const splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/
        const result = splitDeviceRe.exec(path)
        const device = result[1] || ''
        const isUnc = Boolean(device && device.charAt(1) !== ':') // UNC paths are always absolute

        return Boolean(result[2] || isUnc)
      }

      module.exports = process.platform === 'win32' ? win32 : posix
      module.exports.posix = posix
      module.exports.win32 = win32

      /** */
    },
    /* 103 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          21
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          2
        )

        /*!
         * is-glob <https://github.com/jonschlinkert/is-glob>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */
        const isExtglob = __webpack_require__(173)

        const chars = {
          '{': '}',
          '(': ')',
          '[': ']',
        }
        const strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/
        const relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/

        module.exports = function isGlob(string, options) {
          if (typeof string !== 'string' || string === '') {
            return false
          }

          if (isExtglob(string)) {
            return true
          }

          let regex = strictRegex
          let match // optionally relax regex

          if (options && options.strict === false) {
            regex = relaxedRegex
          }

          while ((match = regex.exec(string))) {
            if (match[2]) {
              return true
            }
            let idx = match.index + match[0].length // if an open bracket/brace/paren is escaped,
            // set the index to the next closing character

            const open = match[1]
            const close = open ? chars[open] : null

            if (open && close) {
              const n = string.indexOf(close, idx)

              if (n !== -1) {
                idx = n + 1
              }
            }

            string = string.slice(idx)
          }

          return false
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 104 */
    /** */ function(module, exports, __webpack_require__) {
      function __export(m) {
        for (const p in m) {
          if (!exports.hasOwnProperty(p)) {
            exports[p] = m[p]
          }
        }
      }

      const __importStar =
        (this && this.__importStar) ||
        function(module_) {
          if (module_ && module_.__esModule) {
            return module_
          }
          const result = {}
          if (module_ != null) {
            for (const k in module_) {
              if (Object.hasOwnProperty.call(module_, k)) {
                result[k] = module_[k]
              }
            }
          }
          result.default = module_
          return result
        }

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })

      const TSESTree = __importStar(__webpack_require__(177))

      exports.TSESTree = TSESTree

      __export(__webpack_require__(178))

      /** */
    },
    /* 105 */
    /** */ function(module, exports, __webpack_require__) {
      const getBuiltIn = __webpack_require__(52)

      module.exports = getBuiltIn('navigator', 'userAgent') || ''

      /** */
    },
    /* 106 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ const core_js_modules_es_array_last_index_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        48
      )
      /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        2
      )
      /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        14
      )
      /* harmony import */ const core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        24
      )

      const path = __webpack_require__(15)

      const win32 = process.platform === 'win32'

      const _require = __webpack_require__(76)
      const {REGEX_SPECIAL_CHARS} = _require
      const {REGEX_SPECIAL_CHARS_GLOBAL} = _require
      const {REGEX_REMOVE_BACKSLASH} = _require

      exports.isObject = function(value) {
        return (
          value !== null && typeof value === 'object' && !Array.isArray(value)
        )
      }

      exports.hasRegexChars = function(string) {
        return REGEX_SPECIAL_CHARS.test(string)
      }

      exports.isRegexChar = function(string) {
        return string.length === 1 && exports.hasRegexChars(string)
      }

      exports.escapeRegex = function(string) {
        return string.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1')
      }

      exports.toPosixSlashes = function(string) {
        return string.replace(/\\/g, '/')
      }

      exports.removeBackslashes = function(string) {
        return string.replace(REGEX_REMOVE_BACKSLASH, function(match) {
          return match === '\\' ? '' : match
        })
      }

      exports.supportsLookbehinds = function() {
        const segs = process.version.slice(1).split('.')

        if (
          (segs.length === 3 && Number(segs[0]) >= 9) ||
          (Number(segs[0]) === 8 && Number(segs[1]) >= 10)
        ) {
          return true
        }

        return false
      }

      exports.isWindows = function(options) {
        if (options && typeof options.windows === 'boolean') {
          return options.windows
        }

        return win32 === true || path.sep === '\\'
      }

      exports.escapeLast = function(input, char, lastIdx) {
        const idx = input.lastIndexOf(char, lastIdx)
        if (idx === -1) {
          return input
        }
        if (input[idx - 1] === '\\') {
          return exports.escapeLast(input, char, idx - 1)
        }
        return `${input.slice(0, idx)}\\${input.slice(idx)}`
      }

      /** */
    },
    /* 107 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_2___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_2__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          1
        )

        const utils = __webpack_require__(108)

        module.exports = function(ast) {
          const options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

          const stringify = function stringify(node) {
            const parent =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : {}
            const invalidBlock =
              options.escapeInvalid && utils.isInvalidBrace(parent)
            const invalidNode =
              node.invalid === true && options.escapeInvalid === true
            let output = ''

            if (node.value) {
              if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
                return `\\${node.value}`
              }

              return node.value
            }

            if (node.value) {
              return node.value
            }

            if (node.nodes) {
              let _iteratorNormalCompletion = true
              let _didIteratorError = false
              let _iteratorError

              try {
                for (
                  var _iterator = node.nodes[Symbol.iterator](), _step;
                  !(_iteratorNormalCompletion = (_step = _iterator.next())
                    .done);
                  _iteratorNormalCompletion = true
                ) {
                  const child = _step.value
                  output += stringify(child)
                }
              } catch (error) {
                _didIteratorError = true
                _iteratorError = error
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return()
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError
                  }
                }
              }
            }

            return output
          }

          return stringify(ast)
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 108 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ const core_js_modules_es_string_trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        46
      )

      exports.isInteger = function(number) {
        if (typeof number === 'number') {
          return Number.isInteger(number)
        }

        if (typeof number === 'string' && number.trim() !== '') {
          return Number.isInteger(Number(number))
        }

        return false
      }
      /**
       * Find a node of the given type
       */

      exports.find = function(node, type) {
        return node.nodes.find(function(node) {
          return node.type === type
        })
      }
      /**
       * Find a node of the given type
       */

      exports.exceedsLimit = function(min, max) {
        const step =
          arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1
        const limit = arguments.length > 3 ? arguments[3] : undefined
        if (limit === false) {
          return false
        }
        if (!exports.isInteger(min) || !exports.isInteger(max)) {
          return false
        }
        return (Number(max) - Number(min)) / Number(step) >= limit
      }
      /**
       * Escape the given node with '\\' before node.value
       */

      exports.escapeNode = function(block) {
        const n =
          arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0
        const type = arguments.length > 2 ? arguments[2] : undefined
        const node = block.nodes[n]
        if (!node) {
          return
        }

        if (
          (type && node.type === type) ||
          node.type === 'open' ||
          node.type === 'close'
        ) {
          if (node.escaped !== true) {
            node.value = `\\${node.value}`
            node.escaped = true
          }
        }
      }
      /**
       * Returns true if the given brace node should be enclosed in literal braces
       */

      exports.encloseBrace = function(node) {
        if (node.type !== 'brace') {
          return false
        }

        if ((node.commas >> (0 + node.ranges)) >> 0 === 0) {
          node.invalid = true
          return true
        }

        return false
      }
      /**
       * Returns true if a brace node is invalid.
       */

      exports.isInvalidBrace = function(block) {
        if (block.type !== 'brace') {
          return false
        }
        if (block.invalid === true || block.dollar) {
          return true
        }

        if ((block.commas >> (0 + block.ranges)) >> 0 === 0) {
          block.invalid = true
          return true
        }

        if (block.open !== true || block.close !== true) {
          block.invalid = true
          return true
        }

        return false
      }
      /**
       * Returns true if a node is an open or close node
       */

      exports.isOpenOrClose = function(node) {
        if (node.type === 'open' || node.type === 'close') {
          return true
        }

        return node.open === true || node.close === true
      }
      /**
       * Reduce an array of text nodes.
       */

      exports.reduce = function(nodes) {
        return nodes.reduce(function(accumulator, node) {
          if (node.type === 'text') {
            accumulator.push(node.value)
          }
          if (node.type === 'range') {
            node.type = 'text'
          }
          return accumulator
        }, [])
      }
      /**
       * Flatten an array
       */

      exports.flatten = function() {
        const result = []

        const flat = function flat(array) {
          for (const ele of array) {
            Array.isArray(ele)
              ? flat(ele, result)
              : ele !== void 0 && result.push(ele)
          }

          return result
        }

        for (
          var _length = arguments.length,
            arguments_ = new Array(_length),
            _key = 0;
          _key < _length;
          _key++
        ) {
          arguments_[_key] = arguments[_key]
        }

        flat(arguments_)
        return result
      }

      /** */
    },
    /* 109 */
    /** */ function(module, exports, __webpack_require__) {
      const _require = __webpack_require__(15)
      const {separator} = _require

      exports.EV_ALL = 'all'
      exports.EV_READY = 'ready'
      exports.EV_ADD = 'add'
      exports.EV_CHANGE = 'change'
      exports.EV_ADD_DIR = 'addDir'
      exports.EV_UNLINK = 'unlink'
      exports.EV_UNLINK_DIR = 'unlinkDir'
      exports.EV_RAW = 'raw'
      exports.EV_ERROR = 'error'
      exports.STR_DATA = 'data'
      exports.STR_END = 'end'
      exports.STR_CLOSE = 'close'
      exports.FSEVENT_CREATED = 'created'
      exports.FSEVENT_MODIFIED = 'modified'
      exports.FSEVENT_DELETED = 'deleted'
      exports.FSEVENT_MOVED = 'moved'
      exports.FSEVENT_CLONED = 'cloned'
      exports.FSEVENT_UNKNOWN = 'unknown'
      exports.FSEVENT_TYPE_DIRECTORY = 'directory'
      exports.FSEVENT_TYPE_SYMLINK = 'symlink'
      exports.KEY_LISTENERS = 'listeners'
      exports.KEY_ERR = 'errHandlers'
      exports.KEY_RAW = 'rawEmitters'
      exports.HANDLER_KEYS = [
        exports.KEY_LISTENERS,
        exports.KEY_ERR,
        exports.KEY_RAW,
      ]
      exports.DOT_SLASH = `.${separator}`
      exports.BACK_SLASH_RE = /\\/g
      exports.DOUBLE_SLASH_RE = /\/\//
      exports.SLASH_OR_BACK_SLASH_RE = /[\/\\]/
      exports.DOT_RE = /\..*\.(sw[px])$|\~$|\.subl.*\.tmp/
      exports.REPLACER_RE = /^\.[\/\\]/
      exports.SLASH = '/'
      exports.BRACE_START = '{'
      exports.BANG = '!'
      exports.ONE_DOT = '.'
      exports.TWO_DOTS = '..'
      exports.ROOT_GLOBSTAR = '/**/*'
      exports.SLASH_GLOBSTAR = '/**'
      exports.GLOBSTAR = '**'
      exports.DIR_SUFFIX = 'Dir'
      exports.ANYMATCH_OPTS = {
        dot: true,
      }
      exports.STRING_TYPE = 'string'
      exports.FUNCTION_TYPE = 'function'
      exports.EMPTY_STR = ''

      exports.EMPTY_FN = function() {}

      exports.IDENTITY_FN = function(value) {
        return value
      }

      const _process = process
      const {platform} = _process
      exports.isWindows = platform === 'win32'
      exports.isMacos = platform === 'darwin'

      /** */
    },
    /* 110 */
    /** */ function(module, exports, __webpack_require__) {
      const DESCRIPTORS = __webpack_require__(18)

      const fails = __webpack_require__(9)

      const createElement = __webpack_require__(80) // Thank's IE8 for his funny defineProperty

      module.exports =
        !DESCRIPTORS &&
        !fails(function() {
          return (
            Object.defineProperty(createElement('div'), 'a', {
              get: function get() {
                return 7
              },
            }).a != 7
          )
        })

      /** */
    },
    /* 111 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          3
        )

        const shared = __webpack_require__(51)

        module.exports = shared('native-function-to-string', Function.toString)
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 112 */
    /** */ function(module, exports, __webpack_require__) {
      const wellKnownSymbol = __webpack_require__(7)

      const create = __webpack_require__(64)

      const hide = __webpack_require__(30)

      const UNSCOPABLES = wellKnownSymbol('unscopables')
      const ArrayPrototype = Array.prototype // Array.prototype[@@unscopables]
      // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

      if (ArrayPrototype[UNSCOPABLES] == undefined) {
        hide(ArrayPrototype, UNSCOPABLES, create(null))
      } // add a key to Array.prototype[@@unscopables]

      module.exports = function(key) {
        ArrayPrototype[UNSCOPABLES][key] = true
      }

      /** */
    },
    /* 113 */
    /** */ function(module, exports, __webpack_require__) {
      const has = __webpack_require__(20)

      const ownKeys = __webpack_require__(114)

      const getOwnPropertyDescriptorModule = __webpack_require__(49)

      const definePropertyModule = __webpack_require__(19)

      module.exports = function(target, source) {
        const keys = ownKeys(source)
        const defineProperty = definePropertyModule.f
        const getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f

        for (const key of keys) {
          if (!has(target, key)) {
            defineProperty(target, key, getOwnPropertyDescriptor(source, key))
          }
        }
      }

      /** */
    },
    /* 114 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          11
        )

        const getBuiltIn = __webpack_require__(52)

        const getOwnPropertyNamesModule = __webpack_require__(63)

        const getOwnPropertySymbolsModule = __webpack_require__(87)

        const anObject = __webpack_require__(17) // all object keys, includes non-enumerable and symbols

        module.exports =
          getBuiltIn('Reflect', 'ownKeys') ||
          function ownKeys(it) {
            const keys = getOwnPropertyNamesModule.f(anObject(it))
            const getOwnPropertySymbols = getOwnPropertySymbolsModule.f
            return getOwnPropertySymbols
              ? keys.concat(getOwnPropertySymbols(it))
              : keys
          }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 115 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          21
        )

        const has = __webpack_require__(20)

        const toIndexedObject = __webpack_require__(29)

        const {indexOf} = __webpack_require__(83)

        const hiddenKeys = __webpack_require__(53)

        module.exports = function(object, names) {
          const O = toIndexedObject(object)
          let i = 0
          const result = []
          let key

          for (key in O) {
            !has(hiddenKeys, key) && has(O, key) && result.push(key)
          } // Don't enum bug & hidden keys

          while (names.length > i) {
            if (has(O, (key = names[i++]))) {
              ~indexOf(result, key) || result.push(key)
            }
          }

          return result
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 116 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          1
        )

        const fails = __webpack_require__(9)

        module.exports =
          !!Object.getOwnPropertySymbols &&
          !fails(function() {
            // Chrome 38 Symbol has incorrect toString conversion
            // eslint-disable-next-line no-undef
            return !String(Symbol())
          })
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 117 */
    /** */ function(module, exports, __webpack_require__) {
      const getBuiltIn = __webpack_require__(52)

      module.exports = getBuiltIn('document', 'documentElement')

      /** */
    },
    /* 118 */
    /** */ function(module, exports, __webpack_require__) {
      exports.f = __webpack_require__(7)

      /** */
    },
    /* 119 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          1
        )

        const $ = __webpack_require__(6)

        const createIteratorConstructor = __webpack_require__(153)

        const getPrototypeOf = __webpack_require__(121)

        const setPrototypeOf = __webpack_require__(122)

        const setToStringTag = __webpack_require__(40)

        const hide = __webpack_require__(30)

        const redefine = __webpack_require__(25)

        const wellKnownSymbol = __webpack_require__(7)

        const IS_PURE = __webpack_require__(45)

        const Iterators = __webpack_require__(56)

        const IteratorsCore = __webpack_require__(120)

        const {IteratorPrototype} = IteratorsCore
        const {BUGGY_SAFARI_ITERATORS} = IteratorsCore
        const ITERATOR = wellKnownSymbol('iterator')
        const KEYS = 'keys'
        const VALUES = 'values'
        const ENTRIES = 'entries'

        const returnThis = function returnThis() {
          return this
        }

        module.exports = function(
          Iterable,
          NAME,
          IteratorConstructor,
          next,
          DEFAULT,
          IS_SET,
          FORCED
        ) {
          createIteratorConstructor(IteratorConstructor, NAME, next)

          const getIterationMethod = function getIterationMethod(KIND) {
            if (KIND === DEFAULT && defaultIterator) {
              return defaultIterator
            }
            if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) {
              return IterablePrototype[KIND]
            }

            switch (KIND) {
              case KEYS:
                return function keys() {
                  return new IteratorConstructor(this, KIND)
                }

              case VALUES:
                return function values() {
                  return new IteratorConstructor(this, KIND)
                }

              case ENTRIES:
                return function entries() {
                  return new IteratorConstructor(this, KIND)
                }
            }

            return function() {
              return new IteratorConstructor(this)
            }
          }

          const TO_STRING_TAG = `${NAME} Iterator`
          let INCORRECT_VALUES_NAME = false
          var IterablePrototype = Iterable.prototype
          const nativeIterator =
            IterablePrototype[ITERATOR] ||
            IterablePrototype['@@iterator'] ||
            (DEFAULT && IterablePrototype[DEFAULT])
          var defaultIterator =
            (!BUGGY_SAFARI_ITERATORS && nativeIterator) ||
            getIterationMethod(DEFAULT)
          const anyNativeIterator =
            NAME == 'Array'
              ? IterablePrototype.entries || nativeIterator
              : nativeIterator
          let CurrentIteratorPrototype
          let methods
          let KEY // fix native

          if (anyNativeIterator) {
            CurrentIteratorPrototype = getPrototypeOf(
              anyNativeIterator.call(new Iterable())
            )

            if (
              IteratorPrototype !== Object.prototype &&
              CurrentIteratorPrototype.next
            ) {
              if (
                !IS_PURE &&
                getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype
              ) {
                if (setPrototypeOf) {
                  setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype)
                } else if (
                  typeof CurrentIteratorPrototype[ITERATOR] !== 'function'
                ) {
                  hide(CurrentIteratorPrototype, ITERATOR, returnThis)
                }
              } // Set @@toStringTag to native iterators

              setToStringTag(
                CurrentIteratorPrototype,
                TO_STRING_TAG,
                true,
                true
              )
              if (IS_PURE) {
                Iterators[TO_STRING_TAG] = returnThis
              }
            }
          } // fix Array#{values, @@iterator}.name in V8 / FF

          if (
            DEFAULT == VALUES &&
            nativeIterator &&
            nativeIterator.name !== VALUES
          ) {
            INCORRECT_VALUES_NAME = true

            defaultIterator = function values() {
              return nativeIterator.call(this)
            }
          } // define iterator

          if (
            (!IS_PURE || FORCED) &&
            IterablePrototype[ITERATOR] !== defaultIterator
          ) {
            hide(IterablePrototype, ITERATOR, defaultIterator)
          }

          Iterators[NAME] = defaultIterator // export additional methods

          if (DEFAULT) {
            methods = {
              values: getIterationMethod(VALUES),
              keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
              entries: getIterationMethod(ENTRIES),
            }
            if (FORCED) {
              for (KEY in methods) {
                if (
                  BUGGY_SAFARI_ITERATORS ||
                  INCORRECT_VALUES_NAME ||
                  !(KEY in IterablePrototype)
                ) {
                  redefine(IterablePrototype, KEY, methods[KEY])
                }
              }
            } else {
              $(
                {
                  target: NAME,
                  proto: true,
                  forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME,
                },
                methods
              )
            }
          }

          return methods
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 120 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          1
        )

        const getPrototypeOf = __webpack_require__(121)

        const hide = __webpack_require__(30)

        const has = __webpack_require__(20)

        const wellKnownSymbol = __webpack_require__(7)

        const IS_PURE = __webpack_require__(45)

        const ITERATOR = wellKnownSymbol('iterator')
        let BUGGY_SAFARI_ITERATORS = false

        const returnThis = function returnThis() {
          return this
        } // `%IteratorPrototype%` object
        // https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object

        let IteratorPrototype
        let PrototypeOfArrayIteratorPrototype
        let arrayIterator

        if ([].keys) {
          arrayIterator = [].keys() // Safari 8 has buggy iterators w/o `next`

          if (!('next' in arrayIterator)) {
            BUGGY_SAFARI_ITERATORS = true
          } else {
            PrototypeOfArrayIteratorPrototype = getPrototypeOf(
              getPrototypeOf(arrayIterator)
            )
            if (PrototypeOfArrayIteratorPrototype !== Object.prototype) {
              IteratorPrototype = PrototypeOfArrayIteratorPrototype
            }
          }
        }

        if (IteratorPrototype == undefined) {
          IteratorPrototype = {}
        } // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

        if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
          hide(IteratorPrototype, ITERATOR, returnThis)
        }
        module.exports = {
          IteratorPrototype,
          BUGGY_SAFARI_ITERATORS,
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 121 */
    /** */ function(module, exports, __webpack_require__) {
      const has = __webpack_require__(20)

      const toObject = __webpack_require__(31)

      const sharedKey = __webpack_require__(65)

      const CORRECT_PROTOTYPE_GETTER = __webpack_require__(154)

      const IE_PROTO = sharedKey('IE_PROTO')
      const ObjectPrototype = Object.prototype // `Object.getPrototypeOf` method
      // https://tc39.github.io/ecma262/#sec-object.getprototypeof

      module.exports = CORRECT_PROTOTYPE_GETTER
        ? Object.getPrototypeOf
        : function(O) {
            O = toObject(O)
            if (has(O, IE_PROTO)) {
              return O[IE_PROTO]
            }

            if (
              typeof O.constructor === 'function' &&
              O instanceof O.constructor
            ) {
              return O.constructor.prototype
            }

            return O instanceof Object ? ObjectPrototype : null
          }

      /** */
    },
    /* 122 */
    /** */ function(module, exports, __webpack_require__) {
      const anObject = __webpack_require__(17)

      const aPossiblePrototype = __webpack_require__(155) // `Object.setPrototypeOf` method
      // https://tc39.github.io/ecma262/#sec-object.setprototypeof
      // Works with __proto__ only. Old v8 can't work with null proto objects.

      /* eslint-disable no-proto */

      module.exports =
        Object.setPrototypeOf ||
        ('__proto__' in {}
          ? (function() {
              let CORRECT_SETTER = false
              const test = {}
              let setter

              try {
                setter = Object.getOwnPropertyDescriptor(
                  Object.prototype,
                  '__proto__'
                ).set
                setter.call(test, [])
                CORRECT_SETTER = Array.isArray(test)
              } catch (error) {
                /* empty */
              }

              return function setPrototypeOf(O, proto) {
                anObject(O)
                aPossiblePrototype(proto)
                if (CORRECT_SETTER) {
                  setter.call(O, proto)
                } else {
                  O.__proto__ = proto
                }
                return O
              }
            })()
          : undefined)

      /** */
    },
    /* 123 */
    /** */ function(module, exports, __webpack_require__) {
      const wellKnownSymbol = __webpack_require__(7)

      const Iterators = __webpack_require__(56)

      const ITERATOR = wellKnownSymbol('iterator')
      const ArrayPrototype = Array.prototype // check on default Array iterator

      module.exports = function(it) {
        return (
          it !== undefined &&
          (Iterators.Array === it || ArrayPrototype[ITERATOR] === it)
        )
      }

      /** */
    },
    /* 124 */
    /** */ function(module, exports, __webpack_require__) {
      const classof = __webpack_require__(125)

      const Iterators = __webpack_require__(56)

      const wellKnownSymbol = __webpack_require__(7)

      const ITERATOR = wellKnownSymbol('iterator')

      module.exports = function(it) {
        if (it != undefined) {
          return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)]
        }
      }

      /** */
    },
    /* 125 */
    /** */ function(module, exports, __webpack_require__) {
      const classofRaw = __webpack_require__(33)

      const wellKnownSymbol = __webpack_require__(7)

      const TO_STRING_TAG = wellKnownSymbol('toStringTag') // ES3 wrong here

      const CORRECT_ARGUMENTS =
        classofRaw(
          (function() {
            return arguments
          })()
        ) == 'Arguments' // fallback for IE11 Script Access Denied error

      const tryGet = function tryGet(it, key) {
        try {
          return it[key]
        } catch (error) {
          /* empty */
        }
      } // getting tag from ES6+ `Object.prototype.toString`

      module.exports = function(it) {
        let O
        let tag
        let result
        return it === undefined
          ? 'Undefined'
          : it === null
          ? 'Null' // @@toStringTag case
          : typeof (tag = tryGet((O = new Object(it)), TO_STRING_TAG)) ===
            'string'
          ? tag // builtinTag case
          : CORRECT_ARGUMENTS
          ? classofRaw(O) // ES3 arguments fallback
          : (result = classofRaw(O)) == 'Object' &&
            typeof O.callee === 'function'
          ? 'Arguments'
          : result
      }

      /** */
    },
    /* 126 */
    /** */ function(module, exports, __webpack_require__) {
      const anObject = __webpack_require__(17) // call something on iterator step with safe closing on error

      module.exports = function(iterator, fn, value, ENTRIES) {
        try {
          return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value) // 7.4.6 IteratorClose(iterator, completion)
        } catch (error) {
          const returnMethod = iterator.return
          if (returnMethod !== undefined) {
            anObject(returnMethod.call(iterator))
          }
          throw error
        }
      }

      /** */
    },
    /* 127 */
    /** */ function(module, exports, __webpack_require__) {
      const isObject = __webpack_require__(12)

      const setPrototypeOf = __webpack_require__(122) // makes subclassing work correct for wrapped built-ins

      module.exports = function($this, dummy, Wrapper) {
        let NewTarget
        let NewTargetPrototype
        if (
          // it can work only with native `setPrototypeOf`
          setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
          typeof (NewTarget = dummy.constructor) === 'function' &&
          NewTarget !== Wrapper &&
          isObject((NewTargetPrototype = NewTarget.prototype)) &&
          NewTargetPrototype !== Wrapper.prototype
        ) {
          setPrototypeOf($this, NewTargetPrototype)
        }
        return $this
      }

      /** */
    },
    /* 128 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          91
        )
        /* harmony import */ const core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_2___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_2__
        )

        const global = __webpack_require__(8)

        const nativeFunctionToString = __webpack_require__(111)

        const {WeakMap} = global
        module.exports =
          typeof WeakMap === 'function' &&
          /native code/.test(nativeFunctionToString.call(WeakMap))
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 129 */
    /** */ function(module, exports, __webpack_require__) {
      const isRegExp = __webpack_require__(98)

      module.exports = function(it) {
        if (isRegExp(it)) {
          throw new TypeError("The method doesn't accept regular expressions")
        }

        return it
      }

      /** */
    },
    /* 130 */
    /** */ function(module, exports, __webpack_require__) {
      const wellKnownSymbol = __webpack_require__(7)

      const MATCH = wellKnownSymbol('match')

      module.exports = function(METHOD_NAME) {
        const regexp = /./

        try {
          '/./'[METHOD_NAME](regexp)
        } catch (e) {
          try {
            regexp[MATCH] = false
            return '/./'[METHOD_NAME](regexp)
          } catch (f) {
            /* empty */
          }
        }

        return false
      }

      /** */
    },
    /* 131 */
    /** */ function(module, exports) {
      // a string of all valid unicode whitespaces
      // eslint-disable-next-line max-len
      module.exports =
        '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'

      /** */
    },
    /* 132 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          11
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          28
        )
        /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          14
        )

        // Approach:
        //
        // 1. Get the minimatch set
        // 2. For each pattern in the set, PROCESS(pattern, false)
        // 3. Store matches per-set, then uniq them
        //
        // PROCESS(pattern, inGlobStar)
        // Get the first [n] items from pattern that are all strings
        // Join these together.  This is PREFIX.
        //   If there is no more remaining, then stat(PREFIX) and
        //   add to matches if it succeeds.  END.
        //
        // If inGlobStar and PREFIX is symlink and points to dir
        //   set ENTRIES = []
        // else readdir(PREFIX) as ENTRIES
        //   If fail, END
        //
        // with ENTRIES
        //   If pattern[n] is GLOBSTAR
        //     // handle the case where the globstar match is empty
        //     // by pruning it out, and testing the resulting pattern
        //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
        //     // handle other cases.
        //     for ENTRY in ENTRIES (not dotfiles)
        //       // attach globstar + tail onto the entry
        //       // Mark that this entry is a globstar match
        //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
        //
        //   else // not globstar
        //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
        //       Test ENTRY against pattern[n]
        //       If fails, continue
        //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
        //
        // Caveat:
        //   Cache all stats and readdirs results to minimize syscall.  Since all
        //   we ever care about is existence and directory-ness, we can just keep
        //   `true` for files, and [children,...] for directories, or `false` for
        //   things that don't exist.
        module.exports = glob

        const fs = __webpack_require__(35)

        const rp = __webpack_require__(133)

        const minimatch = __webpack_require__(101)

        const {Minimatch} = minimatch

        const inherits = __webpack_require__(169)

        const EE = __webpack_require__(134).EventEmitter

        const path = __webpack_require__(15)

        const assert = __webpack_require__(135)

        const isAbsolute = __webpack_require__(102)

        const globSync = __webpack_require__(171)

        const common = __webpack_require__(136)

        const {alphasort} = common
        const {alphasorti} = common
        const {setopts} = common
        const {ownProperty} = common

        const inflight = __webpack_require__(172)

        const util = __webpack_require__(36)

        const {childrenIgnored} = common
        const {isIgnored} = common

        const once = __webpack_require__(138)

        function glob(pattern, options, callback) {
          if (typeof options === 'function') {
            ;(callback = options), (options = {})
          }
          if (!options) {
            options = {}
          }

          if (options.sync) {
            if (callback) {
              throw new TypeError('callback provided to sync glob')
            }
            return globSync(pattern, options)
          }

          return new Glob(pattern, options, callback)
        }

        glob.sync = globSync
        const GlobSync = (glob.GlobSync = globSync.GlobSync) // old api surface

        glob.glob = glob

        function extend(origin, add) {
          if (add === null || typeof add !== 'object') {
            return origin
          }

          const keys = Object.keys(add)
          let i = keys.length

          while (i--) {
            origin[keys[i]] = add[keys[i]]
          }

          return origin
        }

        glob.hasMagic = function(pattern, options_) {
          const options = extend({}, options_)
          options.noprocess = true
          const g = new Glob(pattern, options)
          const {set} = g.minimatch
          if (!pattern) {
            return false
          }
          if (set.length > 1) {
            return true
          }

          for (let j = 0; j < set[0].length; j++) {
            if (typeof set[0][j] !== 'string') {
              return true
            }
          }

          return false
        }

        glob.Glob = Glob
        inherits(Glob, EE)

        function Glob(pattern, options, callback) {
          if (typeof options === 'function') {
            callback = options
            options = null
          }

          if (options && options.sync) {
            if (callback) {
              throw new TypeError('callback provided to sync glob')
            }
            return new GlobSync(pattern, options)
          }

          if (!(this instanceof Glob)) {
            return new Glob(pattern, options, callback)
          }
          setopts(this, pattern, options)
          this._didRealPath = false // process each pattern in the minimatch set

          const n = this.minimatch.set.length // The matches are stored as {<filename>: true,...} so that
          // duplicates are automagically pruned.
          // Later, we do an Object.keys() on these.
          // Keep them as a list so we can fill in when nonull is set.

          this.matches = new Array(n)

          if (typeof callback === 'function') {
            callback = once(callback)
            this.on('error', callback)
            this.on('end', function(matches) {
              callback(null, matches)
            })
          }

          const self = this
          this._processing = 0
          this._emitQueue = []
          this._processQueue = []
          this.paused = false
          if (this.noprocess) {
            return this
          }
          if (n === 0) {
            return done()
          }
          let sync = true

          for (let i = 0; i < n; i++) {
            this._process(this.minimatch.set[i], i, false, done)
          }

          sync = false

          function done() {
            --self._processing

            if (self._processing <= 0) {
              if (sync) {
                process.nextTick(function() {
                  self._finish()
                })
              } else {
                self._finish()
              }
            }
          }
        }

        Glob.prototype._finish = function() {
          assert(this instanceof Glob)
          if (this.aborted) {
            return
          }
          if (this.realpath && !this._didRealpath) {
            return this._realpath()
          }
          common.finish(this)
          this.emit('end', this.found)
        }

        Glob.prototype._realpath = function() {
          if (this._didRealpath) {
            return
          }
          this._didRealpath = true
          let n = this.matches.length
          if (n === 0) {
            return this._finish()
          }
          const self = this

          for (let i = 0; i < this.matches.length; i++) {
            this._realpathSet(i, next)
          }

          function next() {
            if (--n === 0) {
              self._finish()
            }
          }
        }

        Glob.prototype._realpathSet = function(index, callback) {
          const matchset = this.matches[index]
          if (!matchset) {
            return callback()
          }
          const found = Object.keys(matchset)
          const self = this
          let n = found.length
          if (n === 0) {
            return callback()
          }
          const set = (this.matches[index] = Object.create(null))
          found.forEach(function(p, i) {
            // If there's a problem with the stat, then it means that
            // one or more of the links in the realpath couldn't be
            // resolved.  just return the abs value in that case.
            p = self._makeAbs(p)
            rp.realpath(p, self.realpathCache, function(er, real) {
              if (!er) {
                set[real] = true
              } else if (er.syscall === 'stat') {
                set[p] = true
              } else {
                self.emit('error', er)
              } // srsly wtf right here

              if (--n === 0) {
                self.matches[index] = set
                callback()
              }
            })
          })
        }

        Glob.prototype._mark = function(p) {
          return common.mark(this, p)
        }

        Glob.prototype._makeAbs = function(f) {
          return common.makeAbs(this, f)
        }

        Glob.prototype.abort = function() {
          this.aborted = true
          this.emit('abort')
        }

        Glob.prototype.pause = function() {
          if (!this.paused) {
            this.paused = true
            this.emit('pause')
          }
        }

        Glob.prototype.resume = function() {
          if (this.paused) {
            this.emit('resume')
            this.paused = false

            if (this._emitQueue.length) {
              const eq = this._emitQueue.slice(0)

              this._emitQueue.length = 0

              for (var i = 0; i < eq.length; i++) {
                const e = eq[i]

                this._emitMatch(e[0], e[1])
              }
            }

            if (this._processQueue.length) {
              const pq = this._processQueue.slice(0)

              this._processQueue.length = 0

              for (var i = 0; i < pq.length; i++) {
                const p = pq[i]
                this._processing--

                this._process(p[0], p[1], p[2], p[3])
              }
            }
          }
        }

        Glob.prototype._process = function(
          pattern,
          index,
          inGlobStar,
          callback
        ) {
          assert(this instanceof Glob)
          assert(typeof callback === 'function')
          if (this.aborted) {
            return
          }
          this._processing++

          if (this.paused) {
            this._processQueue.push([pattern, index, inGlobStar, callback])

            return
          } // console.error('PROCESS %d', this._processing, pattern)
          // Get the first [n] parts of pattern that are all strings.

          let n = 0

          while (typeof pattern[n] === 'string') {
            n++
          } // now n is the index of the first one that is *not* a string.
          // see if there's anything else

          let prefix

          switch (n) {
            // if not, then this is rather simple
            case pattern.length:
              this._processSimple(pattern.join('/'), index, callback)

              return

            case 0:
              // pattern *starts* with some non-trivial item.
              // going to readdir(cwd), but not include the prefix in matches.
              prefix = null
              break

            default:
              // pattern has some string bits in the front.
              // whatever it starts with, whether that's 'absolute' like /foo/bar,
              // or 'relative' like '../baz'
              prefix = pattern.slice(0, n).join('/')
              break
          }

          const remain = pattern.slice(n) // get the list of entries.

          let read
          if (prefix === null) {
            read = '.'
          } else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
            if (!prefix || !isAbsolute(prefix)) {
              prefix = `/${prefix}`
            }
            read = prefix
          } else {
            read = prefix
          }

          const abs = this._makeAbs(read) // if ignored, skip _processing

          if (childrenIgnored(this, read)) {
            return callback()
          }
          const isGlobStar = remain[0] === minimatch.GLOBSTAR
          if (isGlobStar) {
            this._processGlobStar(
              prefix,
              read,
              abs,
              remain,
              index,
              inGlobStar,
              callback
            )
          } else {
            this._processReaddir(
              prefix,
              read,
              abs,
              remain,
              index,
              inGlobStar,
              callback
            )
          }
        }

        Glob.prototype._processReaddir = function(
          prefix,
          read,
          abs,
          remain,
          index,
          inGlobStar,
          callback
        ) {
          const self = this

          this._readdir(abs, inGlobStar, function(er, entries) {
            return self._processReaddir2(
              prefix,
              read,
              abs,
              remain,
              index,
              inGlobStar,
              entries,
              callback
            )
          })
        }

        Glob.prototype._processReaddir2 = function(
          prefix,
          read,
          abs,
          remain,
          index,
          inGlobStar,
          entries,
          callback
        ) {
          // if the abs isn't a dir, then nothing can match!
          if (!entries) {
            return callback()
          } // It will only match dot entries if it starts with a dot, or if
          // dot is set.  Stuff like @(.foo|.bar) isn't allowed.

          const pn = remain[0]
          const negate = !!this.minimatch.negate
          const rawGlob = pn._glob
          const dotOk = this.dot || rawGlob.charAt(0) === '.'
          const matchedEntries = []

          for (var i = 0; i < entries.length; i++) {
            var e = entries[i]

            if (e.charAt(0) !== '.' || dotOk) {
              var m

              if (negate && !prefix) {
                m = !e.match(pn)
              } else {
                m = e.match(pn)
              }

              if (m) {
                matchedEntries.push(e)
              }
            }
          } // console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

          const length_ = matchedEntries.length // If there are no matched entries, then nothing matches.

          if (length_ === 0) {
            return callback()
          } // if this is the last remaining pattern bit, then no need for
          // an additional stat *unless* the user has specified mark or
          // stat explicitly.  We know they exist, since readdir returned
          // them.

          if (remain.length === 1 && !this.mark && !this.stat) {
            if (!this.matches[index]) {
              this.matches[index] = Object.create(null)
            }

            for (var i = 0; i < length_; i++) {
              var e = matchedEntries[i]

              if (prefix) {
                if (prefix !== '/') {
                  e = `${prefix}/${e}`
                } else {
                  e = prefix + e
                }
              }

              if (e.charAt(0) === '/' && !this.nomount) {
                e = path.join(this.root, e)
              }

              this._emitMatch(index, e)
            } // This was the last one, and no stats were needed

            return callback()
          } // now test all matched entries as stand-ins for that part
          // of the pattern.

          remain.shift()

          for (var i = 0; i < length_; i++) {
            var e = matchedEntries[i]
            var newPattern

            if (prefix) {
              if (prefix !== '/') {
                e = `${prefix}/${e}`
              } else {
                e = prefix + e
              }
            }

            this._process([e].concat(remain), index, inGlobStar, callback)
          }

          callback()
        }

        Glob.prototype._emitMatch = function(index, e) {
          if (this.aborted) {
            return
          }
          if (isIgnored(this, e)) {
            return
          }

          if (this.paused) {
            this._emitQueue.push([index, e])

            return
          }

          const abs = isAbsolute(e) ? e : this._makeAbs(e)
          if (this.mark) {
            e = this._mark(e)
          }
          if (this.absolute) {
            e = abs
          }
          if (this.matches[index][e]) {
            return
          }

          if (this.nodir) {
            const c = this.cache[abs]
            if (c === 'DIR' || Array.isArray(c)) {
              return
            }
          }

          this.matches[index][e] = true
          const st = this.statCache[abs]
          if (st) {
            this.emit('stat', e, st)
          }
          this.emit('match', e)
        }

        Glob.prototype._readdirInGlobStar = function(abs, callback) {
          if (this.aborted) {
            return
          } // follow all symlinked directories forever
          // just proceed as if this is a non-globstar situation

          if (this.follow) {
            return this._readdir(abs, false, callback)
          }
          const lstatkey = `lstat\0${abs}`
          const self = this
          const lstatcb = inflight(lstatkey, lstatcb_)
          if (lstatcb) {
            fs.lstat(abs, lstatcb)
          }

          function lstatcb_(er, lstat) {
            if (er && er.code === 'ENOENT') {
              return callback()
            }
            const isSym = lstat && lstat.isSymbolicLink()
            self.symlinks[abs] = isSym // If it's not a symlink or a dir, then it's definitely a regular file.
            // don't bother doing a readdir in that case.

            if (!isSym && lstat && !lstat.isDirectory()) {
              self.cache[abs] = 'FILE'
              callback()
            } else {
              self._readdir(abs, false, callback)
            }
          }
        }

        Glob.prototype._readdir = function(abs, inGlobStar, callback) {
          if (this.aborted) {
            return
          }
          callback = inflight(`readdir\0${abs}\0${inGlobStar}`, callback)
          if (!callback) {
            return
          } // console.error('RD %j %j', +inGlobStar, abs)

          if (inGlobStar && !ownProperty(this.symlinks, abs)) {
            return this._readdirInGlobStar(abs, callback)
          }

          if (ownProperty(this.cache, abs)) {
            const c = this.cache[abs]
            if (!c || c === 'FILE') {
              return callback()
            }
            if (Array.isArray(c)) {
              return callback(null, c)
            }
          }

          const self = this
          fs.readdir(abs, readdirCallback(this, abs, callback))
        }

        function readdirCallback(self, abs, callback) {
          return function(er, entries) {
            if (er) {
              self._readdirError(abs, er, callback)
            } else {
              self._readdirEntries(abs, entries, callback)
            }
          }
        }

        Glob.prototype._readdirEntries = function(abs, entries, callback) {
          if (this.aborted) {
            return
          } // if we haven't asked to stat everything, then just
          // assume that everything in there exists, so we can avoid
          // having to stat it a second time.

          if (!this.mark && !this.stat) {
            for (const e of entries) {
              if (abs === '/') {
                e = abs + e
              } else {
                e = `${abs}/${e}`
              }
              this.cache[e] = true
            }
          }

          this.cache[abs] = entries
          return callback(null, entries)
        }

        Glob.prototype._readdirError = function(f, er, callback) {
          if (this.aborted) {
            return
          } // handle errors, and cache the information

          switch (er.code) {
            case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205

            case 'ENOTDIR':
              // totally normal. means it *does* exist.
              var abs = this._makeAbs(f)

              this.cache[abs] = 'FILE'

              if (abs === this.cwdAbs) {
                const error = new Error(`${er.code} invalid cwd ${this.cwd}`)
                error.path = this.cwd
                error.code = er.code
                this.emit('error', error)
                this.abort()
              }

              break

            case 'ENOENT': // not terribly unusual

            case 'ELOOP':
            case 'ENAMETOOLONG':
            case 'UNKNOWN':
              this.cache[this._makeAbs(f)] = false
              break

            default:
              // some unusual error.  Treat as failure.
              this.cache[this._makeAbs(f)] = false

              if (this.strict) {
                this.emit('error', er) // If the error is handled, then we abort
                // if not, we threw out of here

                this.abort()
              }

              if (!this.silent) {
                console.error('glob error', er)
              }
              break
          }

          return callback()
        }

        Glob.prototype._processGlobStar = function(
          prefix,
          read,
          abs,
          remain,
          index,
          inGlobStar,
          callback
        ) {
          const self = this

          this._readdir(abs, inGlobStar, function(er, entries) {
            self._processGlobStar2(
              prefix,
              read,
              abs,
              remain,
              index,
              inGlobStar,
              entries,
              callback
            )
          })
        }

        Glob.prototype._processGlobStar2 = function(
          prefix,
          read,
          abs,
          remain,
          index,
          inGlobStar,
          entries,
          callback
        ) {
          // console.error('pgs2', prefix, remain[0], entries)
          // no entries means not a dir, so it can never have matches
          // foo.txt/** doesn't match foo.txt
          if (!entries) {
            return callback()
          } // test without the globstar, and with every child both below
          // and replacing the globstar.

          const remainWithoutGlobStar = remain.slice(1)
          const gspref = prefix ? [prefix] : []
          const noGlobStar = gspref.concat(remainWithoutGlobStar) // the noGlobStar pattern exits the inGlobStar state

          this._process(noGlobStar, index, false, callback)

          const isSym = this.symlinks[abs]
          const length_ = entries.length // If it's a symlink, and we're in a globstar, then stop

          if (isSym && inGlobStar) {
            return callback()
          }

          for (let i = 0; i < length_; i++) {
            const e = entries[i]
            if (e.charAt(0) === '.' && !this.dot) {
              continue
            } // these two cases enter the inGlobStar state

            const instead = gspref.concat(entries[i], remainWithoutGlobStar)

            this._process(instead, index, true, callback)

            const below = gspref.concat(entries[i], remain)

            this._process(below, index, true, callback)
          }

          callback()
        }

        Glob.prototype._processSimple = function(prefix, index, callback) {
          // XXX review this.  Shouldn't it be doing the mounting etc
          // before doing stat?  kinda weird?
          const self = this

          this._stat(prefix, function(er, exists) {
            self._processSimple2(prefix, index, er, exists, callback)
          })
        }

        Glob.prototype._processSimple2 = function(
          prefix,
          index,
          er,
          exists,
          callback
        ) {
          // console.error('ps2', prefix, exists)
          if (!this.matches[index]) {
            this.matches[index] = Object.create(null)
          } // If it doesn't exist, then just mark the lack of results

          if (!exists) {
            return callback()
          }

          if (prefix && isAbsolute(prefix) && !this.nomount) {
            const trail = /[\/\\]$/.test(prefix)

            if (prefix.charAt(0) === '/') {
              prefix = path.join(this.root, prefix)
            } else {
              prefix = path.resolve(this.root, prefix)
              if (trail) {
                prefix += '/'
              }
            }
          }

          if (process.platform === 'win32') {
            prefix = prefix.replace(/\\/g, '/')
          } // Mark this as a match

          this._emitMatch(index, prefix)

          callback()
        } // Returns either 'DIR', 'FILE', or false

        Glob.prototype._stat = function(f, callback) {
          const abs = this._makeAbs(f)

          const needDir = f.slice(-1) === '/'
          if (f.length > this.maxLength) {
            return callback()
          }

          if (!this.stat && ownProperty(this.cache, abs)) {
            let c = this.cache[abs]
            if (Array.isArray(c)) {
              c = 'DIR'
            } // It exists, but maybe not how we need it

            if (!needDir || c === 'DIR') {
              return callback(null, c)
            }
            if (needDir && c === 'FILE') {
              return callback()
            } // otherwise we have to stat, because maybe c=true
            // if we know it exists, but not what it is.
          }

          let exists
          const stat = this.statCache[abs]

          if (stat !== undefined) {
            if (stat === false) {
              return callback(null, stat)
            }

            const type = stat.isDirectory() ? 'DIR' : 'FILE'
            if (needDir && type === 'FILE') {
              return callback()
            }
            return callback(null, type, stat)
          }

          const self = this
          const statcb = inflight(`stat\0${abs}`, lstatcb_)
          if (statcb) {
            fs.lstat(abs, statcb)
          }

          function lstatcb_(er, lstat) {
            if (lstat && lstat.isSymbolicLink()) {
              // If it's a symlink, then treat it as the target, unless
              // the target does not exist, then treat it as a file.
              return fs.stat(abs, function(er, stat) {
                if (er) {
                  self._stat2(f, abs, null, lstat, callback)
                } else {
                  self._stat2(f, abs, er, stat, callback)
                }
              })
            }
            self._stat2(f, abs, er, lstat, callback)
          }
        }

        Glob.prototype._stat2 = function(f, abs, er, stat, callback) {
          if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
            this.statCache[abs] = false
            return callback()
          }

          const needDir = f.slice(-1) === '/'
          this.statCache[abs] = stat
          if (abs.slice(-1) === '/' && stat && !stat.isDirectory()) {
            return callback(null, false, stat)
          }
          let c = true
          if (stat) {
            c = stat.isDirectory() ? 'DIR' : 'FILE'
          }
          this.cache[abs] = this.cache[abs] || c
          if (needDir && c === 'FILE') {
            return callback()
          }
          return callback(null, c, stat)
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 133 */
    /** */ function(module, exports, __webpack_require__) {
      module.exports = realpath
      realpath.realpath = realpath
      realpath.sync = realpathSync
      realpath.realpathSync = realpathSync
      realpath.monkeypatch = monkeypatch
      realpath.unmonkeypatch = unmonkeypatch

      const fs = __webpack_require__(35)

      const origRealpath = fs.realpath
      const origRealpathSync = fs.realpathSync
      const {version} = process
      const ok = /^v[0-5]\./.test(version)

      const old = __webpack_require__(165)

      function newError(er) {
        return (
          er &&
          er.syscall === 'realpath' &&
          (er.code === 'ELOOP' ||
            er.code === 'ENOMEM' ||
            er.code === 'ENAMETOOLONG')
        )
      }

      function realpath(p, cache, callback) {
        if (ok) {
          return origRealpath(p, cache, callback)
        }

        if (typeof cache === 'function') {
          callback = cache
          cache = null
        }

        origRealpath(p, cache, function(er, result) {
          if (newError(er)) {
            old.realpath(p, cache, callback)
          } else {
            callback(er, result)
          }
        })
      }

      function realpathSync(p, cache) {
        if (ok) {
          return origRealpathSync(p, cache)
        }

        try {
          return origRealpathSync(p, cache)
        } catch (error) {
          if (newError(error)) {
            return old.realpathSync(p, cache)
          }
          throw error
        }
      }

      function monkeypatch() {
        fs.realpath = realpath
        fs.realpathSync = realpathSync
      }

      function unmonkeypatch() {
        fs.realpath = origRealpath
        fs.realpathSync = origRealpathSync
      }

      /** */
    },
    /* 134 */
    /** */ function(module, exports) {
      module.exports = require('events')

      /** */
    },
    /* 135 */
    /** */ function(module, exports) {
      module.exports = require('assert')

      /** */
    },
    /* 136 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        13
      )
      /* harmony import */ const core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        21
      )
      /* harmony import */ const core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        23
      )
      /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        2
      )
      /* harmony import */ const core_js_modules_es_array_sort__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
        42
      )
      /* harmony import */ const core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
        28
      )
      /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
        14
      )

      exports.alphasort = alphasort
      exports.alphasorti = alphasorti
      exports.setopts = setopts
      exports.ownProp = ownProperty
      exports.makeAbs = makeAbs
      exports.finish = finish
      exports.mark = mark
      exports.isIgnored = isIgnored
      exports.childrenIgnored = childrenIgnored

      function ownProperty(object, field) {
        return Object.prototype.hasOwnProperty.call(object, field)
      }

      const path = __webpack_require__(15)

      const minimatch = __webpack_require__(101)

      const isAbsolute = __webpack_require__(102)

      const {Minimatch} = minimatch

      function alphasorti(a, b) {
        return a.toLowerCase().localeCompare(b.toLowerCase())
      }

      function alphasort(a, b) {
        return a.localeCompare(b)
      }

      function setupIgnores(self, options) {
        self.ignore = options.ignore || []
        if (!Array.isArray(self.ignore)) {
          self.ignore = [self.ignore]
        }

        if (self.ignore.length) {
          self.ignore = self.ignore.map(ignoreMap)
        }
      } // ignore patterns are always in dot:true mode.

      function ignoreMap(pattern) {
        let gmatcher = null

        if (pattern.slice(-3) === '/**') {
          const gpattern = pattern.replace(/(\/\*\*)+$/, '')
          gmatcher = new Minimatch(gpattern, {
            dot: true,
          })
        }

        return {
          matcher: new Minimatch(pattern, {
            dot: true,
          }),
          gmatcher,
        }
      }

      function setopts(self, pattern, options) {
        if (!options) {
          options = {}
        } // base-matching: just use globstar for that.

        if (options.matchBase && !pattern.includes('/')) {
          if (options.noglobstar) {
            throw new Error('base matching requires globstar')
          }

          pattern = `**/${pattern}`
        }

        self.silent = !!options.silent
        self.pattern = pattern
        self.strict = options.strict !== false
        self.realpath = !!options.realpath
        self.realpathCache = options.realpathCache || Object.create(null)
        self.follow = !!options.follow
        self.dot = !!options.dot
        self.mark = !!options.mark
        self.nodir = !!options.nodir
        if (self.nodir) {
          self.mark = true
        }
        self.sync = !!options.sync
        self.nounique = !!options.nounique
        self.nonull = !!options.nonull
        self.nosort = !!options.nosort
        self.nocase = !!options.nocase
        self.stat = !!options.stat
        self.noprocess = !!options.noprocess
        self.absolute = !!options.absolute
        self.maxLength = options.maxLength || Infinity
        self.cache = options.cache || Object.create(null)
        self.statCache = options.statCache || Object.create(null)
        self.symlinks = options.symlinks || Object.create(null)
        setupIgnores(self, options)
        self.changedCwd = false
        const cwd = process.cwd()
        if (!ownProperty(options, 'cwd')) {
          self.cwd = cwd
        } else {
          self.cwd = path.resolve(options.cwd)
          self.changedCwd = self.cwd !== cwd
        }
        self.root = options.root || path.resolve(self.cwd, '/')
        self.root = path.resolve(self.root)
        if (process.platform === 'win32') {
          self.root = self.root.replace(/\\/g, '/')
        } // TODO: is an absolute `cwd` supposed to be resolved against `root`?
        // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')

        self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
        if (process.platform === 'win32') {
          self.cwdAbs = self.cwdAbs.replace(/\\/g, '/')
        }
        self.nomount = !!options.nomount // disable comments and negation in Minimatch.
        // Note that they are not supported in Glob itself anyway.

        options.nonegate = true
        options.nocomment = true
        self.minimatch = new Minimatch(pattern, options)
        self.options = self.minimatch.options
      }

      function finish(self) {
        const nou = self.nounique
        let all = nou ? [] : Object.create(null)

        for (var i = 0, l = self.matches.length; i < l; i++) {
          const matches = self.matches[i]

          if (!matches || Object.keys(matches).length === 0) {
            if (self.nonull) {
              // do like the shell, and spit out the literal glob
              const literal = self.minimatch.globSet[i]
              if (nou) {
                all.push(literal)
              } else {
                all[literal] = true
              }
            }
          } else {
            // had matches
            const m = Object.keys(matches)
            if (nou) {
              all.push.apply(all, m)
            } else {
              m.forEach(function(m) {
                all[m] = true
              })
            }
          }
        }

        if (!nou) {
          all = Object.keys(all)
        }
        if (!self.nosort) {
          all = all.sort(self.nocase ? alphasorti : alphasort)
        } // at *some* point we statted all of these

        if (self.mark) {
          for (var i = 0; i < all.length; i++) {
            all[i] = self._mark(all[i])
          }

          if (self.nodir) {
            all = all.filter(function(e) {
              let notDir = !/\/$/.test(e)
              const c = self.cache[e] || self.cache[makeAbs(self, e)]
              if (notDir && c) {
                notDir = c !== 'DIR' && !Array.isArray(c)
              }
              return notDir
            })
          }
        }

        if (self.ignore.length) {
          all = all.filter(function(m) {
            return !isIgnored(self, m)
          })
        }
        self.found = all
      }

      function mark(self, p) {
        const abs = makeAbs(self, p)
        const c = self.cache[abs]
        let m = p

        if (c) {
          const isDir = c === 'DIR' || Array.isArray(c)
          const slash = p.slice(-1) === '/'
          if (isDir && !slash) {
            m += '/'
          } else if (!isDir && slash) {
            m = m.slice(0, -1)
          }

          if (m !== p) {
            const mabs = makeAbs(self, m)
            self.statCache[mabs] = self.statCache[abs]
            self.cache[mabs] = self.cache[abs]
          }
        }

        return m
      } // lotta situps...

      function makeAbs(self, f) {
        let abs = f

        if (f.charAt(0) === '/') {
          abs = path.join(self.root, f)
        } else if (isAbsolute(f) || f === '') {
          abs = f
        } else if (self.changedCwd) {
          abs = path.resolve(self.cwd, f)
        } else {
          abs = path.resolve(f)
        }

        if (process.platform === 'win32') {
          abs = abs.replace(/\\/g, '/')
        }
        return abs
      } // Return true, if pattern ends with globstar '**', for the accompanying parent directory.
      // Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents

      function isIgnored(self, path) {
        if (!self.ignore.length) {
          return false
        }
        return self.ignore.some(function(item) {
          return (
            item.matcher.match(path) ||
            !!(item.gmatcher && item.gmatcher.match(path))
          )
        })
      }

      function childrenIgnored(self, path) {
        if (!self.ignore.length) {
          return false
        }
        return self.ignore.some(function(item) {
          return !!(item.gmatcher && item.gmatcher.match(path))
        })
      }

      /** */
    },
    /* 137 */
    /** */ function(module, exports) {
      // Returns a wrapper function that returns a wrapped callback
      // The wrapper function should do some stuff, and return a
      // presumably different callback function.
      // This makes sure that own properties are retained, so that
      // decorations and such are not lost along the way.
      module.exports = wrappy

      function wrappy(fn, callback) {
        if (fn && callback) {
          return wrappy(fn)(callback)
        }
        if (typeof fn !== 'function') {
          throw new TypeError('need wrapper function')
        }
        Object.keys(fn).forEach(function(k) {
          wrapper[k] = fn[k]
        })
        return wrapper

        function wrapper() {
          const arguments_ = new Array(arguments.length)

          for (let i = 0; i < arguments_.length; i++) {
            arguments_[i] = arguments[i]
          }

          const returnValue = fn.apply(this, arguments_)
          const callback_ = arguments_[arguments_.length - 1]

          if (typeof returnValue === 'function' && returnValue !== callback_) {
            Object.keys(callback_).forEach(function(k) {
              returnValue[k] = callback_[k]
            })
          }

          return returnValue
        }
      }

      /** */
    },
    /* 138 */
    /** */ function(module, exports, __webpack_require__) {
      const wrappy = __webpack_require__(137)

      module.exports = wrappy(once)
      module.exports.strict = wrappy(onceStrict)
      once.proto = once(function() {
        Object.defineProperty(Function.prototype, 'once', {
          value: function value() {
            return once(this)
          },
          configurable: true,
        })
        Object.defineProperty(Function.prototype, 'onceStrict', {
          value: function value() {
            return onceStrict(this)
          },
          configurable: true,
        })
      })

      function once(fn) {
        const f = function f() {
          if (f.called) {
            return f.value
          }
          f.called = true
          return (f.value = Reflect.apply(fn, this, arguments))
        }

        f.called = false
        return f
      }

      function onceStrict(fn) {
        const f = function f() {
          if (f.called) {
            throw new Error(f.onceError)
          }
          f.called = true
          return (f.value = Reflect.apply(fn, this, arguments))
        }

        const name = fn.name || 'Function wrapped with `once`'
        f.onceError = `${name} shouldn't be called more than once`
        f.called = false
        return f
      }

      /** */
    },
    /* 139 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        5
      )
      /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        10
      )
      /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        11
      )
      /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        13
      )
      /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
        4
      )
      /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4___default = /* #__PURE__ */ __webpack_require__.n(
        core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4__
      )
      /* harmony import */ const core_js_modules_es_array_last_index_of__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
        48
      )
      /* harmony import */ const core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
        23
      )
      /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
        2
      )
      /* harmony import */ const core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
        32
      )
      /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
        1
      )
      /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
        16
      )
      /* harmony import */ const core_js_modules_es_regexp_flags__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
        59
      )
      /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
        3
      )
      /* harmony import */ const core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
        91
      )
      /* harmony import */ const core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_13___default = /* #__PURE__ */ __webpack_require__.n(
        core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_13__
      )

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function')
        }
      }

      function _defineProperties(target, properties) {
        for (const descriptor of properties) {
          descriptor.enumerable = descriptor.enumerable || false
          descriptor.configurable = true
          if ('value' in descriptor) {
            descriptor.writable = true
          }
          Object.defineProperty(target, descriptor.key, descriptor)
        }
      }

      function _createClass(Constructor, protoProperties, staticProperties) {
        if (protoProperties) {
          _defineProperties(Constructor.prototype, protoProperties)
        }
        if (staticProperties) {
          _defineProperties(Constructor, staticProperties)
        }
        return Constructor
      }

      const __importStar =
        (undefined && undefined.__importStar) ||
        function(module_) {
          if (module_ && module_.__esModule) {
            return module_
          }
          const result = {}
          if (module_ != null) {
            for (const k in module_) {
              if (Object.hasOwnProperty.call(module_, k)) {
                result[k] = module_[k]
              }
            }
          }
          result.default = module_
          return result
        }

      Object.defineProperty(exports, '__esModule', {
        value: true,
      }) // There's lots of funny stuff due to the typing of ts.Node

      /* eslint-disable @typescript-eslint/no-explicit-any */

      const ts = __importStar(__webpack_require__(47)) // leave this as * as ts so people using util package don't need syntheticDefaultImports

      const node_utils_1 = __webpack_require__(73)

      const ts_estree_1 = __webpack_require__(104)

      const {SyntaxKind} = ts
      /**
       * Extends and formats a given error object
       * @param error the error object
       * @returns converted error object
       */

      function convertError(error) {
        return node_utils_1.createError(
          error.file,
          error.start,
          error.message || error.messageText
        )
      }

      exports.convertError = convertError

      const Converter =
        /* #__PURE__ */
        (function() {
          /**
           * Converts a TypeScript node into an ESTree node
           * @param ast the full TypeScript AST
           * @param options additional options for the conversion
           * @returns the converted ESTreeNode
           */
          function Converter(ast, options) {
            _classCallCheck(this, Converter)

            this.esTreeNodeToTSNodeMap = new WeakMap()
            this.tsNodeToESTreeNodeMap = new WeakMap()
            this.allowPattern = false
            this.inTypeMode = false
            this.ast = ast
            this.options = {...options}
          }

          _createClass(Converter, [
            {
              key: 'getASTMaps',
              value: function getASTMaps() {
                return {
                  esTreeNodeToTSNodeMap: this.esTreeNodeToTSNodeMap,
                  tsNodeToESTreeNodeMap: this.tsNodeToESTreeNodeMap,
                }
              },
            },
            {
              key: 'convertProgram',
              value: function convertProgram() {
                return this.converter(this.ast)
              },
              /**
               * Converts a TypeScript node into an ESTree node.
               * @param node the child ts.Node
               * @param parent parentNode
               * @param inTypeMode flag to determine if we are in typeMode
               * @param allowPattern flag to determine if patterns are allowed
               * @returns the converted ESTree node
               */
            },
            {
              key: 'converter',
              value: function converter(
                node,
                parent,
                inTypeMode,
                allowPattern
              ) {
                /**
                 * Exit early for null and undefined
                 */
                if (!node) {
                  return null
                }

                const typeMode = this.inTypeMode
                const pattern = this.allowPattern

                if (inTypeMode !== undefined) {
                  this.inTypeMode = inTypeMode
                }

                if (allowPattern !== undefined) {
                  this.allowPattern = allowPattern
                }

                const result = this.convertNode(node, parent || node.parent)
                this.registerTSNodeInNodeMap(node, result)
                this.inTypeMode = typeMode
                this.allowPattern = pattern
                return result
              },
              /**
               * Fixes the exports of the given ts.Node
               * @param node   the ts.Node
               * @param result result
               * @returns the ESTreeNode with fixed exports
               */
            },
            {
              key: 'fixExports',
              value: function fixExports(node, result) {
                // check for exports
                if (
                  node.modifiers &&
                  node.modifiers[0].kind === SyntaxKind.ExportKeyword
                ) {
                  /**
                   * Make sure that original node is registered instead of export
                   */
                  this.registerTSNodeInNodeMap(node, result)
                  const exportKeyword = node.modifiers[0]
                  const nextModifier = node.modifiers[1]
                  const declarationIsDefault =
                    nextModifier &&
                    nextModifier.kind === SyntaxKind.DefaultKeyword
                  const varToken = declarationIsDefault
                    ? node_utils_1.findNextToken(
                        nextModifier,
                        this.ast,
                        this.ast
                      )
                    : node_utils_1.findNextToken(
                        exportKeyword,
                        this.ast,
                        this.ast
                      )
                  result.range[0] = varToken.getStart(this.ast)
                  result.loc = node_utils_1.getLocFor(
                    result.range[0],
                    result.range[1],
                    this.ast
                  )

                  if (declarationIsDefault) {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,
                      declaration: result,
                      range: [
                        exportKeyword.getStart(this.ast),
                        result.range[1],
                      ],
                    })
                  }
                  return this.createNode(node, {
                    type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,
                    declaration: result,
                    specifiers: [],
                    source: null,
                    range: [exportKeyword.getStart(this.ast), result.range[1]],
                  })
                }

                return result
              },
              /**
               * Register specific TypeScript node into map with first ESTree node provided
               */
            },
            {
              key: 'registerTSNodeInNodeMap',
              value: function registerTSNodeInNodeMap(node, result) {
                if (result && this.options.shouldPreserveNodeMaps) {
                  if (!this.tsNodeToESTreeNodeMap.has(node)) {
                    this.tsNodeToESTreeNodeMap.set(node, result)
                  }
                }
              },
              /**
               * Converts a TypeScript node into an ESTree node.
               * @param child the child ts.Node
               * @param parent parentNode
               * @returns the converted ESTree node
               */
            },
            {
              key: 'convertPattern',
              value: function convertPattern(child, parent) {
                return this.converter(child, parent, this.inTypeMode, true)
              },
              /**
               * Converts a TypeScript node into an ESTree node.
               * @param child the child ts.Node
               * @param parent parentNode
               * @returns the converted ESTree node
               */
            },
            {
              key: 'convertChild',
              value: function convertChild(child, parent) {
                return this.converter(child, parent, this.inTypeMode, false)
              },
              /**
               * Converts a TypeScript node into an ESTree node.
               * @param child the child ts.Node
               * @param parent parentNode
               * @returns the converted ESTree node
               */
            },
            {
              key: 'convertType',
              value: function convertType(child, parent) {
                return this.converter(child, parent, true, false)
              },
            },
            {
              key: 'createNode',
              value: function createNode(node, data) {
                const result = data

                if (!result.range) {
                  result.range = node_utils_1.getRange(node, this.ast)
                }

                if (!result.loc) {
                  result.loc = node_utils_1.getLocFor(
                    result.range[0],
                    result.range[1],
                    this.ast
                  )
                }

                if (result && this.options.shouldPreserveNodeMaps) {
                  this.esTreeNodeToTSNodeMap.set(result, node)
                }

                return result
              },
              /**
               * Converts a child into a type annotation. This creates an intermediary
               * TypeAnnotation node to match what Flow does.
               * @param child The TypeScript AST node to convert.
               * @param parent parentNode
               * @returns The type annotation node.
               */
            },
            {
              key: 'convertTypeAnnotation',
              value: function convertTypeAnnotation(child, parent) {
                // in FunctionType and ConstructorType typeAnnotation has 2 characters `=>` and in other places is just colon
                const offset =
                  parent.kind === SyntaxKind.FunctionType ||
                  parent.kind === SyntaxKind.ConstructorType
                    ? 2
                    : 1
                const annotationStartCol = child.getFullStart() - offset
                const loc = node_utils_1.getLocFor(
                  annotationStartCol,
                  child.end,
                  this.ast
                )
                return {
                  type: ts_estree_1.AST_NODE_TYPES.TSTypeAnnotation,
                  loc,
                  range: [annotationStartCol, child.end],
                  typeAnnotation: this.convertType(child),
                }
              },
              /**
               * Coverts body Nodes and add directive field to StringLiterals
               * @param nodes of ts.Node
               * @param parent parentNode
               * @returns Array of body statements
               */
            },
            {
              key: 'convertBodyExpressions',
              value: function convertBodyExpressions(nodes, parent) {
                const _this = this

                let allowDirectives = node_utils_1.canContainDirective(parent)
                return nodes
                  .map(function(statement) {
                    const child = _this.convertChild(statement)

                    if (allowDirectives) {
                      if (
                        child &&
                        child.expression &&
                        ts.isExpressionStatement(statement) &&
                        ts.isStringLiteral(statement.expression)
                      ) {
                        const {raw} = child.expression
                        child.directive = raw.slice(1, -1)
                        return child // child can be null but it's filtered below
                      }
                      allowDirectives = false
                    }

                    return child // child can be null but it's filtered below
                  }) // filter out unknown nodes for now
                  .filter(function(statement) {
                    return statement
                  })
              },
              /**
               * Converts a ts.Node's typeArguments to TSTypeParameterInstantiation node
               * @param typeArguments ts.Node typeArguments
               * @returns TypeParameterInstantiation node
               */
            },
            {
              key: 'convertTypeArgumentsToTypeParameters',
              value: function convertTypeArgumentsToTypeParameters(
                typeArguments
              ) {
                const _this2 = this

                const greaterThanToken = node_utils_1.findNextToken(
                  typeArguments,
                  this.ast,
                  this.ast
                )
                return {
                  type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterInstantiation,
                  range: [typeArguments.pos - 1, greaterThanToken.end],
                  loc: node_utils_1.getLocFor(
                    typeArguments.pos - 1,
                    greaterThanToken.end,
                    this.ast
                  ),
                  params: typeArguments.map(function(typeArgument) {
                    return _this2.convertType(typeArgument)
                  }),
                }
              },
              /**
               * Converts a ts.Node's typeParameters to TSTypeParameterDeclaration node
               * @param typeParameters ts.Node typeParameters
               * @returns TypeParameterDeclaration node
               */
            },
            {
              key: 'convertTSTypeParametersToTypeParametersDeclaration',
              value: function convertTSTypeParametersToTypeParametersDeclaration(
                typeParameters
              ) {
                const _this3 = this

                const greaterThanToken = node_utils_1.findNextToken(
                  typeParameters,
                  this.ast,
                  this.ast
                )
                return {
                  type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterDeclaration,
                  range: [typeParameters.pos - 1, greaterThanToken.end],
                  loc: node_utils_1.getLocFor(
                    typeParameters.pos - 1,
                    greaterThanToken.end,
                    this.ast
                  ),
                  params: typeParameters.map(function(typeParameter) {
                    return _this3.convertType(typeParameter)
                  }),
                }
              },
              /**
               * Converts an array of ts.Node parameters into an array of ESTreeNode params
               * @param parameters An array of ts.Node params to be converted
               * @returns an array of converted ESTreeNode params
               */
            },
            {
              key: 'convertParameters',
              value: function convertParameters(parameters) {
                const _this4 = this

                if (!parameters || !parameters.length) {
                  return []
                }

                return parameters.map(function(parameter) {
                  const convertedParameter = _this4.convertChild(parameter)

                  if (parameter.decorators && parameter.decorators.length) {
                    convertedParameter.decorators = parameter.decorators.map(
                      function(element) {
                        return _this4.convertChild(element)
                      }
                    )
                  }

                  return convertedParameter
                })
              },
              /**
               * For nodes that are copied directly from the TypeScript AST into
               * ESTree mostly as-is. The only difference is the addition of a type
               * property instead of a kind property. Recursively copies all children.
               */
            },
            {
              key: 'deeplyCopy',
              value: function deeplyCopy(node) {
                const _this5 = this

                const customType = `TS${SyntaxKind[node.kind]}`
                /**
                 * If the "errorOnUnknownASTType" option is set to true, throw an error,
                 * otherwise fallback to just including the unknown type as-is.
                 */

                if (
                  this.options.errorOnUnknownASTType &&
                  !ts_estree_1.AST_NODE_TYPES[customType]
                ) {
                  throw new Error(`Unknown AST_NODE_TYPE: "${customType}"`)
                }

                const result = this.createNode(node, {
                  type: customType,
                })
                Object.keys(node)
                  .filter(function(key) {
                    return !/^(?:_children|kind|parent|pos|end|flags|modifierFlagsCache|jsDoc)$/.test(
                      key
                    )
                  })
                  .forEach(function(key) {
                    if (key === 'type') {
                      result.typeAnnotation = node.type
                        ? _this5.convertTypeAnnotation(node.type, node)
                        : null
                    } else if (key === 'typeArguments') {
                      result.typeParameters = node.typeArguments
                        ? _this5.convertTypeArgumentsToTypeParameters(
                            node.typeArguments
                          )
                        : null
                    } else if (key === 'typeParameters') {
                      result.typeParameters = node.typeParameters
                        ? _this5.convertTSTypeParametersToTypeParametersDeclaration(
                            node.typeParameters
                          )
                        : null
                    } else if (key === 'decorators') {
                      if (node.decorators && node.decorators.length) {
                        result.decorators = node.decorators.map(function(
                          element
                        ) {
                          return _this5.convertChild(element)
                        })
                      }
                    } else {
                      if (Array.isArray(node[key])) {
                        result[key] = node[key].map(function(element) {
                          return _this5.convertChild(element)
                        })
                      } else if (
                        node[key] &&
                        typeof node[key] === 'object' &&
                        node[key].kind
                      ) {
                        // need to check node[key].kind to ensure we don't try to convert a symbol
                        result[key] = _this5.convertChild(node[key])
                      } else {
                        result[key] = node[key]
                      }
                    }
                  })
                return result
              },
              /**
               * Converts a TypeScript JSX node.tagName into an ESTree node.name
               * @param node the tagName object from a JSX ts.Node
               * @param parent
               * @returns the converted ESTree name object
               */
            },
            {
              key: 'convertJSXTagName',
              value: function convertJSXTagName(node, parent) {
                let result

                switch (node.kind) {
                  case SyntaxKind.PropertyAccessExpression:
                    result = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.JSXMemberExpression,
                      object: this.convertJSXTagName(node.expression, parent),
                      property: this.convertJSXTagName(node.name, parent),
                    })
                    break

                  case SyntaxKind.ThisKeyword:
                    result = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,
                      name: 'this',
                    })
                    break

                  case SyntaxKind.Identifier:
                  default:
                    result = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,
                      name: node.text,
                    })
                    break
                }

                this.registerTSNodeInNodeMap(node, result)
                return result
              },
              /**
               * Applies the given TS modifiers to the given result object.
               * @param result
               * @param modifiers original ts.Nodes from the node.modifiers array
               * @returns the current result object will be mutated
               * @deprecated This method adds not standardized `modifiers` property in nodes
               */
            },
            {
              key: 'applyModifiersToResult',
              value: function applyModifiersToResult(result, modifiers) {
                const _this6 = this

                if (!modifiers || !modifiers.length) {
                  return
                }
                /**
                 * Some modifiers are explicitly handled by applying them as
                 * boolean values on the result node. As well as adding them
                 * to the result, we remove them from the array, so that they
                 * are not handled twice.
                 */

                const handledModifierIndices = {}

                for (const [i, modifier] of modifiers.entries()) {
                  switch (modifier.kind) {
                    /**
                     * Ignore ExportKeyword and DefaultKeyword, they are handled
                     * via the fixExports utility function
                     */
                    case SyntaxKind.ExportKeyword:
                    case SyntaxKind.DefaultKeyword:
                      handledModifierIndices[i] = true
                      break

                    case SyntaxKind.ConstKeyword:
                      result.const = true
                      handledModifierIndices[i] = true
                      break

                    case SyntaxKind.DeclareKeyword:
                      result.declare = true
                      handledModifierIndices[i] = true
                      break

                    default:
                  }
                }
                /**
                 * If there are still valid modifiers available which have
                 * not been explicitly handled above, we just convert and
                 * add the modifiers array to the result node.
                 */

                const remainingModifiers = modifiers.filter(function(_, i) {
                  return !handledModifierIndices[i]
                })

                if (!remainingModifiers || !remainingModifiers.length) {
                  return
                }

                result.modifiers = remainingModifiers.map(function(element) {
                  return _this6.convertChild(element)
                })
              },
              /**
               * Uses the provided range location to adjust the location data of the given Node
               * @param result The node that will have its location data mutated
               * @param childRange The child node range used to expand location
               */
            },
            {
              key: 'fixParentLocation',
              value: function fixParentLocation(result, childRange) {
                if (childRange[0] < result.range[0]) {
                  result.range[0] = childRange[0]
                  result.loc.start = node_utils_1.getLineAndCharacterFor(
                    result.range[0],
                    this.ast
                  )
                }

                if (childRange[1] > result.range[1]) {
                  result.range[1] = childRange[1]
                  result.loc.end = node_utils_1.getLineAndCharacterFor(
                    result.range[1],
                    this.ast
                  )
                }
              },
              /**
               * Converts a TypeScript node into an ESTree node.
               * The core of the conversion logic:
               * Identify and convert each relevant TypeScript SyntaxKind
               * @param node the child ts.Node
               * @param parent parentNode
               * @returns the converted ESTree node
               */
            },
            {
              key: 'convertNode',
              value: function convertNode(node, parent) {
                const _this7 = this

                switch (node.kind) {
                  case SyntaxKind.SourceFile: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Program,
                      body: this.convertBodyExpressions(node.statements, node),
                      // externalModuleIndicator is internal field in TSC
                      sourceType: node.externalModuleIndicator
                        ? 'module'
                        : 'script',
                      range: [node.getStart(this.ast), node.endOfFileToken.end],
                    })
                  }

                  case SyntaxKind.Block: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.BlockStatement,
                      body: this.convertBodyExpressions(node.statements, node),
                    })
                  }

                  case SyntaxKind.Identifier: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Identifier,
                      name: node.text,
                    })
                  }

                  case SyntaxKind.WithStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.WithStatement,
                      object: this.convertChild(node.expression),
                      body: this.convertChild(node.statement),
                    })
                  // Control Flow

                  case SyntaxKind.ReturnStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ReturnStatement,
                      argument: this.convertChild(node.expression),
                    })

                  case SyntaxKind.LabeledStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.LabeledStatement,
                      label: this.convertChild(node.label),
                      body: this.convertChild(node.statement),
                    })

                  case SyntaxKind.ContinueStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ContinueStatement,
                      label: this.convertChild(node.label),
                    })

                  case SyntaxKind.BreakStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.BreakStatement,
                      label: this.convertChild(node.label),
                    })
                  // Choice

                  case SyntaxKind.IfStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.IfStatement,
                      test: this.convertChild(node.expression),
                      consequent: this.convertChild(node.thenStatement),
                      alternate: this.convertChild(node.elseStatement),
                    })

                  case SyntaxKind.SwitchStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.SwitchStatement,
                      discriminant: this.convertChild(node.expression),
                      cases: node.caseBlock.clauses.map(function(element) {
                        return _this7.convertChild(element)
                      }),
                    })

                  case SyntaxKind.CaseClause:
                  case SyntaxKind.DefaultClause:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.SwitchCase,
                      // expression is present in case only
                      test:
                        node.kind === SyntaxKind.CaseClause
                          ? this.convertChild(node.expression)
                          : null,
                      consequent: node.statements.map(function(element) {
                        return _this7.convertChild(element)
                      }),
                    })
                  // Exceptions

                  case SyntaxKind.ThrowStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ThrowStatement,
                      argument: this.convertChild(node.expression),
                    })

                  case SyntaxKind.TryStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TryStatement,
                      block: this.convertChild(node.tryBlock),
                      handler: this.convertChild(node.catchClause),
                      finalizer: this.convertChild(node.finallyBlock),
                    })

                  case SyntaxKind.CatchClause:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.CatchClause,
                      param: node.variableDeclaration
                        ? this.convertChild(node.variableDeclaration.name)
                        : null,
                      body: this.convertChild(node.block),
                    })
                  // Loops

                  case SyntaxKind.WhileStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.WhileStatement,
                      test: this.convertChild(node.expression),
                      body: this.convertChild(node.statement),
                    })

                  /**
                   * Unlike other parsers, TypeScript calls a "DoWhileStatement"
                   * a "DoStatement"
                   */

                  case SyntaxKind.DoStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.DoWhileStatement,
                      test: this.convertChild(node.expression),
                      body: this.convertChild(node.statement),
                    })

                  case SyntaxKind.ForStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ForStatement,
                      init: this.convertChild(node.initializer),
                      test: this.convertChild(node.condition),
                      update: this.convertChild(node.incrementor),
                      body: this.convertChild(node.statement),
                    })

                  case SyntaxKind.ForInStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ForInStatement,
                      left: this.convertPattern(node.initializer),
                      right: this.convertChild(node.expression),
                      body: this.convertChild(node.statement),
                    })

                  case SyntaxKind.ForOfStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ForOfStatement,
                      left: this.convertPattern(node.initializer),
                      right: this.convertChild(node.expression),
                      body: this.convertChild(node.statement),
                      await: Boolean(
                        node.awaitModifier &&
                          node.awaitModifier.kind === SyntaxKind.AwaitKeyword
                      ),
                    })
                  // Declarations

                  case SyntaxKind.FunctionDeclaration: {
                    const isDeclare = node_utils_1.hasModifier(
                      SyntaxKind.DeclareKeyword,
                      node
                    )
                    const result = this.createNode(node, {
                      type:
                        isDeclare || !node.body
                          ? ts_estree_1.AST_NODE_TYPES.TSDeclareFunction
                          : ts_estree_1.AST_NODE_TYPES.FunctionDeclaration,
                      id: this.convertChild(node.name),
                      generator: !!node.asteriskToken,
                      expression: false,
                      async: node_utils_1.hasModifier(
                        SyntaxKind.AsyncKeyword,
                        node
                      ),
                      params: this.convertParameters(node.parameters),
                      body: this.convertChild(node.body) || undefined,
                    }) // Process returnType

                    if (node.type) {
                      result.returnType = this.convertTypeAnnotation(
                        node.type,
                        node
                      )
                    }

                    if (isDeclare) {
                      result.declare = true
                    } // Process typeParameters

                    if (node.typeParameters) {
                      result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(
                        node.typeParameters
                      )
                    }
                    /**
                     * Semantically, decorators are not allowed on function declarations,
                     * but the TypeScript compiler will parse them and produce a valid AST,
                     * so we handle them here too.
                     */

                    if (node.decorators) {
                      result.decorators = node.decorators.map(function(
                        element
                      ) {
                        return _this7.convertChild(element)
                      })
                    } // check for exports

                    return this.fixExports(node, result)
                  }

                  case SyntaxKind.VariableDeclaration: {
                    const _result = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.VariableDeclarator,
                      id: this.convertPattern(node.name),
                      init: this.convertChild(node.initializer),
                    })

                    if (node.exclamationToken) {
                      _result.definite = true
                    }

                    if (node.type) {
                      _result.id.typeAnnotation = this.convertTypeAnnotation(
                        node.type,
                        node
                      )
                      this.fixParentLocation(
                        _result.id,
                        _result.id.typeAnnotation.range
                      )
                    }

                    return _result
                  }

                  case SyntaxKind.VariableStatement: {
                    const _result2 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,
                      declarations: node.declarationList.declarations.map(
                        function(element) {
                          return _this7.convertChild(element)
                        }
                      ),
                      kind: node_utils_1.getDeclarationKind(
                        node.declarationList
                      ),
                    })
                    /**
                     * Semantically, decorators are not allowed on variable declarations,
                     * but the TypeScript compiler will parse them and produce a valid AST,
                     * so we handle them here too.
                     */

                    if (node.decorators) {
                      _result2.decorators = node.decorators.map(function(
                        element
                      ) {
                        return _this7.convertChild(element)
                      })
                    }

                    if (
                      node_utils_1.hasModifier(SyntaxKind.DeclareKeyword, node)
                    ) {
                      _result2.declare = true
                    } // check for exports

                    return this.fixExports(node, _result2)
                  }
                  // mostly for for-of, for-in

                  case SyntaxKind.VariableDeclarationList:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,
                      declarations: node.declarations.map(function(element) {
                        return _this7.convertChild(element)
                      }),
                      kind: node_utils_1.getDeclarationKind(node),
                    })
                  // Expressions

                  case SyntaxKind.ExpressionStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ExpressionStatement,
                      expression: this.convertChild(node.expression),
                    })

                  case SyntaxKind.ThisKeyword:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ThisExpression,
                    })

                  case SyntaxKind.ArrayLiteralExpression: {
                    // TypeScript uses ArrayLiteralExpression in destructuring assignment, too
                    if (this.allowPattern) {
                      return this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,
                        elements: node.elements.map(function(element) {
                          return _this7.convertPattern(element)
                        }),
                      })
                    }
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ArrayExpression,
                      elements: node.elements.map(function(element) {
                        return _this7.convertChild(element)
                      }),
                    })
                  }

                  case SyntaxKind.ObjectLiteralExpression: {
                    // TypeScript uses ObjectLiteralExpression in destructuring assignment, too
                    if (this.allowPattern) {
                      return this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,
                        properties: node.properties.map(function(element) {
                          return _this7.convertPattern(element)
                        }),
                      })
                    }
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ObjectExpression,
                      properties: node.properties.map(function(element) {
                        return _this7.convertChild(element)
                      }),
                    })
                  }

                  case SyntaxKind.PropertyAssignment:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Property,
                      key: this.convertChild(node.name),
                      value: this.converter(
                        node.initializer,
                        node,
                        this.inTypeMode,
                        this.allowPattern
                      ),
                      computed: node_utils_1.isComputedProperty(node.name),
                      method: false,
                      shorthand: false,
                      kind: 'init',
                    })

                  case SyntaxKind.ShorthandPropertyAssignment: {
                    if (node.objectAssignmentInitializer) {
                      return this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.Property,
                        key: this.convertChild(node.name),
                        value: this.createNode(node, {
                          type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                          left: this.convertPattern(node.name),
                          right: this.convertChild(
                            node.objectAssignmentInitializer
                          ),
                        }),
                        computed: false,
                        method: false,
                        shorthand: true,
                        kind: 'init',
                      })
                    }
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Property,
                      key: this.convertChild(node.name),
                      value: this.convertChild(node.name),
                      computed: false,
                      method: false,
                      shorthand: true,
                      kind: 'init',
                    })
                  }

                  case SyntaxKind.ComputedPropertyName:
                    return this.convertChild(node.expression)

                  case SyntaxKind.PropertyDeclaration: {
                    const isAbstract = node_utils_1.hasModifier(
                      SyntaxKind.AbstractKeyword,
                      node
                    )

                    const _result3 = this.createNode(node, {
                      type: isAbstract
                        ? ts_estree_1.AST_NODE_TYPES.TSAbstractClassProperty
                        : ts_estree_1.AST_NODE_TYPES.ClassProperty,
                      key: this.convertChild(node.name),
                      value: this.convertChild(node.initializer),
                      computed: node_utils_1.isComputedProperty(node.name),
                      static: node_utils_1.hasModifier(
                        SyntaxKind.StaticKeyword,
                        node
                      ),
                      readonly:
                        node_utils_1.hasModifier(
                          SyntaxKind.ReadonlyKeyword,
                          node
                        ) || undefined,
                    })

                    if (node.type) {
                      _result3.typeAnnotation = this.convertTypeAnnotation(
                        node.type,
                        node
                      )
                    }

                    if (node.decorators) {
                      _result3.decorators = node.decorators.map(function(
                        element
                      ) {
                        return _this7.convertChild(element)
                      })
                    }

                    const accessibility = node_utils_1.getTSNodeAccessibility(
                      node
                    )

                    if (accessibility) {
                      _result3.accessibility = accessibility
                    }

                    if (
                      (node.name.kind === SyntaxKind.Identifier ||
                        node.name.kind === SyntaxKind.ComputedPropertyName) &&
                      node.questionToken
                    ) {
                      _result3.optional = true
                    }

                    if (node.exclamationToken) {
                      _result3.definite = true
                    }

                    if (
                      _result3.key.type ===
                        ts_estree_1.AST_NODE_TYPES.Literal &&
                      node.questionToken
                    ) {
                      _result3.optional = true
                    }

                    return _result3
                  }

                  case SyntaxKind.GetAccessor:
                  case SyntaxKind.SetAccessor:
                  case SyntaxKind.MethodDeclaration: {
                    const method = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.FunctionExpression,
                      id: null,
                      generator: !!node.asteriskToken,
                      expression: false,
                      async: node_utils_1.hasModifier(
                        SyntaxKind.AsyncKeyword,
                        node
                      ),
                      body: this.convertChild(node.body),
                      range: [node.parameters.pos - 1, node.end],
                      params: [],
                    })

                    if (node.type) {
                      method.returnType = this.convertTypeAnnotation(
                        node.type,
                        node
                      )
                    } // Process typeParameters

                    if (node.typeParameters) {
                      method.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(
                        node.typeParameters
                      )
                      this.fixParentLocation(
                        method,
                        method.typeParameters.range
                      )
                    }

                    let _result4

                    if (parent.kind === SyntaxKind.ObjectLiteralExpression) {
                      method.params = node.parameters.map(function(element) {
                        return _this7.convertChild(element)
                      })
                      _result4 = this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.Property,
                        key: this.convertChild(node.name),
                        value: method,
                        computed: node_utils_1.isComputedProperty(node.name),
                        method: node.kind === SyntaxKind.MethodDeclaration,
                        shorthand: false,
                        kind: 'init',
                      })
                    } else {
                      // class

                      /**
                       * Unlike in object literal methods, class method params can have decorators
                       */
                      method.params = this.convertParameters(node.parameters)
                      /**
                       * TypeScript class methods can be defined as "abstract"
                       */

                      const methodDefinitionType = node_utils_1.hasModifier(
                        SyntaxKind.AbstractKeyword,
                        node
                      )
                        ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition
                        : ts_estree_1.AST_NODE_TYPES.MethodDefinition
                      _result4 = this.createNode(node, {
                        type: methodDefinitionType,
                        key: this.convertChild(node.name),
                        value: method,
                        computed: node_utils_1.isComputedProperty(node.name),
                        static: node_utils_1.hasModifier(
                          SyntaxKind.StaticKeyword,
                          node
                        ),
                        kind: 'method',
                      })

                      if (node.decorators) {
                        _result4.decorators = node.decorators.map(function(
                          element
                        ) {
                          return _this7.convertChild(element)
                        })
                      }

                      const _accessibility = node_utils_1.getTSNodeAccessibility(
                        node
                      )

                      if (_accessibility) {
                        _result4.accessibility = _accessibility
                      }
                    }

                    if (
                      _result4.key.type ===
                        ts_estree_1.AST_NODE_TYPES.Identifier &&
                      node.questionToken
                    ) {
                      _result4.key.optional = true
                    }

                    if (node.kind === SyntaxKind.GetAccessor) {
                      _result4.kind = 'get'
                    } else if (node.kind === SyntaxKind.SetAccessor) {
                      _result4.kind = 'set'
                    } else if (
                      !_result4.static &&
                      node.name.kind === SyntaxKind.StringLiteral &&
                      node.name.text === 'constructor' &&
                      _result4.type !== ts_estree_1.AST_NODE_TYPES.Property
                    ) {
                      _result4.kind = 'constructor'
                    }

                    return _result4
                  }
                  // TypeScript uses this even for static methods named "constructor"

                  case SyntaxKind.Constructor: {
                    const lastModifier = node_utils_1.getLastModifier(node)
                    const constructorToken =
                      (lastModifier &&
                        node_utils_1.findNextToken(
                          lastModifier,
                          node,
                          this.ast
                        )) ||
                      node.getFirstToken()

                    const _constructor = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.FunctionExpression,
                      id: null,
                      params: this.convertParameters(node.parameters),
                      generator: false,
                      expression: false,
                      async: false,
                      body: this.convertChild(node.body),
                      range: [node.parameters.pos - 1, node.end],
                    }) // Process typeParameters

                    if (node.typeParameters) {
                      _constructor.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(
                        node.typeParameters
                      )
                      this.fixParentLocation(
                        _constructor,
                        _constructor.typeParameters.range
                      )
                    } // Process returnType

                    if (node.type) {
                      _constructor.returnType = this.convertTypeAnnotation(
                        node.type,
                        node
                      )
                    }

                    const constructorKey = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Identifier,
                      name: 'constructor',
                      range: [
                        constructorToken.getStart(this.ast),
                        constructorToken.end,
                      ],
                    })
                    const isStatic = node_utils_1.hasModifier(
                      SyntaxKind.StaticKeyword,
                      node
                    )

                    const _result5 = this.createNode(node, {
                      type: node_utils_1.hasModifier(
                        SyntaxKind.AbstractKeyword,
                        node
                      )
                        ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition
                        : ts_estree_1.AST_NODE_TYPES.MethodDefinition,
                      key: constructorKey,
                      value: _constructor,
                      computed: false,
                      static: isStatic,
                      kind: isStatic ? 'method' : 'constructor',
                    })

                    const _accessibility2 = node_utils_1.getTSNodeAccessibility(
                      node
                    )

                    if (_accessibility2) {
                      _result5.accessibility = _accessibility2
                    }

                    return _result5
                  }

                  case SyntaxKind.FunctionExpression: {
                    const _result6 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.FunctionExpression,
                      id: this.convertChild(node.name),
                      generator: !!node.asteriskToken,
                      params: this.convertParameters(node.parameters),
                      body: this.convertChild(node.body),
                      async: node_utils_1.hasModifier(
                        SyntaxKind.AsyncKeyword,
                        node
                      ),
                      expression: false,
                    }) // Process returnType

                    if (node.type) {
                      _result6.returnType = this.convertTypeAnnotation(
                        node.type,
                        node
                      )
                    } // Process typeParameters

                    if (node.typeParameters) {
                      _result6.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(
                        node.typeParameters
                      )
                    }

                    return _result6
                  }

                  case SyntaxKind.SuperKeyword:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Super,
                    })

                  case SyntaxKind.ArrayBindingPattern:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,
                      elements: node.elements.map(function(element) {
                        return _this7.convertPattern(element)
                      }),
                    })
                  // occurs with missing array elements like [,]

                  case SyntaxKind.OmittedExpression:
                    return null

                  case SyntaxKind.ObjectBindingPattern:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,
                      properties: node.elements.map(function(element) {
                        return _this7.convertPattern(element)
                      }),
                    })

                  case SyntaxKind.BindingElement: {
                    if (parent.kind === SyntaxKind.ArrayBindingPattern) {
                      const arrayItem = this.convertChild(node.name, parent)

                      if (node.initializer) {
                        return this.createNode(node, {
                          type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                          left: arrayItem,
                          right: this.convertChild(node.initializer),
                        })
                      }
                      if (node.dotDotDotToken) {
                        return this.createNode(node, {
                          type: ts_estree_1.AST_NODE_TYPES.RestElement,
                          argument: arrayItem,
                        })
                      }
                      return arrayItem
                    }
                    let _result7

                    if (node.dotDotDotToken) {
                      _result7 = this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.RestElement,
                        argument: this.convertChild(
                          node.propertyName || node.name
                        ),
                      })
                    } else {
                      _result7 = this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.Property,
                        key: this.convertChild(node.propertyName || node.name),
                        value: this.convertChild(node.name),
                        computed: Boolean(
                          node.propertyName &&
                            node.propertyName.kind ===
                              SyntaxKind.ComputedPropertyName
                        ),
                        method: false,
                        shorthand: !node.propertyName,
                        kind: 'init',
                      })
                    }

                    if (node.initializer) {
                      _result7.value = this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                        left: this.convertChild(node.name),
                        right: this.convertChild(node.initializer),
                        range: [
                          node.name.getStart(this.ast),
                          node.initializer.end,
                        ],
                      })
                    }

                    return _result7
                  }

                  case SyntaxKind.ArrowFunction: {
                    const _result8 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ArrowFunctionExpression,
                      generator: false,
                      id: null,
                      params: this.convertParameters(node.parameters),
                      body: this.convertChild(node.body),
                      async: node_utils_1.hasModifier(
                        SyntaxKind.AsyncKeyword,
                        node
                      ),
                      expression: node.body.kind !== SyntaxKind.Block,
                    }) // Process returnType

                    if (node.type) {
                      _result8.returnType = this.convertTypeAnnotation(
                        node.type,
                        node
                      )
                    } // Process typeParameters

                    if (node.typeParameters) {
                      _result8.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(
                        node.typeParameters
                      )
                    }

                    return _result8
                  }

                  case SyntaxKind.YieldExpression:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.YieldExpression,
                      delegate: !!node.asteriskToken,
                      argument: this.convertChild(node.expression),
                    })

                  case SyntaxKind.AwaitExpression:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.AwaitExpression,
                      argument: this.convertChild(node.expression),
                    })
                  // Template Literals

                  case SyntaxKind.NoSubstitutionTemplateLiteral:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,
                      quasis: [
                        this.createNode(node, {
                          type: ts_estree_1.AST_NODE_TYPES.TemplateElement,
                          value: {
                            raw: this.ast.text.slice(
                              node.getStart(this.ast) + 1,
                              node.end - 1
                            ),
                            cooked: node.text,
                          },
                          tail: true,
                        }),
                      ],
                      expressions: [],
                    })

                  case SyntaxKind.TemplateExpression: {
                    const _result9 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,
                      quasis: [this.convertChild(node.head)],
                      expressions: [],
                    })

                    node.templateSpans.forEach(function(templateSpan) {
                      _result9.expressions.push(
                        _this7.convertChild(templateSpan.expression)
                      )

                      _result9.quasis.push(
                        _this7.convertChild(templateSpan.literal)
                      )
                    })
                    return _result9
                  }

                  case SyntaxKind.TaggedTemplateExpression:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TaggedTemplateExpression,
                      typeParameters: node.typeArguments
                        ? this.convertTypeArgumentsToTypeParameters(
                            node.typeArguments
                          )
                        : undefined,
                      tag: this.convertChild(node.tag),
                      quasi: this.convertChild(node.template),
                    })

                  case SyntaxKind.TemplateHead:
                  case SyntaxKind.TemplateMiddle:
                  case SyntaxKind.TemplateTail: {
                    const tail = node.kind === SyntaxKind.TemplateTail
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TemplateElement,
                      value: {
                        raw: this.ast.text.slice(
                          node.getStart(this.ast) + 1,
                          node.end - (tail ? 1 : 2)
                        ),
                        cooked: node.text,
                      },
                      tail,
                    })
                  }
                  // Patterns

                  case SyntaxKind.SpreadAssignment:
                  case SyntaxKind.SpreadElement: {
                    if (this.allowPattern) {
                      return this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.RestElement,
                        argument: this.convertPattern(node.expression),
                      })
                    }
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.SpreadElement,
                      argument: this.convertChild(node.expression),
                    })
                  }

                  case SyntaxKind.Parameter: {
                    let parameter

                    let _result10

                    if (node.dotDotDotToken) {
                      parameter = _result10 = this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.RestElement,
                        argument: this.convertChild(node.name),
                      })
                    } else if (node.initializer) {
                      parameter = this.convertChild(node.name)
                      _result10 = this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                        left: parameter,
                        right: this.convertChild(node.initializer),
                      })

                      if (node.modifiers) {
                        // AssignmentPattern should not contain modifiers in range
                        _result10.range[0] = parameter.range[0]
                        _result10.loc = node_utils_1.getLocFor(
                          _result10.range[0],
                          _result10.range[1],
                          this.ast
                        )
                      }
                    } else {
                      parameter = _result10 = this.convertChild(
                        node.name,
                        parent
                      )
                    }

                    if (node.type) {
                      parameter.typeAnnotation = this.convertTypeAnnotation(
                        node.type,
                        node
                      )
                      this.fixParentLocation(
                        parameter,
                        parameter.typeAnnotation.range
                      )
                    }

                    if (node.questionToken) {
                      if (node.questionToken.end > parameter.range[1]) {
                        parameter.range[1] = node.questionToken.end
                        parameter.loc.end = node_utils_1.getLineAndCharacterFor(
                          parameter.range[1],
                          this.ast
                        )
                      }

                      parameter.optional = true
                    }

                    if (node.modifiers) {
                      return this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.TSParameterProperty,
                        accessibility:
                          node_utils_1.getTSNodeAccessibility(node) ||
                          undefined,
                        readonly:
                          node_utils_1.hasModifier(
                            SyntaxKind.ReadonlyKeyword,
                            node
                          ) || undefined,
                        static:
                          node_utils_1.hasModifier(
                            SyntaxKind.StaticKeyword,
                            node
                          ) || undefined,
                        export:
                          node_utils_1.hasModifier(
                            SyntaxKind.ExportKeyword,
                            node
                          ) || undefined,
                        parameter: _result10,
                      })
                    }

                    return _result10
                  }
                  // Classes

                  case SyntaxKind.ClassDeclaration:
                  case SyntaxKind.ClassExpression: {
                    const heritageClauses = node.heritageClauses || []
                    const classNodeType =
                      node.kind === SyntaxKind.ClassDeclaration
                        ? ts_estree_1.AST_NODE_TYPES.ClassDeclaration
                        : ts_estree_1.AST_NODE_TYPES.ClassExpression
                    const superClass = heritageClauses.find(function(clause) {
                      return clause.token === SyntaxKind.ExtendsKeyword
                    })
                    const implementsClause = heritageClauses.find(function(
                      clause
                    ) {
                      return clause.token === SyntaxKind.ImplementsKeyword
                    })

                    const _result11 = this.createNode(node, {
                      type: classNodeType,
                      id: this.convertChild(node.name),
                      body: this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.ClassBody,
                        body: [],
                        range: [node.members.pos - 1, node.end],
                      }),
                      superClass:
                        superClass && superClass.types[0]
                          ? this.convertChild(superClass.types[0].expression)
                          : null,
                    })

                    if (superClass) {
                      if (superClass.types.length > 1) {
                        throw node_utils_1.createError(
                          this.ast,
                          superClass.types[1].pos,
                          'Classes can only extend a single class.'
                        )
                      }

                      if (
                        superClass.types[0] &&
                        superClass.types[0].typeArguments
                      ) {
                        _result11.superTypeParameters = this.convertTypeArgumentsToTypeParameters(
                          superClass.types[0].typeArguments
                        )
                      }
                    }

                    if (node.typeParameters) {
                      _result11.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(
                        node.typeParameters
                      )
                    }

                    if (implementsClause) {
                      _result11.implements = implementsClause.types.map(
                        function(element) {
                          return _this7.convertChild(element)
                        }
                      )
                    }
                    /**
                     * TypeScript class declarations can be defined as "abstract"
                     */

                    if (
                      node_utils_1.hasModifier(SyntaxKind.AbstractKeyword, node)
                    ) {
                      _result11.abstract = true
                    }

                    if (
                      node_utils_1.hasModifier(SyntaxKind.DeclareKeyword, node)
                    ) {
                      _result11.declare = true
                    }

                    if (node.decorators) {
                      _result11.decorators = node.decorators.map(function(
                        element
                      ) {
                        return _this7.convertChild(element)
                      })
                    }

                    const filteredMembers = node.members.filter(
                      node_utils_1.isESTreeClassMember
                    )

                    if (filteredMembers.length) {
                      _result11.body.body = filteredMembers.map(function(
                        element
                      ) {
                        return _this7.convertChild(element)
                      })
                    } // check for exports

                    return this.fixExports(node, _result11)
                  }
                  // Modules

                  case SyntaxKind.ModuleBlock:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSModuleBlock,
                      body: this.convertBodyExpressions(node.statements, node),
                    })

                  case SyntaxKind.ImportDeclaration: {
                    const _result12 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ImportDeclaration,
                      source: this.convertChild(node.moduleSpecifier),
                      specifiers: [],
                    })

                    if (node.importClause) {
                      if (node.importClause.name) {
                        _result12.specifiers.push(
                          this.convertChild(node.importClause)
                        )
                      }

                      if (node.importClause.namedBindings) {
                        switch (node.importClause.namedBindings.kind) {
                          case SyntaxKind.NamespaceImport:
                            _result12.specifiers.push(
                              this.convertChild(node.importClause.namedBindings)
                            )

                            break

                          case SyntaxKind.NamedImports:
                            _result12.specifiers = _result12.specifiers.concat(
                              node.importClause.namedBindings.elements.map(
                                function(element) {
                                  return _this7.convertChild(element)
                                }
                              )
                            )
                            break
                        }
                      }
                    }

                    return _result12
                  }

                  case SyntaxKind.NamespaceImport:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ImportNamespaceSpecifier,
                      local: this.convertChild(node.name),
                    })

                  case SyntaxKind.ImportSpecifier:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ImportSpecifier,
                      local: this.convertChild(node.name),
                      imported: this.convertChild(
                        node.propertyName || node.name
                      ),
                    })

                  case SyntaxKind.ImportClause:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ImportDefaultSpecifier,
                      local: this.convertChild(node.name),
                      range: [node.getStart(this.ast), node.name.end],
                    })

                  case SyntaxKind.ExportDeclaration:
                    if (node.exportClause) {
                      return this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,
                        source: this.convertChild(node.moduleSpecifier),
                        specifiers: node.exportClause.elements.map(function(
                          element
                        ) {
                          return _this7.convertChild(element)
                        }),
                        declaration: null,
                      })
                    }
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ExportAllDeclaration,
                      source: this.convertChild(node.moduleSpecifier),
                    })

                  case SyntaxKind.ExportSpecifier:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ExportSpecifier,
                      local: this.convertChild(node.propertyName || node.name),
                      exported: this.convertChild(node.name),
                    })

                  case SyntaxKind.ExportAssignment:
                    if (node.isExportEquals) {
                      return this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.TSExportAssignment,
                        expression: this.convertChild(node.expression),
                      })
                    }
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,
                      declaration: this.convertChild(node.expression),
                    })

                  // Unary Operations

                  case SyntaxKind.PrefixUnaryExpression:
                  case SyntaxKind.PostfixUnaryExpression: {
                    const operator =
                      node_utils_1.getTextForTokenKind(node.operator) || ''
                    /**
                     * ESTree uses UpdateExpression for ++/--
                     */

                    if (/^(?:\+\+|--)$/.test(operator)) {
                      return this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.UpdateExpression,
                        operator,
                        prefix: node.kind === SyntaxKind.PrefixUnaryExpression,
                        argument: this.convertChild(node.operand),
                      })
                    }
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,
                      operator,
                      prefix: node.kind === SyntaxKind.PrefixUnaryExpression,
                      argument: this.convertChild(node.operand),
                    })
                  }

                  case SyntaxKind.DeleteExpression:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,
                      operator: 'delete',
                      prefix: true,
                      argument: this.convertChild(node.expression),
                    })

                  case SyntaxKind.VoidExpression:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,
                      operator: 'void',
                      prefix: true,
                      argument: this.convertChild(node.expression),
                    })

                  case SyntaxKind.TypeOfExpression:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,
                      operator: 'typeof',
                      prefix: true,
                      argument: this.convertChild(node.expression),
                    })

                  case SyntaxKind.TypeOperator:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSTypeOperator,
                      operator: node_utils_1.getTextForTokenKind(node.operator),
                      typeAnnotation: this.convertChild(node.type),
                    })
                  // Binary Operations

                  case SyntaxKind.BinaryExpression: {
                    // TypeScript uses BinaryExpression for sequences as well
                    if (node_utils_1.isComma(node.operatorToken)) {
                      const _result13 = this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.SequenceExpression,
                        expressions: [],
                      })

                      const left = this.convertChild(node.left)

                      if (
                        left.type ===
                          ts_estree_1.AST_NODE_TYPES.SequenceExpression &&
                        node.left.kind !== SyntaxKind.ParenthesizedExpression
                      ) {
                        _result13.expressions = _result13.expressions.concat(
                          left.expressions
                        )
                      } else {
                        _result13.expressions.push(left)
                      }

                      _result13.expressions.push(this.convertChild(node.right))

                      return _result13
                    }
                    const type = node_utils_1.getBinaryExpressionType(
                      node.operatorToken
                    )

                    if (
                      this.allowPattern &&
                      type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression
                    ) {
                      return this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                        left: this.convertPattern(node.left, node),
                        right: this.convertChild(node.right),
                      })
                    }

                    return this.createNode(node, {
                      type,
                      operator: node_utils_1.getTextForTokenKind(
                        node.operatorToken.kind
                      ),
                      left: this.converter(
                        node.left,
                        node,
                        this.inTypeMode,
                        type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression
                      ),
                      right: this.convertChild(node.right),
                    })
                  }

                  case SyntaxKind.PropertyAccessExpression: {
                    const isLocallyOptional =
                      node.questionDotToken !== undefined
                    const object = this.convertChild(node.expression)
                    const property = this.convertChild(node.name)
                    const computed = false

                    if (
                      isLocallyOptional || // the optional expression should propogate up the member expression tree
                      object.type ===
                        ts_estree_1.AST_NODE_TYPES.OptionalMemberExpression ||
                      object.type ===
                        ts_estree_1.AST_NODE_TYPES.OptionalCallExpression
                    ) {
                      return this.createNode(node, {
                        type:
                          ts_estree_1.AST_NODE_TYPES.OptionalMemberExpression,
                        object,
                        property,
                        computed,
                        optional: isLocallyOptional,
                      })
                    }
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.MemberExpression,
                      object,
                      property,
                      computed,
                      optional: false,
                    })
                  }

                  case SyntaxKind.ElementAccessExpression: {
                    const _isLocallyOptional =
                      node.questionDotToken !== undefined

                    const _object = this.convertChild(node.expression)

                    const _property = this.convertChild(node.argumentExpression)

                    const _computed = true

                    if (
                      _isLocallyOptional || // the optional expression should propogate up the member expression tree
                      _object.type ===
                        ts_estree_1.AST_NODE_TYPES.OptionalMemberExpression ||
                      _object.type ===
                        ts_estree_1.AST_NODE_TYPES.OptionalCallExpression
                    ) {
                      return this.createNode(node, {
                        type:
                          ts_estree_1.AST_NODE_TYPES.OptionalMemberExpression,
                        object: _object,
                        property: _property,
                        computed: _computed,
                        optional: _isLocallyOptional,
                      })
                    }
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.MemberExpression,
                      object: _object,
                      property: _property,
                      computed: _computed,
                      optional: false,
                    })
                  }

                  case SyntaxKind.CallExpression: {
                    const _isLocallyOptional2 =
                      node.questionDotToken !== undefined

                    const callee = this.convertChild(node.expression)
                    const arguments_ = node.arguments.map(function(element) {
                      return _this7.convertChild(element)
                    })

                    let _result14

                    if (
                      _isLocallyOptional2 || // the optional expression should propogate up the member expression tree
                      callee.type ===
                        ts_estree_1.AST_NODE_TYPES.OptionalMemberExpression ||
                      callee.type ===
                        ts_estree_1.AST_NODE_TYPES.OptionalCallExpression
                    ) {
                      _result14 = this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.OptionalCallExpression,
                        callee,
                        arguments: arguments_,
                        optional: _isLocallyOptional2,
                      })
                    } else {
                      _result14 = this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.CallExpression,
                        callee,
                        arguments: arguments_,
                        optional: false,
                      })
                    }

                    if (node.typeArguments) {
                      _result14.typeParameters = this.convertTypeArgumentsToTypeParameters(
                        node.typeArguments
                      )
                    }

                    return _result14
                  }

                  case SyntaxKind.NewExpression: {
                    // NOTE - NewExpression cannot have an optional chain in it
                    const _result15 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.NewExpression,
                      callee: this.convertChild(node.expression),
                      arguments: node.arguments
                        ? node.arguments.map(function(element) {
                            return _this7.convertChild(element)
                          })
                        : [],
                    })

                    if (node.typeArguments) {
                      _result15.typeParameters = this.convertTypeArgumentsToTypeParameters(
                        node.typeArguments
                      )
                    }

                    return _result15
                  }

                  case SyntaxKind.ConditionalExpression:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.ConditionalExpression,
                      test: this.convertChild(node.condition),
                      consequent: this.convertChild(node.whenTrue),
                      alternate: this.convertChild(node.whenFalse),
                    })

                  case SyntaxKind.MetaProperty: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.MetaProperty,
                      meta: this.createNode(node.getFirstToken(), {
                        type: ts_estree_1.AST_NODE_TYPES.Identifier,
                        name: node_utils_1.getTextForTokenKind(
                          node.keywordToken
                        ),
                      }),
                      property: this.convertChild(node.name),
                    })
                  }

                  case SyntaxKind.Decorator: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Decorator,
                      expression: this.convertChild(node.expression),
                    })
                  }
                  // Literals

                  case SyntaxKind.StringLiteral: {
                    const _result16 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Literal,
                      raw: '',
                      value: '',
                    })

                    _result16.raw = this.ast.text.slice(
                      _result16.range[0],
                      _result16.range[1]
                    )

                    if (parent.name && parent.name === node) {
                      _result16.value = node.text
                    } else {
                      _result16.value = node_utils_1.unescapeStringLiteralText(
                        node.text
                      )
                    }

                    return _result16
                  }

                  case SyntaxKind.NumericLiteral: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Literal,
                      value: Number(node.text),
                      raw: node.getText(),
                    })
                  }

                  case SyntaxKind.BigIntLiteral: {
                    const _result17 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.BigIntLiteral,
                      raw: '',
                      value: '',
                    })

                    _result17.raw = this.ast.text.slice(
                      _result17.range[0],
                      _result17.range[1]
                    )
                    _result17.value = _result17.raw.slice(0, -1) // remove suffix `n`

                    return _result17
                  }

                  case SyntaxKind.RegularExpressionLiteral: {
                    const pattern = node.text.slice(
                      1,
                      node.text.lastIndexOf('/')
                    )
                    const flags = node.text.slice(
                      node.text.lastIndexOf('/') + 1
                    )
                    let regex = null

                    try {
                      regex = new RegExp(pattern, flags)
                    } catch (error) {
                      regex = null
                    }

                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Literal,
                      value: regex,
                      raw: node.text,
                      regex: {
                        pattern,
                        flags,
                      },
                    })
                  }

                  case SyntaxKind.TrueKeyword:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Literal,
                      value: true,
                      raw: 'true',
                    })

                  case SyntaxKind.FalseKeyword:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Literal,
                      value: false,
                      raw: 'false',
                    })

                  case SyntaxKind.NullKeyword: {
                    if (this.inTypeMode) {
                      return this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword,
                      })
                    }
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Literal,
                      value: null,
                      raw: 'null',
                    })
                  }

                  case SyntaxKind.ImportKeyword:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Import,
                    })

                  case SyntaxKind.EmptyStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.EmptyStatement,
                    })

                  case SyntaxKind.DebuggerStatement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.DebuggerStatement,
                    })
                  // JSX

                  case SyntaxKind.JsxElement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.JSXElement,
                      openingElement: this.convertChild(node.openingElement),
                      closingElement: this.convertChild(node.closingElement),
                      children: node.children.map(function(element) {
                        return _this7.convertChild(element)
                      }),
                    })

                  case SyntaxKind.JsxFragment:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.JSXFragment,
                      openingFragment: this.convertChild(node.openingFragment),
                      closingFragment: this.convertChild(node.closingFragment),
                      children: node.children.map(function(element) {
                        return _this7.convertChild(element)
                      }),
                    })

                  case SyntaxKind.JsxSelfClosingElement: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.JSXElement,

                      /**
                       * Convert SyntaxKind.JsxSelfClosingElement to SyntaxKind.JsxOpeningElement,
                       * TypeScript does not seem to have the idea of openingElement when tag is self-closing
                       */
                      openingElement: this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,
                        typeParameters: node.typeArguments
                          ? this.convertTypeArgumentsToTypeParameters(
                              node.typeArguments
                            )
                          : undefined,
                        selfClosing: true,
                        name: this.convertJSXTagName(node.tagName, node),
                        attributes: node.attributes.properties.map(function(
                          element
                        ) {
                          return _this7.convertChild(element)
                        }),
                        range: node_utils_1.getRange(node, this.ast),
                      }),
                      closingElement: null,
                      children: [],
                    })
                  }

                  case SyntaxKind.JsxOpeningElement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,
                      typeParameters: node.typeArguments
                        ? this.convertTypeArgumentsToTypeParameters(
                            node.typeArguments
                          )
                        : undefined,
                      selfClosing: false,
                      name: this.convertJSXTagName(node.tagName, node),
                      attributes: node.attributes.properties.map(function(
                        element
                      ) {
                        return _this7.convertChild(element)
                      }),
                    })

                  case SyntaxKind.JsxClosingElement:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.JSXClosingElement,
                      name: this.convertJSXTagName(node.tagName, node),
                    })

                  case SyntaxKind.JsxOpeningFragment:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.JSXOpeningFragment,
                    })

                  case SyntaxKind.JsxClosingFragment:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.JSXClosingFragment,
                    })

                  case SyntaxKind.JsxExpression: {
                    const expression = node.expression
                      ? this.convertChild(node.expression)
                      : this.createNode(node, {
                          type: ts_estree_1.AST_NODE_TYPES.JSXEmptyExpression,
                          range: [
                            node.getStart(this.ast) + 1,
                            node.getEnd() - 1,
                          ],
                        })

                    if (node.dotDotDotToken) {
                      return this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.JSXSpreadChild,
                        expression,
                      })
                    }
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.JSXExpressionContainer,
                      expression,
                    })
                  }

                  case SyntaxKind.JsxAttribute: {
                    const attributeName = this.convertChild(node.name)
                    attributeName.type =
                      ts_estree_1.AST_NODE_TYPES.JSXIdentifier
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.JSXAttribute,
                      name: attributeName,
                      value: this.convertChild(node.initializer),
                    })
                  }

                  /**
                   * The JSX AST changed the node type for string literals
                   * inside a JSX Element from `Literal` to `JSXText`. We
                   * provide a flag to support both types until `Literal`
                   * node type is deprecated in ESLint v5.
                   */

                  case SyntaxKind.JsxText: {
                    const start = node.getFullStart()
                    const end = node.getEnd()

                    if (this.options.useJSXTextNode) {
                      return this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.JSXText,
                        value: this.ast.text.slice(start, end),
                        raw: this.ast.text.slice(start, end),
                        range: [start, end],
                      })
                    }
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.Literal,
                      value: this.ast.text.slice(start, end),
                      raw: this.ast.text.slice(start, end),
                      range: [start, end],
                    })
                  }

                  case SyntaxKind.JsxSpreadAttribute:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.JSXSpreadAttribute,
                      argument: this.convertChild(node.expression),
                    })

                  case SyntaxKind.QualifiedName: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSQualifiedName,
                      left: this.convertChild(node.left),
                      right: this.convertChild(node.right),
                    })
                  }
                  // TypeScript specific

                  case SyntaxKind.TypeReference: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSTypeReference,
                      typeName: this.convertType(node.typeName),
                      typeParameters: node.typeArguments
                        ? this.convertTypeArgumentsToTypeParameters(
                            node.typeArguments
                          )
                        : undefined,
                    })
                  }

                  case SyntaxKind.TypeParameter: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSTypeParameter,
                      name: this.convertType(node.name),
                      constraint: node.constraint
                        ? this.convertType(node.constraint)
                        : undefined,
                      default: node.default
                        ? this.convertType(node.default)
                        : undefined,
                    })
                  }

                  case SyntaxKind.ThisType:
                  case SyntaxKind.AnyKeyword:
                  case SyntaxKind.BigIntKeyword:
                  case SyntaxKind.BooleanKeyword:
                  case SyntaxKind.NeverKeyword:
                  case SyntaxKind.NumberKeyword:
                  case SyntaxKind.ObjectKeyword:
                  case SyntaxKind.StringKeyword:
                  case SyntaxKind.SymbolKeyword:
                  case SyntaxKind.UnknownKeyword:
                  case SyntaxKind.VoidKeyword:
                  case SyntaxKind.UndefinedKeyword: {
                    return this.createNode(node, {
                      type:
                        ts_estree_1.AST_NODE_TYPES[
                          `TS${SyntaxKind[node.kind]}`
                        ],
                    })
                  }

                  case SyntaxKind.NonNullExpression: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSNonNullExpression,
                      expression: this.convertChild(node.expression),
                    })
                  }

                  case SyntaxKind.TypeLiteral: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSTypeLiteral,
                      members: node.members.map(function(element) {
                        return _this7.convertChild(element)
                      }),
                    })
                  }

                  case SyntaxKind.ArrayType: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSArrayType,
                      elementType: this.convertType(node.elementType),
                    })
                  }

                  case SyntaxKind.IndexedAccessType: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSIndexedAccessType,
                      objectType: this.convertType(node.objectType),
                      indexType: this.convertType(node.indexType),
                    })
                  }

                  case SyntaxKind.ConditionalType: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSConditionalType,
                      checkType: this.convertType(node.checkType),
                      extendsType: this.convertType(node.extendsType),
                      trueType: this.convertType(node.trueType),
                      falseType: this.convertType(node.falseType),
                    })
                  }

                  case SyntaxKind.TypeQuery: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSTypeQuery,
                      exprName: this.convertType(node.exprName),
                    })
                  }

                  case SyntaxKind.MappedType: {
                    const _result18 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSMappedType,
                      typeParameter: this.convertType(node.typeParameter),
                    })

                    if (node.readonlyToken) {
                      if (
                        node.readonlyToken.kind === SyntaxKind.ReadonlyKeyword
                      ) {
                        _result18.readonly = true
                      } else {
                        _result18.readonly = node_utils_1.getTextForTokenKind(
                          node.readonlyToken.kind
                        )
                      }
                    }

                    if (node.questionToken) {
                      if (
                        node.questionToken.kind === SyntaxKind.QuestionToken
                      ) {
                        _result18.optional = true
                      } else {
                        _result18.optional = node_utils_1.getTextForTokenKind(
                          node.questionToken.kind
                        )
                      }
                    }

                    if (node.type) {
                      _result18.typeAnnotation = this.convertType(node.type)
                    }

                    return _result18
                  }

                  case SyntaxKind.ParenthesizedExpression:
                    return this.convertChild(node.expression, parent)

                  case SyntaxKind.TypeAliasDeclaration: {
                    const _result19 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration,
                      id: this.convertChild(node.name),
                      typeAnnotation: this.convertType(node.type),
                    })

                    if (
                      node_utils_1.hasModifier(SyntaxKind.DeclareKeyword, node)
                    ) {
                      _result19.declare = true
                    } // Process typeParameters

                    if (node.typeParameters) {
                      _result19.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(
                        node.typeParameters
                      )
                    } // check for exports

                    return this.fixExports(node, _result19)
                  }

                  case SyntaxKind.MethodSignature: {
                    const _result20 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSMethodSignature,
                      computed: node_utils_1.isComputedProperty(node.name),
                      key: this.convertChild(node.name),
                      params: this.convertParameters(node.parameters),
                    })

                    if (node_utils_1.isOptional(node)) {
                      _result20.optional = true
                    }

                    if (node.type) {
                      _result20.returnType = this.convertTypeAnnotation(
                        node.type,
                        node
                      )
                    }

                    if (
                      node_utils_1.hasModifier(SyntaxKind.ReadonlyKeyword, node)
                    ) {
                      _result20.readonly = true
                    }

                    if (node.typeParameters) {
                      _result20.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(
                        node.typeParameters
                      )
                    }

                    const _accessibility3 = node_utils_1.getTSNodeAccessibility(
                      node
                    )

                    if (_accessibility3) {
                      _result20.accessibility = _accessibility3
                    }

                    if (
                      node_utils_1.hasModifier(SyntaxKind.ExportKeyword, node)
                    ) {
                      _result20.export = true
                    }

                    if (
                      node_utils_1.hasModifier(SyntaxKind.StaticKeyword, node)
                    ) {
                      _result20.static = true
                    }

                    return _result20
                  }

                  case SyntaxKind.PropertySignature: {
                    const _result21 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSPropertySignature,
                      optional: node_utils_1.isOptional(node) || undefined,
                      computed: node_utils_1.isComputedProperty(node.name),
                      key: this.convertChild(node.name),
                      typeAnnotation: node.type
                        ? this.convertTypeAnnotation(node.type, node)
                        : undefined,
                      initializer:
                        this.convertChild(node.initializer) || undefined,
                      readonly:
                        node_utils_1.hasModifier(
                          SyntaxKind.ReadonlyKeyword,
                          node
                        ) || undefined,
                      static:
                        node_utils_1.hasModifier(
                          SyntaxKind.StaticKeyword,
                          node
                        ) || undefined,
                      export:
                        node_utils_1.hasModifier(
                          SyntaxKind.ExportKeyword,
                          node
                        ) || undefined,
                    })

                    const _accessibility4 = node_utils_1.getTSNodeAccessibility(
                      node
                    )

                    if (_accessibility4) {
                      _result21.accessibility = _accessibility4
                    }

                    return _result21
                  }

                  case SyntaxKind.IndexSignature: {
                    const _result22 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSIndexSignature,
                      parameters: node.parameters.map(function(element) {
                        return _this7.convertChild(element)
                      }),
                    })

                    if (node.type) {
                      _result22.typeAnnotation = this.convertTypeAnnotation(
                        node.type,
                        node
                      )
                    }

                    if (
                      node_utils_1.hasModifier(SyntaxKind.ReadonlyKeyword, node)
                    ) {
                      _result22.readonly = true
                    }

                    const _accessibility5 = node_utils_1.getTSNodeAccessibility(
                      node
                    )

                    if (_accessibility5) {
                      _result22.accessibility = _accessibility5
                    }

                    if (
                      node_utils_1.hasModifier(SyntaxKind.ExportKeyword, node)
                    ) {
                      _result22.export = true
                    }

                    if (
                      node_utils_1.hasModifier(SyntaxKind.StaticKeyword, node)
                    ) {
                      _result22.static = true
                    }

                    return _result22
                  }

                  case SyntaxKind.ConstructorType:
                  case SyntaxKind.FunctionType:
                  case SyntaxKind.ConstructSignature:
                  case SyntaxKind.CallSignature: {
                    let _type

                    switch (node.kind) {
                      case SyntaxKind.ConstructSignature:
                        _type =
                          ts_estree_1.AST_NODE_TYPES
                            .TSConstructSignatureDeclaration
                        break

                      case SyntaxKind.CallSignature:
                        _type =
                          ts_estree_1.AST_NODE_TYPES.TSCallSignatureDeclaration
                        break

                      case SyntaxKind.FunctionType:
                        _type = ts_estree_1.AST_NODE_TYPES.TSFunctionType
                        break

                      case SyntaxKind.ConstructorType:
                      default:
                        _type = ts_estree_1.AST_NODE_TYPES.TSConstructorType
                        break
                    }

                    const _result23 = this.createNode(node, {
                      type: _type,
                      params: this.convertParameters(node.parameters),
                    })

                    if (node.type) {
                      _result23.returnType = this.convertTypeAnnotation(
                        node.type,
                        node
                      )
                    }

                    if (node.typeParameters) {
                      _result23.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(
                        node.typeParameters
                      )
                    }

                    return _result23
                  }

                  case SyntaxKind.ExpressionWithTypeArguments: {
                    const _result24 = this.createNode(node, {
                      type:
                        parent &&
                        parent.kind === SyntaxKind.InterfaceDeclaration
                          ? ts_estree_1.AST_NODE_TYPES.TSInterfaceHeritage
                          : ts_estree_1.AST_NODE_TYPES.TSClassImplements,
                      expression: this.convertChild(node.expression),
                    })

                    if (node.typeArguments) {
                      _result24.typeParameters = this.convertTypeArgumentsToTypeParameters(
                        node.typeArguments
                      )
                    }

                    return _result24
                  }

                  case SyntaxKind.InterfaceDeclaration: {
                    const interfaceHeritageClauses = node.heritageClauses || []

                    const _result25 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration,
                      body: this.createNode(node, {
                        type: ts_estree_1.AST_NODE_TYPES.TSInterfaceBody,
                        body: node.members.map(function(member) {
                          return _this7.convertChild(member)
                        }),
                        range: [node.members.pos - 1, node.end],
                      }),
                      id: this.convertChild(node.name),
                    })

                    if (node.typeParameters) {
                      _result25.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(
                        node.typeParameters
                      )
                    }

                    if (interfaceHeritageClauses.length > 0) {
                      const interfaceExtends = []
                      const interfaceImplements = []
                      let _iteratorNormalCompletion = true
                      let _didIteratorError = false
                      let _iteratorError

                      try {
                        for (
                          var _iterator = interfaceHeritageClauses[
                              Symbol.iterator
                            ](),
                            _step;
                          !(_iteratorNormalCompletion = (_step = _iterator.next())
                            .done);
                          _iteratorNormalCompletion = true
                        ) {
                          const heritageClause = _step.value

                          if (
                            heritageClause.token === SyntaxKind.ExtendsKeyword
                          ) {
                            let _iteratorNormalCompletion2 = true
                            let _didIteratorError2 = false
                            let _iteratorError2

                            try {
                              for (
                                var _iterator2 = heritageClause.types[
                                    Symbol.iterator
                                  ](),
                                  _step2;
                                !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next())
                                  .done);
                                _iteratorNormalCompletion2 = true
                              ) {
                                const n = _step2.value
                                interfaceExtends.push(
                                  this.convertChild(n, node)
                                )
                              }
                            } catch (error) {
                              _didIteratorError2 = true
                              _iteratorError2 = error
                            } finally {
                              try {
                                if (
                                  !_iteratorNormalCompletion2 &&
                                  _iterator2.return != null
                                ) {
                                  _iterator2.return()
                                }
                              } finally {
                                if (_didIteratorError2) {
                                  throw _iteratorError2
                                }
                              }
                            }
                          } else if (
                            heritageClause.token ===
                            SyntaxKind.ImplementsKeyword
                          ) {
                            let _iteratorNormalCompletion3 = true
                            let _didIteratorError3 = false
                            let _iteratorError3

                            try {
                              for (
                                var _iterator3 = heritageClause.types[
                                    Symbol.iterator
                                  ](),
                                  _step3;
                                !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next())
                                  .done);
                                _iteratorNormalCompletion3 = true
                              ) {
                                const _n = _step3.value
                                interfaceImplements.push(
                                  this.convertChild(_n, node)
                                )
                              }
                            } catch (error) {
                              _didIteratorError3 = true
                              _iteratorError3 = error
                            } finally {
                              try {
                                if (
                                  !_iteratorNormalCompletion3 &&
                                  _iterator3.return != null
                                ) {
                                  _iterator3.return()
                                }
                              } finally {
                                if (_didIteratorError3) {
                                  throw _iteratorError3
                                }
                              }
                            }
                          }
                        }
                      } catch (error) {
                        _didIteratorError = true
                        _iteratorError = error
                      } finally {
                        try {
                          if (
                            !_iteratorNormalCompletion &&
                            _iterator.return != null
                          ) {
                            _iterator.return()
                          }
                        } finally {
                          if (_didIteratorError) {
                            throw _iteratorError
                          }
                        }
                      }

                      if (interfaceExtends.length) {
                        _result25.extends = interfaceExtends
                      }

                      if (interfaceImplements.length) {
                        _result25.implements = interfaceImplements
                      }
                    }
                    /**
                     * Semantically, decorators are not allowed on interface declarations,
                     * but the TypeScript compiler will parse them and produce a valid AST,
                     * so we handle them here too.
                     */

                    if (node.decorators) {
                      _result25.decorators = node.decorators.map(function(
                        element
                      ) {
                        return _this7.convertChild(element)
                      })
                    }

                    if (
                      node_utils_1.hasModifier(SyntaxKind.AbstractKeyword, node)
                    ) {
                      _result25.abstract = true
                    }

                    if (
                      node_utils_1.hasModifier(SyntaxKind.DeclareKeyword, node)
                    ) {
                      _result25.declare = true
                    } // check for exports

                    return this.fixExports(node, _result25)
                  }

                  case SyntaxKind.TypePredicate: {
                    const _result26 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSTypePredicate,
                      asserts: node.assertsModifier !== undefined,
                      parameterName: this.convertChild(node.parameterName),
                      typeAnnotation: null,
                    })
                    /**
                     * Specific fix for type-guard location data
                     */

                    if (node.type) {
                      _result26.typeAnnotation = this.convertTypeAnnotation(
                        node.type,
                        node
                      )
                      _result26.typeAnnotation.loc =
                        _result26.typeAnnotation.typeAnnotation.loc
                      _result26.typeAnnotation.range =
                        _result26.typeAnnotation.typeAnnotation.range
                    }

                    return _result26
                  }

                  case SyntaxKind.ImportType:
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSImportType,
                      isTypeOf: !!node.isTypeOf,
                      parameter: this.convertChild(node.argument),
                      qualifier: this.convertChild(node.qualifier),
                      typeParameters: node.typeArguments
                        ? this.convertTypeArgumentsToTypeParameters(
                            node.typeArguments
                          )
                        : null,
                    })

                  case SyntaxKind.EnumDeclaration: {
                    const _result27 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSEnumDeclaration,
                      id: this.convertChild(node.name),
                      members: node.members.map(function(element) {
                        return _this7.convertChild(element)
                      }),
                    }) // apply modifiers first...

                    this.applyModifiersToResult(_result27, node.modifiers)
                    /**
                     * Semantically, decorators are not allowed on enum declarations,
                     * but the TypeScript compiler will parse them and produce a valid AST,
                     * so we handle them here too.
                     */

                    if (node.decorators) {
                      _result27.decorators = node.decorators.map(function(
                        element
                      ) {
                        return _this7.convertChild(element)
                      })
                    } // ...then check for exports

                    return this.fixExports(node, _result27)
                  }

                  case SyntaxKind.EnumMember: {
                    const _result28 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSEnumMember,
                      id: this.convertChild(node.name),
                    })

                    if (node.initializer) {
                      _result28.initializer = this.convertChild(
                        node.initializer
                      )
                    }

                    return _result28
                  }

                  case SyntaxKind.ModuleDeclaration: {
                    const _result29 = this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration,
                      id: this.convertChild(node.name),
                    })

                    if (node.body) {
                      _result29.body = this.convertChild(node.body)
                    } // apply modifiers first...

                    this.applyModifiersToResult(_result29, node.modifiers)

                    if (node.flags & ts.NodeFlags.GlobalAugmentation) {
                      _result29.global = true
                    } // ...then check for exports

                    return this.fixExports(node, _result29)
                  }
                  // TypeScript specific types

                  case SyntaxKind.OptionalType: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSOptionalType,
                      typeAnnotation: this.convertType(node.type),
                    })
                  }

                  case SyntaxKind.ParenthesizedType: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSParenthesizedType,
                      typeAnnotation: this.convertType(node.type),
                    })
                  }

                  case SyntaxKind.TupleType: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSTupleType,
                      elementTypes: node.elementTypes.map(function(element) {
                        return _this7.convertType(element)
                      }),
                    })
                  }

                  case SyntaxKind.UnionType: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSUnionType,
                      types: node.types.map(function(element) {
                        return _this7.convertType(element)
                      }),
                    })
                  }

                  case SyntaxKind.IntersectionType: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSIntersectionType,
                      types: node.types.map(function(element) {
                        return _this7.convertType(element)
                      }),
                    })
                  }

                  case SyntaxKind.RestType: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSRestType,
                      typeAnnotation: this.convertType(node.type),
                    })
                  }

                  case SyntaxKind.AsExpression: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSAsExpression,
                      expression: this.convertChild(node.expression),
                      typeAnnotation: this.convertType(node.type),
                    })
                  }

                  case SyntaxKind.InferType: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSInferType,
                      typeParameter: this.convertType(node.typeParameter),
                    })
                  }

                  case SyntaxKind.LiteralType: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSLiteralType,
                      literal: this.convertType(node.literal),
                    })
                  }

                  case SyntaxKind.TypeAssertionExpression: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSTypeAssertion,
                      typeAnnotation: this.convertType(node.type),
                      expression: this.convertChild(node.expression),
                    })
                  }

                  case SyntaxKind.ImportEqualsDeclaration: {
                    return this.createNode(node, {
                      type:
                        ts_estree_1.AST_NODE_TYPES.TSImportEqualsDeclaration,
                      id: this.convertChild(node.name),
                      moduleReference: this.convertChild(node.moduleReference),
                      isExport: node_utils_1.hasModifier(
                        SyntaxKind.ExportKeyword,
                        node
                      ),
                    })
                  }

                  case SyntaxKind.ExternalModuleReference: {
                    return this.createNode(node, {
                      type:
                        ts_estree_1.AST_NODE_TYPES.TSExternalModuleReference,
                      expression: this.convertChild(node.expression),
                    })
                  }

                  case SyntaxKind.NamespaceExportDeclaration: {
                    return this.createNode(node, {
                      type:
                        ts_estree_1.AST_NODE_TYPES.TSNamespaceExportDeclaration,
                      id: this.convertChild(node.name),
                    })
                  }

                  case SyntaxKind.AbstractKeyword: {
                    return this.createNode(node, {
                      type: ts_estree_1.AST_NODE_TYPES.TSAbstractKeyword,
                    })
                  }

                  default:
                    return this.deeplyCopy(node)
                }
              },
            },
          ])

          return Converter
        })()

      exports.Converter = Converter

      /** */
    },
    /* 140 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        5
      )
      /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        10
      )
      /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        11
      )
      /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        13
      )
      /* harmony import */ const core_js_modules_es_array_includes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
        34
      )
      /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
        4
      )
      /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5___default = /* #__PURE__ */ __webpack_require__.n(
        core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5__
      )
      /* harmony import */ const core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
        74
      )
      /* harmony import */ const core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_6___default = /* #__PURE__ */ __webpack_require__.n(
        core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_6__
      )
      /* harmony import */ const core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
        32
      )
      /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
        1
      )
      /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
        37
      )
      /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_9___default = /* #__PURE__ */ __webpack_require__.n(
        core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_9__
      )
      /* harmony import */ const core_js_modules_es_string_includes__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
        41
      )

      const __importDefault =
        (undefined && undefined.__importDefault) ||
        function(module_) {
          return module_ && module_.__esModule
            ? module_
            : {
                default: module_,
              }
        }

      const __importStar =
        (undefined && undefined.__importStar) ||
        function(module_) {
          if (module_ && module_.__esModule) {
            return module_
          }
          const result = {}
          if (module_ != null) {
            for (const k in module_) {
              if (Object.hasOwnProperty.call(module_, k)) {
                result[k] = module_[k]
              }
            }
          }
          result.default = module_
          return result
        }

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })

      const chokidar_1 = __importDefault(__webpack_require__(181))

      const path_1 = __importDefault(__webpack_require__(15))

      const ts = __importStar(__webpack_require__(47)) // leave this as * as ts so people using util package don't need syntheticDefaultImports
      //------------------------------------------------------------------------------
      // Environment calculation
      //------------------------------------------------------------------------------

      /**
       * Default compiler options for program generation from single root file
       */

      exports.defaultCompilerOptions = {
        allowNonTsExtensions: true,
        allowJs: true,
        checkJs: true,
        noEmit: true,
      }
      /**
       * Maps tsconfig paths to their corresponding file contents and resulting watches
       */

      const knownWatchProgramMap = new Map()
      /**
       * Maps file paths to their set of corresponding watch callbacks
       * There may be more than one per file if a file is shared between projects
       */

      const watchCallbackTrackingMap = new Map()
      /**
       * Tracks the ts.sys.watchFile watchers that we've opened for config files.
       * We store these so we can clean up our handles if required.
       */

      const configSystemFileWatcherTrackingSet = new Set()
      /**
       * Tracks the ts.sys.watchDirectory watchers that we've opened for project folders.
       * We store these so we can clean up our handles if required.
       */

      const directorySystemFileWatcherTrackingSet = new Set()
      const parsedFilesSeen = new Set()
      /**
       * Clear all of the parser caches.
       * This should only be used in testing to ensure the parser is clean between tests.
       */

      function clearCaches() {
        knownWatchProgramMap.clear()
        watchCallbackTrackingMap.clear()
        parsedFilesSeen.clear() // stop tracking config files

        configSystemFileWatcherTrackingSet.forEach(function(callback) {
          return callback.close()
        })
        configSystemFileWatcherTrackingSet.clear() // stop tracking folders

        directorySystemFileWatcherTrackingSet.forEach(function(callback) {
          return callback.close()
        })
        directorySystemFileWatcherTrackingSet.clear()
      }

      exports.clearCaches = clearCaches
      /**
       * Holds information about the file currently being linted
       */

      const currentLintOperationState = {
        code: '',
        filePath: '',
      }
      /**
       * Appropriately report issues found when reading a config file
       * @param diagnostic The diagnostic raised when creating a program
       */

      function diagnosticReporter(diagnostic) {
        throw new Error(
          ts.flattenDiagnosticMessageText(
            diagnostic.messageText,
            ts.sys.newLine
          )
        )
      }

      function getTsconfigPath(tsconfigPath, extra) {
        return path_1.default.isAbsolute(tsconfigPath)
          ? tsconfigPath
          : path_1.default.join(
              extra.tsconfigRootDir || process.cwd(),
              tsconfigPath
            )
      }
      /**
       * Watches a file or directory for changes
       */

      function watch(path, options, extra) {
        // an escape hatch to disable the file watchers as they can take a bit to initialise in some cases
        // this also supports an env variable so it's easy to switch on/off from the CLI
        if (process.env.PARSER_NO_WATCH === 'true' || extra.noWatch === true) {
          return {
            close: function close() {},
            on: function on() {},
          }
        }

        return chokidar_1.default.watch(path, {
          ignoreInitial: true,
          persistent: false,
          useFsEvents: false,
          ...options,
        })
      }
      /**
       * Calculate project environments using options provided by consumer and paths from config
       * @param code The code being linted
       * @param filePath The path of the file being parsed
       * @param extra.tsconfigRootDir The root directory for relative tsconfig paths
       * @param extra.projects Provided tsconfig paths
       * @returns The programs corresponding to the supplied tsconfig paths
       */

      function calculateProjectParserOptions(code, filePath, extra) {
        const results = [] // preserve reference to code and file being linted

        currentLintOperationState.code = code
        currentLintOperationState.filePath = filePath // Update file version if necessary
        // TODO: only update when necessary, currently marks as changed on every lint

        const watchCallbacks = watchCallbackTrackingMap.get(filePath)

        if (
          parsedFilesSeen.has(filePath) &&
          watchCallbacks &&
          watchCallbacks.size > 0
        ) {
          watchCallbacks.forEach(function(callback) {
            return callback(filePath, ts.FileWatcherEventKind.Changed)
          })
        }

        let _iteratorNormalCompletion = true
        let _didIteratorError = false
        let _iteratorError

        try {
          const _loop = function _loop() {
            const rawTsconfigPath = _step.value
            const tsconfigPath = getTsconfigPath(rawTsconfigPath, extra)
            const existingWatch = knownWatchProgramMap.get(tsconfigPath)

            if (typeof existingWatch !== 'undefined') {
              // get new program (updated if necessary)
              const updatedProgram = existingWatch.getProgram().getProgram()
              updatedProgram.getTypeChecker() // sets parent pointers in source files

              results.push(updatedProgram)
              return 'continue'
            } // create compiler host

            const watchCompilerHost = ts.createWatchCompilerHost(
              tsconfigPath,
              exports.defaultCompilerOptions,
              ts.sys,
              ts.createSemanticDiagnosticsBuilderProgram,
              diagnosticReporter,
              /* reportWatchStatus */
              function() {}
            ) // ensure readFile reads the code being linted instead of the copy on disk

            const oldReadFile = watchCompilerHost.readFile

            watchCompilerHost.readFile = function(filePath, encoding) {
              return path_1.default.normalize(filePath) ===
                path_1.default.normalize(currentLintOperationState.filePath)
                ? currentLintOperationState.code
                : oldReadFile(filePath, encoding)
            } // ensure process reports error on failure instead of exiting process immediately

            watchCompilerHost.onUnRecoverableConfigFileDiagnostic = diagnosticReporter // ensure process doesn't emit programs

            watchCompilerHost.afterProgramCreate = function(program) {
              // report error if there are any errors in the config file
              const configFileDiagnostics = program
                .getConfigFileParsingDiagnostics()
                .filter(function(diag) {
                  return (
                    diag.category === ts.DiagnosticCategory.Error &&
                    diag.code !== 18003
                  )
                })

              if (configFileDiagnostics.length > 0) {
                diagnosticReporter(configFileDiagnostics[0])
              }
            } // in watch mode, eslint will give us the latest file contents
            // store the watch callback so we can trigger an update with eslint's content

            watchCompilerHost.watchFile = function(
              fileName,
              callback,
              interval
            ) {
              // specifically (and separately) watch the tsconfig file
              // this allows us to react to changes in the tsconfig's include/exclude options
              let watcher = null

              if (fileName.includes(tsconfigPath)) {
                watcher = watch(
                  fileName,
                  {
                    interval,
                  },
                  extra
                )
                watcher.on('change', function(path) {
                  callback(path, ts.FileWatcherEventKind.Changed)
                })
                configSystemFileWatcherTrackingSet.add(watcher)
              }

              const normalizedFileName = path_1.default.normalize(fileName)

              const watchers = (function() {
                let watchers = watchCallbackTrackingMap.get(normalizedFileName)

                if (!watchers) {
                  watchers = new Set()
                  watchCallbackTrackingMap.set(normalizedFileName, watchers)
                }

                return watchers
              })()

              watchers.add(callback)
              return {
                close: function close() {
                  watchers.delete(callback)

                  if (watcher) {
                    watcher.close()
                    configSystemFileWatcherTrackingSet.delete(watcher)
                  }
                },
              }
            } // when new files are added in watch mode, we need to tell typescript about those files
            // if we don't then typescript will act like they don't exist.

            watchCompilerHost.watchDirectory = function(
              dirPath,
              callback,
              recursive
            ) {
              const watcher = watch(
                dirPath,
                {
                  depth: recursive ? 0 : undefined,
                  interval: 250,
                },
                extra
              )
              watcher.on('add', function(path) {
                callback(path)
              })
              directorySystemFileWatcherTrackingSet.add(watcher)
              return {
                close() {
                  watcher.close()
                  directorySystemFileWatcherTrackingSet.delete(watcher)
                },
              }
            } // allow files with custom extensions to be included in program (uses internal ts api)

            const oldOnDirectoryStructureHostCreate =
              watchCompilerHost.onCachedDirectoryStructureHostCreate

            watchCompilerHost.onCachedDirectoryStructureHostCreate = function(
              host
            ) {
              const oldReadDirectory = host.readDirectory

              host.readDirectory = function(
                path,
                extensions,
                exclude,
                include,
                depth
              ) {
                return oldReadDirectory(
                  path,
                  !extensions
                    ? undefined
                    : extensions.concat(extra.extraFileExtensions),
                  exclude,
                  include,
                  depth
                )
              }

              oldOnDirectoryStructureHostCreate(host)
            } // create program

            const programWatch = ts.createWatchProgram(watchCompilerHost)
            const program = programWatch.getProgram().getProgram() // cache watch program and return current program

            knownWatchProgramMap.set(tsconfigPath, programWatch)
            results.push(program)
          }

          for (
            var _iterator = extra.projects[Symbol.iterator](), _step;
            !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
            _iteratorNormalCompletion = true
          ) {
            const _returnValue = _loop()

            if (_returnValue === 'continue') {
              continue
            }
          }
        } catch (error) {
          _didIteratorError = true
          _iteratorError = error
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return()
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError
            }
          }
        }

        parsedFilesSeen.add(filePath)
        return results
      }

      exports.calculateProjectParserOptions = calculateProjectParserOptions
      /**
       * Create program from single root file. Requires a single tsconfig to be specified.
       * @param code The code being linted
       * @param filePath The file being linted
       * @param extra.tsconfigRootDir The root directory for relative tsconfig paths
       * @param extra.projects Provided tsconfig paths
       * @returns The program containing just the file being linted and associated library files
       */

      function createProgram(code, filePath, extra) {
        if (!extra.projects || extra.projects.length !== 1) {
          return undefined
        }

        const tsconfigPath = getTsconfigPath(extra.projects[0], extra)
        const commandLine = ts.getParsedCommandLineOfConfigFile(
          tsconfigPath,
          exports.defaultCompilerOptions,
          {
            ...ts.sys,
            onUnRecoverableConfigFileDiagnostic: function onUnRecoverableConfigFileDiagnostic() {},
          }
        )

        if (!commandLine) {
          return undefined
        }

        const compilerHost = ts.createCompilerHost(commandLine.options, true)
        const oldReadFile = compilerHost.readFile

        compilerHost.readFile = function(fileName) {
          return path_1.default.normalize(fileName) ===
            path_1.default.normalize(filePath)
            ? code
            : oldReadFile(fileName)
        }

        return ts.createProgram([filePath], commandLine.options, compilerHost)
      }

      exports.createProgram = createProgram

      /** */
    },
    /* 141 */
    /** */ function(module, exports, __webpack_require__) {
      const defineProperty = __webpack_require__(19).f

      const create = __webpack_require__(64)

      const redefineAll = __webpack_require__(68)

      const bind = __webpack_require__(54)

      const anInstance = __webpack_require__(71)

      const iterate = __webpack_require__(70)

      const defineIterator = __webpack_require__(119)

      const setSpecies = __webpack_require__(99)

      const DESCRIPTORS = __webpack_require__(18)

      const {fastKey} = __webpack_require__(69)

      const InternalStateModule = __webpack_require__(38)

      const setInternalState = InternalStateModule.set
      const internalStateGetterFor = InternalStateModule.getterFor
      module.exports = {
        getConstructor: function getConstructor(
          wrapper,
          CONSTRUCTOR_NAME,
          IS_MAP,
          ADDER
        ) {
          var C = wrapper(function(that, iterable) {
            anInstance(that, C, CONSTRUCTOR_NAME)
            setInternalState(that, {
              type: CONSTRUCTOR_NAME,
              index: create(null),
              first: undefined,
              last: undefined,
              size: 0,
            })
            if (!DESCRIPTORS) {
              that.size = 0
            }
            if (iterable != undefined) {
              iterate(iterable, that[ADDER], that, IS_MAP)
            }
          })
          const getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME)

          const define = function define(that, key, value) {
            const state = getInternalState(that)
            let entry = getEntry(that, key)
            let previous
            let index // change existing entry

            if (entry) {
              entry.value = value // create new entry
            } else {
              state.last = entry = {
                index: (index = fastKey(key, true)),
                key,
                value,
                previous: (previous = state.last),
                next: undefined,
                removed: false,
              }
              if (!state.first) {
                state.first = entry
              }
              if (previous) {
                previous.next = entry
              }
              if (DESCRIPTORS) {
                state.size++
              } else {
                that.size++
              } // add to index

              if (index !== 'F') {
                state.index[index] = entry
              }
            }

            return that
          }

          var getEntry = function getEntry(that, key) {
            const state = getInternalState(that) // fast case

            const index = fastKey(key)
            let entry
            if (index !== 'F') {
              return state.index[index]
            } // frozen object case

            for (entry = state.first; entry; entry = entry.next) {
              if (entry.key == key) {
                return entry
              }
            }
          }

          redefineAll(C.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function clear() {
              const that = this
              const state = getInternalState(that)
              const data = state.index
              let entry = state.first

              while (entry) {
                entry.removed = true
                if (entry.previous) {
                  entry.previous = entry.previous.next = undefined
                }
                delete data[entry.index]
                entry = entry.next
              }

              state.first = state.last = undefined
              if (DESCRIPTORS) {
                state.size = 0
              } else {
                that.size = 0
              }
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            delete: function _delete(key) {
              const that = this
              const state = getInternalState(that)
              const entry = getEntry(that, key)

              if (entry) {
                const {next} = entry
                const {previous} = entry
                delete state.index[entry.index]
                entry.removed = true
                if (previous) {
                  previous.next = next
                }
                if (next) {
                  next.previous = previous
                }
                if (state.first == entry) {
                  state.first = next
                }
                if (state.last == entry) {
                  state.last = previous
                }
                if (DESCRIPTORS) {
                  state.size--
                } else {
                  that.size--
                }
              }

              return !!entry
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function forEach(
              callbackfn
              /* , that = undefined */
            ) {
              const state = getInternalState(this)
              const boundFunction = bind(
                callbackfn,
                arguments.length > 1 ? arguments[1] : undefined,
                3
              )
              let entry

              while ((entry = entry ? entry.next : state.first)) {
                boundFunction(entry.value, entry.key, this) // revert to the last existing entry

                while (entry && entry.removed) {
                  entry = entry.previous
                }
              }
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function has(key) {
              return !!getEntry(this, key)
            },
          })
          redefineAll(
            C.prototype,
            IS_MAP
              ? {
                  // 23.1.3.6 Map.prototype.get(key)
                  get: function get(key) {
                    const entry = getEntry(this, key)
                    return entry && entry.value
                  },
                  // 23.1.3.9 Map.prototype.set(key, value)
                  set: function set(key, value) {
                    return define(this, key === 0 ? 0 : key, value)
                  },
                }
              : {
                  // 23.2.3.1 Set.prototype.add(value)
                  add: function add(value) {
                    return define(this, (value =
                      value === 0 ? 0 : value), value)
                  },
                }
          )
          if (DESCRIPTORS) {
            defineProperty(C.prototype, 'size', {
              get: function get() {
                return getInternalState(this).size
              },
            })
          }
          return C
        },
        setStrong: function setStrong(C, CONSTRUCTOR_NAME, IS_MAP) {
          const ITERATOR_NAME = `${CONSTRUCTOR_NAME} Iterator`
          const getInternalCollectionState = internalStateGetterFor(
            CONSTRUCTOR_NAME
          )
          const getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME) // add .keys, .values, .entries, [@@iterator]
          // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11

          defineIterator(
            C,
            CONSTRUCTOR_NAME,
            function(iterated, kind) {
              setInternalState(this, {
                type: ITERATOR_NAME,
                target: iterated,
                state: getInternalCollectionState(iterated),
                kind,
                last: undefined,
              })
            },
            function() {
              const state = getInternalIteratorState(this)
              const {kind} = state
              let entry = state.last // revert to the last existing entry

              while (entry && entry.removed) {
                entry = entry.previous
              } // get next entry

              if (
                !state.target ||
                !(state.last = entry = entry ? entry.next : state.state.first)
              ) {
                // or finish the iteration
                state.target = undefined
                return {
                  value: undefined,
                  done: true,
                }
              } // return step by kind

              if (kind == 'keys') {
                return {
                  value: entry.key,
                  done: false,
                }
              }
              if (kind == 'values') {
                return {
                  value: entry.value,
                  done: false,
                }
              }
              return {
                value: [entry.key, entry.value],
                done: false,
              }
            },
            IS_MAP ? 'entries' : 'values',
            !IS_MAP,
            true
          ) // add [@@species], 23.1.2.2, 23.2.2.2

          setSpecies(CONSTRUCTOR_NAME)
        },
      }

      /** */
    },
    /* 142 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          44
        )

        const global = __webpack_require__(8)

        module.exports = global.Promise
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 143 */
    /** */ function(module, exports, __webpack_require__) {
      const anObject = __webpack_require__(17)

      const isObject = __webpack_require__(12)

      const newPromiseCapability = __webpack_require__(144)

      module.exports = function(C, x) {
        anObject(C)
        if (isObject(x) && x.constructor === C) {
          return x
        }
        const promiseCapability = newPromiseCapability.f(C)
        const {resolve} = promiseCapability
        resolve(x)
        return promiseCapability.promise
      }

      /** */
    },
    /* 144 */
    /** */ function(module, exports, __webpack_require__) {
      const aFunction = __webpack_require__(55)

      const PromiseCapability = function PromiseCapability(C) {
        let resolve
        let reject
        this.promise = new C(function($$resolve, $$reject) {
          if (resolve !== undefined || reject !== undefined) {
            throw new TypeError('Bad Promise constructor')
          }
          resolve = $$resolve
          reject = $$reject
        })
        this.resolve = aFunction(resolve)
        this.reject = aFunction(reject)
      } // 25.4.1.5 NewPromiseCapability(C)

      module.exports.f = function(C) {
        return new PromiseCapability(C)
      }

      /** */
    },
    /* 145 */
    /** */ function(module, exports, __webpack_require__) {
      const global = __webpack_require__(8)

      const fails = __webpack_require__(9)

      const classof = __webpack_require__(33)

      const bind = __webpack_require__(54)

      const html = __webpack_require__(117)

      const createElement = __webpack_require__(80)

      const {location} = global
      let set = global.setImmediate
      let clear = global.clearImmediate
      const {process} = global
      const {MessageChannel} = global
      const {Dispatch} = global
      let counter = 0
      const queue = {}
      const ONREADYSTATECHANGE = 'onreadystatechange'
      let defer
      let channel
      let port

      const run = function run(id) {
        // eslint-disable-next-line no-prototype-builtins
        if (queue.hasOwnProperty(id)) {
          const fn = queue[id]
          delete queue[id]
          fn()
        }
      }

      const runner = function runner(id) {
        return function() {
          run(id)
        }
      }

      const listener = function listener(event) {
        run(event.data)
      }

      const post = function post(id) {
        // old engines have not location.origin
        global.postMessage(String(id), `${location.protocol}//${location.host}`)
      } // Node.js 0.9+ & IE10+ has setImmediate, otherwise:

      if (!set || !clear) {
        set = function setImmediate(fn) {
          const arguments_ = []
          let i = 1

          while (arguments.length > i) {
            arguments_.push(arguments[i++])
          }

          queue[++counter] = function() {
            // eslint-disable-next-line no-new-func
            ;(typeof fn === 'function' ? fn : new Function(fn)).apply(
              undefined,
              arguments_
            )
          }

          defer(counter)
          return counter
        }

        clear = function clearImmediate(id) {
          delete queue[id]
        } // Node.js 0.8-

        if (classof(process) == 'process') {
          defer = function defer(id) {
            process.nextTick(runner(id))
          } // Sphere (JS game engine) Dispatch API
        } else if (Dispatch && Dispatch.now) {
          defer = function defer(id) {
            Dispatch.now(runner(id))
          } // Browsers with MessageChannel, includes WebWorkers
        } else if (MessageChannel) {
          channel = new MessageChannel()
          port = channel.port2
          channel.port1.onmessage = listener
          defer = bind(port.postMessage, port, 1) // Browsers with postMessage, skip WebWorkers
          // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
        } else if (
          global.addEventListener &&
          typeof postMessage === 'function' &&
          !global.importScripts &&
          !fails(post)
        ) {
          defer = post
          global.addEventListener('message', listener, false) // IE8-
        } else if (ONREADYSTATECHANGE in createElement('script')) {
          defer = function defer(id) {
            html.appendChild(createElement('script'))[
              ONREADYSTATECHANGE
            ] = function() {
              html.removeChild(this)
              run(id)
            }
          } // Rest old browsers
        } else {
          defer = function defer(id) {
            setTimeout(runner(id), 0)
          }
        }
      }

      module.exports = {
        set,
        clear,
      }

      /** */
    },
    /* 146 */
    /** */ function(module, exports, __webpack_require__) {
      module.exports = __webpack_require__(191)

      /** */
    },
    /* 147 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        2
      )
      /* harmony import */ const core_js_modules_es_string_starts_with__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        147
      )

      const $ = __webpack_require__(6)

      const toLength = __webpack_require__(22)

      const notARegExp = __webpack_require__(129)

      const requireObjectCoercible = __webpack_require__(26)

      const correctIsRegExpLogic = __webpack_require__(130)

      const nativeStartsWith = ''.startsWith
      const {min} = Math // `String.prototype.startsWith` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.startswith

      $(
        {
          target: 'String',
          proto: true,
          forced: !correctIsRegExpLogic('startsWith'),
        },
        {
          startsWith: function startsWith(
            searchString
            /* , position = 0 */
          ) {
            const that = String(requireObjectCoercible(this))
            notARegExp(searchString)
            const index = toLength(
              min(arguments.length > 1 ? arguments[1] : undefined, that.length)
            )
            const search = String(searchString)
            return nativeStartsWith
              ? nativeStartsWith.call(that, search, index)
              : that.slice(index, index + search.length) === search
          },
        }
      )

      /** */
    },
    /* 148 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          24
        )

        /*!
         * normalize-path <https://github.com/jonschlinkert/normalize-path>
         *
         * Copyright (c) 2014-2018, Jon Schlinkert.
         * Released under the MIT License.
         */
        module.exports = function(path, stripTrailing) {
          if (typeof path !== 'string') {
            throw new TypeError('expected path to be a string')
          }

          if (path === '\\' || path === '/') {
            return '/'
          }
          const length_ = path.length
          if (length_ <= 1) {
            return path
          } // ensure that win32 namespaces has two leading slashes, so that the path is
          // handled properly by the win32 version of path.parse() after being normalized
          // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces

          let prefix = ''

          if (length_ > 4 && path[3] === '\\') {
            const ch = path[2]

            if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
              path = path.slice(2)
              prefix = '//'
            }
          }

          const segs = path.split(/[/\\]+/)

          if (stripTrailing !== false && segs[segs.length - 1] === '') {
            segs.pop()
          }

          return prefix + segs.join('/')
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 149 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          13
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_array_sort__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          42
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          43
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_4___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_4__
        )
        /* harmony import */ const core_js_modules_es_string_pad_start__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          199
        )
        /* harmony import */ const core_js_modules_es_string_pad_start__WEBPACK_IMPORTED_MODULE_5___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_string_pad_start__WEBPACK_IMPORTED_MODULE_5__
        )
        /*!
         * fill-range <https://github.com/jonschlinkert/fill-range>
         *
         * Copyright (c) 2014-present, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        function ownKeys(object, enumerableOnly) {
          const keys = Object.keys(object)
          if (Object.getOwnPropertySymbols) {
            let symbols = Object.getOwnPropertySymbols(object)
            if (enumerableOnly) {
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable
              })
            }
            keys.push.apply(keys, symbols)
          }
          return keys
        }

        function _objectSpread(target) {
          for (let i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {}
            if (i % 2) {
              ownKeys(source, true).forEach(function(key) {
                _defineProperty(target, key, source[key])
              })
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(
                target,
                Object.getOwnPropertyDescriptors(source)
              )
            } else {
              ownKeys(source).forEach(function(key) {
                Object.defineProperty(
                  target,
                  key,
                  Object.getOwnPropertyDescriptor(source, key)
                )
              })
            }
          }
          return target
        }

        function _defineProperty(object, key, value) {
          if (key in object) {
            Object.defineProperty(object, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true,
            })
          } else {
            object[key] = value
          }
          return object
        }

        const util = __webpack_require__(36)

        const toRegexRange = __webpack_require__(203)

        const isObject = function isObject(value) {
          return (
            value !== null && typeof value === 'object' && !Array.isArray(value)
          )
        }

        const transform = function transform(toNumber) {
          return function(value) {
            return toNumber === true ? Number(value) : String(value)
          }
        }

        const isValidValue = function isValidValue(value) {
          return (
            typeof value === 'number' ||
            (typeof value === 'string' && value !== '')
          )
        }

        const isNumber = function isNumber(number) {
          return Number.isInteger(Number(number))
        }

        const zeros = function zeros(input) {
          let value = `${input}`
          let index = -1
          if (value[0] === '-') {
            value = value.slice(1)
          }
          if (value === '0') {
            return false
          }

          while (value[++index] === '0') {}

          return index > 0
        }

        const stringify = function stringify(start, end, options) {
          if (typeof start === 'string' || typeof end === 'string') {
            return true
          }

          return options.stringify === true
        }

        const pad = function pad(input, maxLength, toNumber) {
          if (maxLength > 0) {
            const dash = input[0] === '-' ? '-' : ''
            if (dash) {
              input = input.slice(1)
            }
            input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0')
          }

          if (toNumber === false) {
            return String(input)
          }

          return input
        }

        const toMaxLength = function toMaxLength_(input, maxLength) {
          const negative = input[0] === '-' ? '-' : ''

          if (negative) {
            input = input.slice(1)
            maxLength--
          }

          while (input.length < maxLength) {
            input = `0${input}`
          }

          return negative ? `-${input}` : input
        }

        const toSequence = function toSequence(parts, options) {
          parts.negatives.sort(function(a, b) {
            return a < b ? -1 : a > b ? 1 : 0
          })
          parts.positives.sort(function(a, b) {
            return a < b ? -1 : a > b ? 1 : 0
          })
          const prefix = options.capture ? '' : '?:'
          let positives = ''
          let negatives = ''
          let result

          if (parts.positives.length) {
            positives = parts.positives.join('|')
          }

          if (parts.negatives.length) {
            negatives = `-(${prefix}${parts.negatives.join('|')})`
          }

          if (positives && negatives) {
            result = `${positives}|${negatives}`
          } else {
            result = positives || negatives
          }

          if (options.wrap) {
            return `(${prefix}${result})`
          }

          return result
        }

        const toRange = function toRange(a, b, isNumbers, options) {
          if (isNumbers) {
            return toRegexRange(
              a,
              b,
              _objectSpread(
                {
                  wrap: false,
                },
                options
              )
            )
          }

          const start = String.fromCharCode(a)
          if (a === b) {
            return start
          }
          const stop = String.fromCharCode(b)
          return `[${start}-${stop}]`
        }

        const toRegex = function toRegex(start, end, options) {
          if (Array.isArray(start)) {
            const wrap = options.wrap === true
            const prefix = options.capture ? '' : '?:'
            return wrap ? `(${prefix}${start.join('|')})` : start.join('|')
          }

          return toRegexRange(start, end, options)
        }

        const rangeError = function rangeError() {
          return new RangeError(
            `Invalid range arguments: ${util.inspect.apply(util, arguments)}`
          )
        }

        const invalidRange = function invalidRange(start, end, options) {
          if (options.strictRanges === true) {
            throw rangeError([start, end])
          }
          return []
        }

        const invalidStep = function invalidStep(step, options) {
          if (options.strictRanges === true) {
            throw new TypeError(`Expected step "${step}" to be a number`)
          }

          return []
        }

        const fillNumbers = function fillNumbers(start, end) {
          let step =
            arguments.length > 2 && arguments[2] !== undefined
              ? arguments[2]
              : 1
          const options =
            arguments.length > 3 && arguments[3] !== undefined
              ? arguments[3]
              : {}
          let a = Number(start)
          let b = Number(end)

          if (!Number.isInteger(a) || !Number.isInteger(b)) {
            if (options.strictRanges === true) {
              throw rangeError([start, end])
            }
            return []
          } // fix negative zero

          if (a === 0) {
            a = 0
          }
          if (b === 0) {
            b = 0
          }
          const descending = a > b
          const startString = String(start)
          const endString = String(end)
          const stepString = String(step)
          step = Math.max(Math.abs(step), 1)
          const padded =
            zeros(startString) || zeros(endString) || zeros(stepString)
          const maxLength = padded
            ? Math.max(startString.length, endString.length, stepString.length)
            : 0
          const toNumber =
            padded === false && stringify(start, end, options) === false
          const format = options.transform || transform(toNumber)

          if (options.toRegex && step === 1) {
            return toRange(
              toMaxLength(start, maxLength),
              toMaxLength(end, maxLength),
              true,
              options
            )
          }

          const parts = {
            negatives: [],
            positives: [],
          }

          const push = function push(number) {
            return parts[number < 0 ? 'negatives' : 'positives'].push(
              Math.abs(number)
            )
          }

          const range = []
          let index = 0

          while (descending ? a >= b : a <= b) {
            if (options.toRegex === true && step > 1) {
              push(a)
            } else {
              range.push(pad(format(a, index), maxLength, toNumber))
            }

            a = descending ? a - step : a + step
            index++
          }

          if (options.toRegex === true) {
            return step > 1
              ? toSequence(parts, options)
              : toRegex(
                  range,
                  null,
                  _objectSpread(
                    {
                      wrap: false,
                    },
                    options
                  )
                )
          }

          return range
        }

        const fillLetters = function fillLetters(start, end) {
          const step =
            arguments.length > 2 && arguments[2] !== undefined
              ? arguments[2]
              : 1
          const options =
            arguments.length > 3 && arguments[3] !== undefined
              ? arguments[3]
              : {}

          if (
            (!isNumber(start) && start.length > 1) ||
            (!isNumber(end) && end.length > 1)
          ) {
            return invalidRange(start, end, options)
          }

          const format =
            options.transform ||
            function(value) {
              return String.fromCharCode(value)
            }

          let a = `${start}`.charCodeAt(0)
          const b = `${end}`.charCodeAt(0)
          const descending = a > b
          const min = Math.min(a, b)
          const max = Math.max(a, b)

          if (options.toRegex && step === 1) {
            return toRange(min, max, false, options)
          }

          const range = []
          let index = 0

          while (descending ? a >= b : a <= b) {
            range.push(format(a, index))
            a = descending ? a - step : a + step
            index++
          }

          if (options.toRegex === true) {
            return toRegex(range, null, {
              wrap: false,
              options,
            })
          }

          return range
        }

        const fill = function fill(start, end, step) {
          const options =
            arguments.length > 3 && arguments[3] !== undefined
              ? arguments[3]
              : {}

          if (end == null && isValidValue(start)) {
            return [start]
          }

          if (!isValidValue(start) || !isValidValue(end)) {
            return invalidRange(start, end, options)
          }

          if (typeof step === 'function') {
            return fill(start, end, 1, {
              transform: step,
            })
          }

          if (isObject(step)) {
            return fill(start, end, 0, step)
          }

          const options_ = _objectSpread({}, options)

          if (options_.capture === true) {
            options_.wrap = true
          }
          step = step || options_.step || 1

          if (!isNumber(step)) {
            if (step != null && !isObject(step)) {
              return invalidStep(step, options_)
            }
            return fill(start, end, 1, step)
          }

          if (isNumber(start) && isNumber(end)) {
            return fillNumbers(start, end, step, options_)
          }

          return fillLetters(start, end, Math.max(Math.abs(step), 1), options_)
        }

        module.exports = fill
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 150 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        11
      )
      /* harmony import */ const core_js_modules_es_array_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        34
      )
      /* harmony import */ const core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        32
      )
      /* harmony import */ const core_js_modules_es_string_includes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        41
      )

      function __export(m) {
        for (const p in m) {
          if (!exports.hasOwnProperty(p)) {
            exports[p] = m[p]
          }
        }
      }

      const __importDefault =
        (undefined && undefined.__importDefault) ||
        function(module_) {
          return module_ && module_.__esModule
            ? module_
            : {
                default: module_,
              }
        }

      const __importStar =
        (undefined && undefined.__importStar) ||
        function(module_) {
          if (module_ && module_.__esModule) {
            return module_
          }
          const result = {}
          if (module_ != null) {
            for (const k in module_) {
              if (Object.hasOwnProperty.call(module_, k)) {
                result[k] = module_[k]
              }
            }
          }
          result.default = module_
          return result
        }

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })

      const path_1 = __importDefault(__webpack_require__(15))

      const semver_1 = __importDefault(__webpack_require__(162))

      const ts = __importStar(__webpack_require__(47)) // leave this as * as ts so people using util package don't need syntheticDefaultImports

      const glob_1 = __webpack_require__(132)

      const is_glob_1 = __importDefault(__webpack_require__(103))

      const ast_converter_1 = __webpack_require__(174)

      const convert_1 = __webpack_require__(139)

      const node_utils_1 = __webpack_require__(73)

      const semantic_or_syntactic_errors_1 = __webpack_require__(180)

      const tsconfig_parser_1 = __webpack_require__(140)
      /**
       * This needs to be kept in sync with the top-level README.md in the
       * typescript-eslint monorepo
       */

      const SUPPORTED_TYPESCRIPT_VERSIONS = '>=3.2.1 <3.8.0'
      const ACTIVE_TYPESCRIPT_VERSION = ts.version
      const isRunningSupportedTypeScriptVersion = semver_1.default.satisfies(
        ACTIVE_TYPESCRIPT_VERSION,
        SUPPORTED_TYPESCRIPT_VERSIONS
      )
      let extra
      let warnedAboutTSVersion = false
      /**
       * Compute the filename based on the parser options.
       *
       * Even if jsx option is set in typescript compiler, filename still has to
       * contain .tsx file extension.
       *
       * @param options Parser options
       */

      function getFileName(_reference) {
        const {jsx} = _reference
        return jsx ? 'estree.tsx' : 'estree.ts'
      }
      /**
       * Resets the extra config object
       */

      function resetExtra() {
        extra = {
          code: '',
          comment: false,
          comments: [],
          createDefaultProgram: false,
          errorOnTypeScriptSyntacticAndSemanticIssues: false,
          errorOnUnknownASTType: false,
          extraFileExtensions: [],
          jsx: false,
          loc: false,
          log: console.log,
          noWatch: false,
          preserveNodeMaps: undefined,
          projects: [],
          range: false,
          strict: false,
          tokens: null,
          tsconfigRootDir: process.cwd(),
          useJSXTextNode: false,
        }
      }
      /**
       * @param code The code of the file being linted
       * @param options The config object
       * @returns If found, returns the source file corresponding to the code and the containing program
       */

      function getASTFromProject(code, options, createDefaultProgram) {
        const filePath = options.filePath || getFileName(options)
        const astAndProgram = node_utils_1.firstDefined(
          tsconfig_parser_1.calculateProjectParserOptions(
            code,
            filePath,
            extra
          ),
          function(currentProgram) {
            const ast = currentProgram.getSourceFile(filePath)
            return (
              ast && {
                ast,
                program: currentProgram,
              }
            )
          }
        )

        if (!astAndProgram && !createDefaultProgram) {
          // the file was either not matched within the tsconfig, or the extension wasn't expected
          const errorLines = [
            '"parserOptions.project" has been set for @typescript-eslint/parser.',
            `The file does not match your project config: ${filePath}.`,
          ]
          let hasMatchedAnError = false
          const fileExtension = path_1.default.extname(filePath)

          if (!['.ts', '.tsx', '.js', '.jsx'].includes(fileExtension)) {
            const nonStandardExtension = `The extension for the file (${fileExtension}) is non-standard`

            if (
              extra.extraFileExtensions &&
              extra.extraFileExtensions.length > 0
            ) {
              if (!extra.extraFileExtensions.includes(fileExtension)) {
                errorLines.push(
                  `${nonStandardExtension}. It should be added to your existing "parserOptions.extraFileExtensions".`
                )
                hasMatchedAnError = true
              }
            } else {
              errorLines.push(
                `${nonStandardExtension}. You should add "parserOptions.extraFileExtensions" to your config.`
              )
              hasMatchedAnError = true
            }
          }

          if (!hasMatchedAnError) {
            errorLines.push(
              'The file must be included in at least one of the projects provided.'
            )
            hasMatchedAnError = true
          }

          throw new Error(errorLines.join('\n'))
        }

        return astAndProgram
      }
      /**
       * @param code The code of the file being linted
       * @param options The config object
       * @returns If found, returns the source file corresponding to the code and the containing program
       */

      function getASTAndDefaultProject(code, options) {
        const fileName = options.filePath || getFileName(options)
        const program = tsconfig_parser_1.createProgram(code, fileName, extra)
        const ast = program && program.getSourceFile(fileName)
        return (
          ast && {
            ast,
            program,
          }
        )
      }
      /**
       * @param code The code of the file being linted
       * @returns Returns a new source file and program corresponding to the linted code
       */

      function createNewProgram(code) {
        const FILENAME = getFileName(extra)
        const compilerHost = {
          fileExists() {
            return true
          },

          getCanonicalFileName() {
            return FILENAME
          },

          getCurrentDirectory() {
            return ''
          },

          getDirectories() {
            return []
          },

          getDefaultLibFileName() {
            return 'lib.d.ts'
          },

          // TODO: Support Windows CRLF
          getNewLine() {
            return '\n'
          },

          getSourceFile(filename) {
            return ts.createSourceFile(
              filename,
              code,
              ts.ScriptTarget.Latest,
              true
            )
          },

          readFile() {
            return undefined
          },

          useCaseSensitiveFileNames() {
            return true
          },

          writeFile() {
            return null
          },
        }
        const program = ts.createProgram(
          [FILENAME],
          {
            noResolve: true,
            target: ts.ScriptTarget.Latest,
            jsx: extra.jsx ? ts.JsxEmit.Preserve : undefined,
            ...tsconfig_parser_1.defaultCompilerOptions,
          },
          compilerHost
        )
        const ast = program.getSourceFile(FILENAME)
        return {
          ast,
          program,
        }
      }
      /**
       * @param code The code of the file being linted
       * @param options The config object
       * @param shouldProvideParserServices True iff the program should be attempted to be calculated from provided tsconfig files
       * @returns Returns a source file and program corresponding to the linted code
       */

      function getProgramAndAST(
        code,
        options,
        shouldProvideParserServices,
        createDefaultProgram
      ) {
        return (
          (shouldProvideParserServices &&
            getASTFromProject(code, options, createDefaultProgram)) ||
          (shouldProvideParserServices &&
            createDefaultProgram &&
            getASTAndDefaultProject(code, options)) ||
          createNewProgram(code)
        )
      }

      function applyParserOptionsToExtra(options) {
        extra.noWatch = typeof options.noWatch === 'boolean' && options.noWatch
        /**
         * Track range information in the AST
         */

        extra.range = typeof options.range === 'boolean' && options.range
        extra.loc = typeof options.loc === 'boolean' && options.loc
        /**
         * Track tokens in the AST
         */

        if (typeof options.tokens === 'boolean' && options.tokens) {
          extra.tokens = []
        }
        /**
         * Track comments in the AST
         */

        if (typeof options.comment === 'boolean' && options.comment) {
          extra.comment = true
          extra.comments = []
        }
        /**
         * Enable JSX - note the applicable file extension is still required
         */

        if (typeof options.jsx === 'boolean' && options.jsx) {
          extra.jsx = true
        }
        /**
         * The JSX AST changed the node type for string literals
         * inside a JSX Element from `Literal` to `JSXText`.
         *
         * When value is `true`, these nodes will be parsed as type `JSXText`.
         * When value is `false`, these nodes will be parsed as type `Literal`.
         */

        if (
          typeof options.useJSXTextNode === 'boolean' &&
          options.useJSXTextNode
        ) {
          extra.useJSXTextNode = true
        }
        /**
         * Allow the user to cause the parser to error if it encounters an unknown AST Node Type
         * (used in testing)
         */

        if (
          typeof options.errorOnUnknownASTType === 'boolean' &&
          options.errorOnUnknownASTType
        ) {
          extra.errorOnUnknownASTType = true
        }
        /**
         * Allow the user to override the function used for logging
         */

        if (typeof options.loggerFn === 'function') {
          extra.log = options.loggerFn
        } else if (options.loggerFn === false) {
          extra.log = Function.prototype
        }

        if (typeof options.project === 'string') {
          extra.projects = [options.project]
        } else if (
          Array.isArray(options.project) &&
          options.project.every(function(projectPath) {
            return typeof projectPath === 'string'
          })
        ) {
          extra.projects = options.project
        }

        if (typeof options.tsconfigRootDir === 'string') {
          extra.tsconfigRootDir = options.tsconfigRootDir
        } // Transform glob patterns into paths

        if (extra.projects) {
          extra.projects = extra.projects.reduce(function(projects, project) {
            return projects.concat(
              is_glob_1.default(project)
                ? glob_1.sync(project, {
                    cwd: extra.tsconfigRootDir || process.cwd(),
                  })
                : project
            )
          }, [])
        }

        if (
          Array.isArray(options.extraFileExtensions) &&
          options.extraFileExtensions.every(function(extension) {
            return typeof extension === 'string'
          })
        ) {
          extra.extraFileExtensions = options.extraFileExtensions
        }
        /**
         * Allow the user to enable or disable the preservation of the AST node maps
         * during the conversion process.
         *
         * NOTE: For backwards compatibility we also preserve node maps in the case where `project` is set,
         * and `preserveNodeMaps` is not explicitly set to anything.
         */

        extra.preserveNodeMaps =
          typeof options.preserveNodeMaps === 'boolean' &&
          options.preserveNodeMaps

        if (
          options.preserveNodeMaps === undefined &&
          extra.projects.length > 0
        ) {
          extra.preserveNodeMaps = true
        }

        extra.createDefaultProgram =
          typeof options.createDefaultProgram === 'boolean' &&
          options.createDefaultProgram
      }

      function warnAboutTSVersion() {
        if (!isRunningSupportedTypeScriptVersion && !warnedAboutTSVersion) {
          const border = '============='
          const versionWarning = [
            border,
            'WARNING: You are currently running a version of TypeScript which is not officially supported by typescript-estree.',
            'You may find that it works just fine, or you may not.',
            `SUPPORTED TYPESCRIPT VERSIONS: ${SUPPORTED_TYPESCRIPT_VERSIONS}`,
            `YOUR TYPESCRIPT VERSION: ${ACTIVE_TYPESCRIPT_VERSION}`,
            'Please only submit bug reports when using the officially supported version.',
            border,
          ]
          extra.log(versionWarning.join('\n\n'))
          warnedAboutTSVersion = true
        }
      } //------------------------------------------------------------------------------
      // Public
      //------------------------------------------------------------------------------

      exports.version = __webpack_require__(214).version

      function parse(code, options) {
        /**
         * Reset the parse configuration
         */
        resetExtra()
        /**
         * Ensure users do not attempt to use parse() when they need parseAndGenerateServices()
         */

        if (options && options.errorOnTypeScriptSyntacticAndSemanticIssues) {
          throw new Error(
            `"errorOnTypeScriptSyntacticAndSemanticIssues" is only supported for parseAndGenerateServices()`
          )
        }
        /**
         * Ensure the source code is a string, and store a reference to it
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any

        if (typeof code !== 'string' && !(code instanceof String)) {
          code = String(code)
        }

        extra.code = code
        /**
         * Apply the given parser options
         */

        if (typeof options !== 'undefined') {
          applyParserOptionsToExtra(options)
        }
        /**
         * Warn if the user is using an unsupported version of TypeScript
         */

        warnAboutTSVersion()
        /**
         * Create a ts.SourceFile directly, no ts.Program is needed for a simple
         * parse
         */

        const ast = ts.createSourceFile(
          getFileName(extra),
          code,
          ts.ScriptTarget.Latest,
          /* setParentNodes */
          true
        )
        /**
         * Convert the TypeScript AST to an ESTree-compatible one
         */

        const _ast_converter_1$astC = ast_converter_1.astConverter(
          ast,
          extra,
          false
        )
        const {estree} = _ast_converter_1$astC

        return estree
      }

      exports.parse = parse

      function parseAndGenerateServices(code, options) {
        /**
         * Reset the parse configuration
         */
        resetExtra()
        /**
         * Ensure the source code is a string, and store a reference to it
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any

        if (typeof code !== 'string' && !(code instanceof String)) {
          code = String(code)
        }

        extra.code = code
        /**
         * Apply the given parser options
         */

        if (typeof options !== 'undefined') {
          applyParserOptionsToExtra(options)

          if (
            typeof options.errorOnTypeScriptSyntacticAndSemanticIssues ===
              'boolean' &&
            options.errorOnTypeScriptSyntacticAndSemanticIssues
          ) {
            extra.errorOnTypeScriptSyntacticAndSemanticIssues = true
          }
        }
        /**
         * Warn if the user is using an unsupported version of TypeScript
         */

        warnAboutTSVersion()
        /**
         * Generate a full ts.Program in order to be able to provide parser
         * services, such as type-checking
         */

        const shouldProvideParserServices =
          extra.projects && extra.projects.length > 0

        const _getProgramAndAST = getProgramAndAST(
          code,
          options,
          shouldProvideParserServices,
          extra.createDefaultProgram
        )
        const {ast} = _getProgramAndAST
        const {program} = _getProgramAndAST
        /**
         * Determine whether or not two-way maps of converted AST nodes should be preserved
         * during the conversion process
         */

        const shouldPreserveNodeMaps =
          extra.preserveNodeMaps !== undefined
            ? extra.preserveNodeMaps
            : shouldProvideParserServices
        /**
         * Convert the TypeScript AST to an ESTree-compatible one, and optionally preserve
         * mappings between converted and original AST nodes
         */

        const _ast_converter_1$astC2 = ast_converter_1.astConverter(
          ast,
          extra,
          shouldPreserveNodeMaps
        )
        const {estree} = _ast_converter_1$astC2
        const {astMaps} = _ast_converter_1$astC2
        /**
         * Even if TypeScript parsed the source code ok, and we had no problems converting the AST,
         * there may be other syntactic or semantic issues in the code that we can optionally report on.
         */

        if (program && extra.errorOnTypeScriptSyntacticAndSemanticIssues) {
          const error = semantic_or_syntactic_errors_1.getFirstSemanticOrSyntacticError(
            program,
            ast
          )

          if (error) {
            throw convert_1.convertError(error)
          }
        }
        /**
         * Return the converted AST and additional parser services
         */

        return {
          ast: estree,
          services: {
            program: shouldProvideParserServices ? program : undefined,
            esTreeNodeToTSNodeMap:
              shouldPreserveNodeMaps && astMaps
                ? astMaps.esTreeNodeToTSNodeMap
                : undefined,
            tsNodeToESTreeNodeMap:
              shouldPreserveNodeMaps && astMaps
                ? astMaps.tsNodeToESTreeNodeMap
                : undefined,
          },
        }
      }

      exports.parseAndGenerateServices = parseAndGenerateServices

      __export(__webpack_require__(104))

      const tsconfig_parser_2 = __webpack_require__(140)

      exports.clearCaches = tsconfig_parser_2.clearCaches

      /** */
    },
    /* 151 */
    /** */ function(module, exports, __webpack_require__) {
      const DESCRIPTORS = __webpack_require__(18)

      const definePropertyModule = __webpack_require__(19)

      const anObject = __webpack_require__(17)

      const objectKeys = __webpack_require__(88) // `Object.defineProperties` method
      // https://tc39.github.io/ecma262/#sec-object.defineproperties

      module.exports = DESCRIPTORS
        ? Object.defineProperties
        : function defineProperties(O, Properties) {
            anObject(O)
            const keys = objectKeys(Properties)
            const {length} = keys
            let index = 0
            let key

            while (length > index) {
              definePropertyModule.f(O, (key = keys[index++]), Properties[key])
            }

            return O
          }

      /** */
    },
    /* 152 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          1
        )

        const toIndexedObject = __webpack_require__(29)

        const nativeGetOwnPropertyNames = __webpack_require__(63).f

        const {toString} = {}
        const windowNames =
          typeof window === 'object' && window && Object.getOwnPropertyNames
            ? Object.getOwnPropertyNames(window)
            : []

        const getWindowNames = function getWindowNames(it) {
          try {
            return nativeGetOwnPropertyNames(it)
          } catch (error) {
            return windowNames.slice()
          }
        } // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window

        module.exports.f = function getOwnPropertyNames(it) {
          return windowNames && toString.call(it) == '[object Window]'
            ? getWindowNames(it)
            : nativeGetOwnPropertyNames(toIndexedObject(it))
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 153 */
    /** */ function(module, exports, __webpack_require__) {
      const {IteratorPrototype} = __webpack_require__(120)

      const create = __webpack_require__(64)

      const createPropertyDescriptor = __webpack_require__(50)

      const setToStringTag = __webpack_require__(40)

      const Iterators = __webpack_require__(56)

      const returnThis = function returnThis() {
        return this
      }

      module.exports = function(IteratorConstructor, NAME, next) {
        const TO_STRING_TAG = `${NAME} Iterator`
        IteratorConstructor.prototype = create(IteratorPrototype, {
          next: createPropertyDescriptor(1, next),
        })
        setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true)
        Iterators[TO_STRING_TAG] = returnThis
        return IteratorConstructor
      }

      /** */
    },
    /* 154 */
    /** */ function(module, exports, __webpack_require__) {
      const fails = __webpack_require__(9)

      module.exports = !fails(function() {
        function F() {
          /* empty */
        }

        F.prototype.constructor = null
        return Object.getPrototypeOf(new F()) !== F.prototype
      })

      /** */
    },
    /* 155 */
    /** */ function(module, exports, __webpack_require__) {
      const isObject = __webpack_require__(12)

      module.exports = function(it) {
        if (!isObject(it) && it !== null) {
          throw new TypeError(`Can't set ${String(it)} as a prototype`)
        }

        return it
      }

      /** */
    },
    /* 156 */
    /** */ function(module, exports, __webpack_require__) {
      const fails = __webpack_require__(9)

      module.exports = !fails(function() {
        return Object.isExtensible(Object.preventExtensions({}))
      })

      /** */
    },
    /* 157 */
    /** */ function(module, exports, __webpack_require__) {
      const bind = __webpack_require__(54)

      const toObject = __webpack_require__(31)

      const callWithSafeIterationClosing = __webpack_require__(126)

      const isArrayIteratorMethod = __webpack_require__(123)

      const toLength = __webpack_require__(22)

      const createProperty = __webpack_require__(57)

      const getIteratorMethod = __webpack_require__(124) // `Array.from` method implementation
      // https://tc39.github.io/ecma262/#sec-array.from

      module.exports = function from(
        arrayLike
        /* , mapfn = undefined, thisArg = undefined */
      ) {
        const O = toObject(arrayLike)
        const C = typeof this === 'function' ? this : Array
        const argumentsLength = arguments.length
        let mapfn = argumentsLength > 1 ? arguments[1] : undefined
        const mapping = mapfn !== undefined
        let index = 0
        const iteratorMethod = getIteratorMethod(O)
        let length
        let result
        let step
        let iterator
        if (mapping) {
          mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2)
        } // if the target is not iterable or it's an array with the default iterator - use a simple case

        if (
          iteratorMethod != undefined &&
          !(C == Array && isArrayIteratorMethod(iteratorMethod))
        ) {
          iterator = iteratorMethod.call(O)
          result = new C()

          for (; !(step = iterator.next()).done; index++) {
            createProperty(
              result,
              index,
              mapping
                ? callWithSafeIterationClosing(
                    iterator,
                    mapfn,
                    [step.value, index],
                    true
                  )
                : step.value
            )
          }
        } else {
          length = toLength(O.length)
          result = new C(length)

          for (; length > index; index++) {
            createProperty(
              result,
              index,
              mapping ? mapfn(O[index], index) : O[index]
            )
          }
        }

        result.length = index
        return result
      }

      /** */
    },
    /* 158 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__
        )
        /* harmony import */ const core_js_modules_es_array_splice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          94
        )
        /* harmony import */ const core_js_modules_es_array_splice__WEBPACK_IMPORTED_MODULE_1___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_splice__WEBPACK_IMPORTED_MODULE_1__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          1
        )

        const redefineAll = __webpack_require__(68)

        const {getWeakData} = __webpack_require__(69)

        const anObject = __webpack_require__(17)

        const isObject = __webpack_require__(12)

        const anInstance = __webpack_require__(71)

        const iterate = __webpack_require__(70)

        const ArrayIterationModule = __webpack_require__(67)

        const $has = __webpack_require__(20)

        const InternalStateModule = __webpack_require__(38)

        const setInternalState = InternalStateModule.set
        const internalStateGetterFor = InternalStateModule.getterFor
        const {find} = ArrayIterationModule
        const {findIndex} = ArrayIterationModule
        let id = 0 // fallback for uncaught frozen keys

        const uncaughtFrozenStore = function uncaughtFrozenStore(store) {
          return store.frozen || (store.frozen = new UncaughtFrozenStore())
        }

        var UncaughtFrozenStore = function UncaughtFrozenStore() {
          this.entries = []
        }

        const findUncaughtFrozen = function findUncaughtFrozen(store, key) {
          return find(store.entries, function(it) {
            return it[0] === key
          })
        }

        UncaughtFrozenStore.prototype = {
          get: function get(key) {
            const entry = findUncaughtFrozen(this, key)
            if (entry) {
              return entry[1]
            }
          },
          has: function has(key) {
            return !!findUncaughtFrozen(this, key)
          },
          set: function set(key, value) {
            const entry = findUncaughtFrozen(this, key)
            if (entry) {
              entry[1] = value
            } else {
              this.entries.push([key, value])
            }
          },
          delete: function _delete(key) {
            const index = findIndex(this.entries, function(it) {
              return it[0] === key
            })
            if (~index) {
              this.entries.splice(index, 1)
            }
            return !!~index
          },
        }
        module.exports = {
          getConstructor: function getConstructor(
            wrapper,
            CONSTRUCTOR_NAME,
            IS_MAP,
            ADDER
          ) {
            var C = wrapper(function(that, iterable) {
              anInstance(that, C, CONSTRUCTOR_NAME)
              setInternalState(that, {
                type: CONSTRUCTOR_NAME,
                id: id++,
                frozen: undefined,
              })
              if (iterable != undefined) {
                iterate(iterable, that[ADDER], that, IS_MAP)
              }
            })
            const getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME)

            const define = function define(that, key, value) {
              const state = getInternalState(that)
              const data = getWeakData(anObject(key), true)
              if (data === true) {
                uncaughtFrozenStore(state).set(key, value)
              } else {
                data[state.id] = value
              }
              return that
            }

            redefineAll(C.prototype, {
              // 23.3.3.2 WeakMap.prototype.delete(key)
              // 23.4.3.3 WeakSet.prototype.delete(value)
              delete: function _delete(key) {
                const state = getInternalState(this)
                if (!isObject(key)) {
                  return false
                }
                const data = getWeakData(key)
                if (data === true) {
                  return uncaughtFrozenStore(state).delete(key)
                }
                return data && $has(data, state.id) && delete data[state.id]
              },
              // 23.3.3.4 WeakMap.prototype.has(key)
              // 23.4.3.4 WeakSet.prototype.has(value)
              has: function has(key) {
                const state = getInternalState(this)
                if (!isObject(key)) {
                  return false
                }
                const data = getWeakData(key)
                if (data === true) {
                  return uncaughtFrozenStore(state).has(key)
                }
                return data && $has(data, state.id)
              },
            })
            redefineAll(
              C.prototype,
              IS_MAP
                ? {
                    // 23.3.3.3 WeakMap.prototype.get(key)
                    get: function get(key) {
                      const state = getInternalState(this)

                      if (isObject(key)) {
                        const data = getWeakData(key)
                        if (data === true) {
                          return uncaughtFrozenStore(state).get(key)
                        }
                        return data ? data[state.id] : undefined
                      }
                    },
                    // 23.3.3.5 WeakMap.prototype.set(key, value)
                    set: function set(key, value) {
                      return define(this, key, value)
                    },
                  }
                : {
                    // 23.4.3.1 WeakSet.prototype.add(value)
                    add: function add(value) {
                      return define(this, value, true)
                    },
                  }
            )
            return C
          },
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 159 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          2
        )

        const toInteger = __webpack_require__(39)

        const requireObjectCoercible = __webpack_require__(26) // `String.prototype.{ codePointAt, at }` methods implementation

        const createMethod = function createMethod(CONVERT_TO_STRING) {
          return function($this, pos) {
            const S = String(requireObjectCoercible($this))
            const position = toInteger(pos)
            const size = S.length
            let first
            let second
            if (position < 0 || position >= size) {
              return CONVERT_TO_STRING ? '' : undefined
            }
            first = S.charCodeAt(position)
            return first < 0xd800 ||
              first > 0xdbff ||
              position + 1 === size ||
              (second = S.charCodeAt(position + 1)) < 0xdc00 ||
              second > 0xdfff
              ? CONVERT_TO_STRING
                ? S.charAt(position)
                : first
              : CONVERT_TO_STRING
              ? S.slice(position, position + 2)
              : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000
          }
        }

        module.exports = {
          // `String.prototype.codePointAt` method
          // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
          codeAt: createMethod(false),
          // `String.prototype.at` method
          // https://github.com/mathiasbynens/String.prototype.at
          charAt: createMethod(true),
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 160 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          1
        )

        const classof = __webpack_require__(125)

        const wellKnownSymbol = __webpack_require__(7)

        const TO_STRING_TAG = wellKnownSymbol('toStringTag')
        const test = {}
        test[TO_STRING_TAG] = 'z' // `Object.prototype.toString` method implementation
        // https://tc39.github.io/ecma262/#sec-object.prototype.tostring

        module.exports =
          String(test) !== '[object z]'
            ? function toString() {
                return `[object ${classof(this)}]`
              }
            : test.toString
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 161 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          11
        )
        /* harmony import */ const core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          32
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          24
        )

        const DESCRIPTORS = __webpack_require__(18)

        const fails = __webpack_require__(9)

        const objectKeys = __webpack_require__(88)

        const getOwnPropertySymbolsModule = __webpack_require__(87)

        const propertyIsEnumerableModule = __webpack_require__(77)

        const toObject = __webpack_require__(31)

        const IndexedObject = __webpack_require__(78)

        const nativeAssign = Object.assign // `Object.assign` method
        // https://tc39.github.io/ecma262/#sec-object.assign
        // should work with symbols and should have deterministic property order (V8 bug)

        module.exports =
          !nativeAssign ||
          fails(function() {
            const A = {}
            const B = {} // eslint-disable-next-line no-undef

            const symbol = Symbol()
            const alphabet = 'abcdefghijklmnopqrst'
            A[symbol] = 7
            alphabet.split('').forEach(function(chr) {
              B[chr] = chr
            })
            return (
              {...A}[symbol] != 7 || objectKeys({...B}).join('') != alphabet
            )
          })
            ? function assign(target, source) {
                // eslint-disable-line no-unused-vars
                const T = toObject(target)
                const argumentsLength = arguments.length
                let index = 1
                const getOwnPropertySymbols = getOwnPropertySymbolsModule.f
                const propertyIsEnumerable = propertyIsEnumerableModule.f

                while (argumentsLength > index) {
                  const S = IndexedObject(arguments[index++])
                  const keys = getOwnPropertySymbols
                    ? objectKeys(S).concat(getOwnPropertySymbols(S))
                    : objectKeys(S)
                  const {length} = keys
                  let j = 0
                  var key

                  while (length > j) {
                    key = keys[j++]
                    if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) {
                      T[key] = S[key]
                    }
                  }
                }

                return T
              }
            : nativeAssign
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 162 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          13
        )
        /* harmony import */ const core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          23
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_array_sort__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          42
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          16
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          3
        )
        /* harmony import */ const core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          28
        )
        /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          14
        )
        /* harmony import */ const core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          24
        )
        /* harmony import */ const core_js_modules_es_string_trim__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
          46
        )

        exports = module.exports = SemVer
        let debug
        /* istanbul ignore next */

        if (
          typeof process === 'object' &&
          process.env &&
          process.env.NODE_DEBUG &&
          /\bsemver\b/i.test(process.env.NODE_DEBUG)
        ) {
          debug = function debug() {
            const arguments_ = Array.prototype.slice.call(arguments, 0)
            arguments_.unshift('SEMVER')
            console.log.apply(console, arguments_)
          }
        } else {
          debug = function debug() {}
        } // Note: this is the semver.org version of the spec that it implements
        // Not necessarily the package version of this code.

        exports.SEMVER_SPEC_VERSION = '2.0.0'
        const MAX_LENGTH = 256
        const MAX_SAFE_INTEGER =
          Number.MAX_SAFE_INTEGER ||
          /* istanbul ignore next */
          9007199254740991 // Max safe segment length for coercion.

        const MAX_SAFE_COMPONENT_LENGTH = 16 // The actual regexps go on exports.re

        const re = (exports.re = [])
        const source = (exports.src = [])
        const t = (exports.tokens = {})
        let R = 0

        function tok(n) {
          t[n] = R++
        } // The following Regular Expressions can be used for tokenizing,
        // validating, and parsing SemVer version strings.
        // ## Numeric Identifier
        // A single `0`, or a non-zero digit followed by zero or more digits.

        tok('NUMERICIDENTIFIER')
        source[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*'
        tok('NUMERICIDENTIFIERLOOSE')
        source[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+' // ## Non-numeric Identifier
        // Zero or more digits, followed by a letter or hyphen, and then zero or
        // more letters, digits, or hyphens.

        tok('NONNUMERICIDENTIFIER')
        source[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*' // ## Main Version
        // Three dot-separated numeric identifiers.

        tok('MAINVERSION')
        source[t.MAINVERSION] =
          `(${source[t.NUMERICIDENTIFIER]})\\.` +
          `(${source[t.NUMERICIDENTIFIER]})\\.` +
          `(${source[t.NUMERICIDENTIFIER]})`
        tok('MAINVERSIONLOOSE')
        source[t.MAINVERSIONLOOSE] =
          `(${source[t.NUMERICIDENTIFIERLOOSE]})\\.` +
          `(${source[t.NUMERICIDENTIFIERLOOSE]})\\.` +
          `(${source[t.NUMERICIDENTIFIERLOOSE]})` // ## Pre-release Version Identifier
        // A numeric identifier, or a non-numeric identifier.

        tok('PRERELEASEIDENTIFIER')
        source[t.PRERELEASEIDENTIFIER] = `(?:${source[t.NUMERICIDENTIFIER]}|${
          source[t.NONNUMERICIDENTIFIER]
        })`
        tok('PRERELEASEIDENTIFIERLOOSE')
        source[t.PRERELEASEIDENTIFIERLOOSE] = `(?:${
          source[t.NUMERICIDENTIFIERLOOSE]
        }|${source[t.NONNUMERICIDENTIFIER]})` // ## Pre-release Version
        // Hyphen, followed by one or more dot-separated pre-release version
        // identifiers.

        tok('PRERELEASE')
        source[t.PRERELEASE] = `(?:-(${source[t.PRERELEASEIDENTIFIER]}(?:\\.${
          source[t.PRERELEASEIDENTIFIER]
        })*))`
        tok('PRERELEASELOOSE')
        source[t.PRERELEASELOOSE] = `(?:-?(${
          source[t.PRERELEASEIDENTIFIERLOOSE]
        }(?:\\.${source[t.PRERELEASEIDENTIFIERLOOSE]})*))` // ## Build Metadata Identifier
        // Any combination of digits, letters, or hyphens.

        tok('BUILDIDENTIFIER')
        source[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+' // ## Build Metadata
        // Plus sign, followed by one or more period-separated build metadata
        // identifiers.

        tok('BUILD')
        source[t.BUILD] = `(?:\\+(${source[t.BUILDIDENTIFIER]}(?:\\.${
          source[t.BUILDIDENTIFIER]
        })*))` // ## Full Version String
        // A main version, followed optionally by a pre-release version and
        // build metadata.
        // Note that the only major, minor, patch, and pre-release sections of
        // the version string are capturing groups.  The build metadata is not a
        // capturing group, because it should not ever be used in version
        // comparison.

        tok('FULL')
        tok('FULLPLAIN')
        source[t.FULLPLAIN] = `v?${source[t.MAINVERSION]}${
          source[t.PRERELEASE]
        }?${source[t.BUILD]}?`
        source[t.FULL] = `^${source[t.FULLPLAIN]}$` // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
        // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
        // common in the npm registry.

        tok('LOOSEPLAIN')
        source[t.LOOSEPLAIN] = `[v=\\s]*${source[t.MAINVERSIONLOOSE]}${
          source[t.PRERELEASELOOSE]
        }?${source[t.BUILD]}?`
        tok('LOOSE')
        source[t.LOOSE] = `^${source[t.LOOSEPLAIN]}$`
        tok('GTLT')
        source[t.GTLT] = '((?:<|>)?=?)' // Something like "2.*" or "1.2.x".
        // Note that "x.x" is a valid xRange identifer, meaning "any version"
        // Only the first item is strictly required.

        tok('XRANGEIDENTIFIERLOOSE')
        source[t.XRANGEIDENTIFIERLOOSE] = `${
          source[t.NUMERICIDENTIFIERLOOSE]
        }|x|X|\\*`
        tok('XRANGEIDENTIFIER')
        source[t.XRANGEIDENTIFIER] = `${source[t.NUMERICIDENTIFIER]}|x|X|\\*`
        tok('XRANGEPLAIN')
        source[t.XRANGEPLAIN] =
          `[v=\\s]*(${source[t.XRANGEIDENTIFIER]})` +
          `(?:\\.(${source[t.XRANGEIDENTIFIER]})` +
          `(?:\\.(${source[t.XRANGEIDENTIFIER]})` +
          `(?:${source[t.PRERELEASE]})?${source[t.BUILD]}?` +
          `)?)?`
        tok('XRANGEPLAINLOOSE')
        source[t.XRANGEPLAINLOOSE] =
          `[v=\\s]*(${source[t.XRANGEIDENTIFIERLOOSE]})` +
          `(?:\\.(${source[t.XRANGEIDENTIFIERLOOSE]})` +
          `(?:\\.(${source[t.XRANGEIDENTIFIERLOOSE]})` +
          `(?:${source[t.PRERELEASELOOSE]})?${source[t.BUILD]}?` +
          `)?)?`
        tok('XRANGE')
        source[t.XRANGE] = `^${source[t.GTLT]}\\s*${source[t.XRANGEPLAIN]}$`
        tok('XRANGELOOSE')
        source[t.XRANGELOOSE] = `^${source[t.GTLT]}\\s*${
          source[t.XRANGEPLAINLOOSE]
        }$` // Coercion.
        // Extract anything that could conceivably be a part of a valid semver

        tok('COERCE')
        source[t.COERCE] =
          `${'(^|[^\\d])' + '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
          `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
          `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
          `(?:$|[^\\d])`
        tok('COERCERTL')
        re[t.COERCERTL] = new RegExp(source[t.COERCE], 'g') // Tilde ranges.
        // Meaning is "reasonably at or greater than"

        tok('LONETILDE')
        source[t.LONETILDE] = '(?:~>?)'
        tok('TILDETRIM')
        source[t.TILDETRIM] = `(\\s*)${source[t.LONETILDE]}\\s+`
        re[t.TILDETRIM] = new RegExp(source[t.TILDETRIM], 'g')
        const tildeTrimReplace = '$1~'
        tok('TILDE')
        source[t.TILDE] = `^${source[t.LONETILDE]}${source[t.XRANGEPLAIN]}$`
        tok('TILDELOOSE')
        source[t.TILDELOOSE] = `^${source[t.LONETILDE]}${
          source[t.XRANGEPLAINLOOSE]
        }$` // Caret ranges.
        // Meaning is "at least and backwards compatible with"

        tok('LONECARET')
        source[t.LONECARET] = '(?:\\^)'
        tok('CARETTRIM')
        source[t.CARETTRIM] = `(\\s*)${source[t.LONECARET]}\\s+`
        re[t.CARETTRIM] = new RegExp(source[t.CARETTRIM], 'g')
        const caretTrimReplace = '$1^'
        tok('CARET')
        source[t.CARET] = `^${source[t.LONECARET]}${source[t.XRANGEPLAIN]}$`
        tok('CARETLOOSE')
        source[t.CARETLOOSE] = `^${source[t.LONECARET]}${
          source[t.XRANGEPLAINLOOSE]
        }$` // A simple gt/lt/eq thing, or just "" to indicate "any version"

        tok('COMPARATORLOOSE')
        source[t.COMPARATORLOOSE] = `^${source[t.GTLT]}\\s*(${
          source[t.LOOSEPLAIN]
        })$|^$`
        tok('COMPARATOR')
        source[t.COMPARATOR] = `^${source[t.GTLT]}\\s*(${
          source[t.FULLPLAIN]
        })$|^$` // An expression to strip any whitespace between the gtlt and the thing
        // it modifies, so that `> 1.2.3` ==> `>1.2.3`

        tok('COMPARATORTRIM')
        source[t.COMPARATORTRIM] = `(\\s*)${source[t.GTLT]}\\s*(${
          source[t.LOOSEPLAIN]
        }|${source[t.XRANGEPLAIN]})` // this one has to use the /g flag

        re[t.COMPARATORTRIM] = new RegExp(source[t.COMPARATORTRIM], 'g')
        const comparatorTrimReplace = '$1$2$3' // Something like `1.2.3 - 1.2.4`
        // Note that these all use the loose form, because they'll be
        // checked against either the strict or loose comparator form
        // later.

        tok('HYPHENRANGE')
        source[t.HYPHENRANGE] =
          `^\\s*(${source[t.XRANGEPLAIN]})` +
          `\\s+-\\s+` +
          `(${source[t.XRANGEPLAIN]})` +
          `\\s*$`
        tok('HYPHENRANGELOOSE')
        source[t.HYPHENRANGELOOSE] =
          `^\\s*(${source[t.XRANGEPLAINLOOSE]})` +
          `\\s+-\\s+` +
          `(${source[t.XRANGEPLAINLOOSE]})` +
          `\\s*$` // Star ranges basically just allow anything at all.

        tok('STAR')
        source[t.STAR] = '(<|>)?=?\\s*\\*' // Compile to actual regexp objects.
        // All are flag-free, unless they were created above with a flag.

        for (let i = 0; i < R; i++) {
          debug(i, source[i])

          if (!re[i]) {
            re[i] = new RegExp(source[i])
          }
        }

        exports.parse = parse

        function parse(version, options) {
          if (!options || typeof options !== 'object') {
            options = {
              loose: !!options,
              includePrerelease: false,
            }
          }

          if (version instanceof SemVer) {
            return version
          }

          if (typeof version !== 'string') {
            return null
          }

          if (version.length > MAX_LENGTH) {
            return null
          }

          const r = options.loose ? re[t.LOOSE] : re[t.FULL]

          if (!r.test(version)) {
            return null
          }

          try {
            return new SemVer(version, options)
          } catch (error) {
            return null
          }
        }

        exports.valid = valid

        function valid(version, options) {
          const v = parse(version, options)
          return v ? v.version : null
        }

        exports.clean = clean

        function clean(version, options) {
          const s = parse(version.trim().replace(/^[=v]+/, ''), options)
          return s ? s.version : null
        }

        exports.SemVer = SemVer

        function SemVer(version, options) {
          if (!options || typeof options !== 'object') {
            options = {
              loose: !!options,
              includePrerelease: false,
            }
          }

          if (version instanceof SemVer) {
            if (version.loose === options.loose) {
              return version
            }
            version = version.version
          } else if (typeof version !== 'string') {
            throw new TypeError(`Invalid Version: ${version}`)
          }

          if (version.length > MAX_LENGTH) {
            throw new TypeError(
              `version is longer than ${MAX_LENGTH} characters`
            )
          }

          if (!(this instanceof SemVer)) {
            return new SemVer(version, options)
          }

          debug('SemVer', version, options)
          this.options = options
          this.loose = !!options.loose
          const m = version
            .trim()
            .match(options.loose ? re[t.LOOSE] : re[t.FULL])

          if (!m) {
            throw new TypeError(`Invalid Version: ${version}`)
          }

          this.raw = version // these are actually numbers

          this.major = Number(m[1])
          this.minor = Number(m[2])
          this.patch = Number(m[3])

          if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError('Invalid major version')
          }

          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError('Invalid minor version')
          }

          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError('Invalid patch version')
          } // numberify any prerelease numeric ids

          if (!m[4]) {
            this.prerelease = []
          } else {
            this.prerelease = m[4].split('.').map(function(id) {
              if (/^\d+$/.test(id)) {
                const number = Number(id)

                if (number >= 0 && number < MAX_SAFE_INTEGER) {
                  return number
                }
              }

              return id
            })
          }

          this.build = m[5] ? m[5].split('.') : []
          this.format()
        }

        SemVer.prototype.format = function() {
          this.version = `${this.major}.${this.minor}.${this.patch}`

          if (this.prerelease.length) {
            this.version += `-${this.prerelease.join('.')}`
          }

          return this.version
        }

        SemVer.prototype.toString = function() {
          return this.version
        }

        SemVer.prototype.compare = function(other) {
          debug('SemVer.compare', this.version, this.options, other)

          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options)
          }

          return this.compareMain(other) || this.comparePre(other)
        }

        SemVer.prototype.compareMain = function(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options)
          }

          return (
            compareIdentifiers(this.major, other.major) ||
            compareIdentifiers(this.minor, other.minor) ||
            compareIdentifiers(this.patch, other.patch)
          )
        }

        SemVer.prototype.comparePre = function(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options)
          } // NOT having a prerelease is > having one

          if (this.prerelease.length && !other.prerelease.length) {
            return -1
          }
          if (!this.prerelease.length && other.prerelease.length) {
            return 1
          }
          if (!this.prerelease.length && !other.prerelease.length) {
            return 0
          }

          let i = 0

          do {
            const a = this.prerelease[i]
            const b = other.prerelease[i]
            debug('prerelease compare', i, a, b)

            if (a === undefined && b === undefined) {
              return 0
            }
            if (b === undefined) {
              return 1
            }
            if (a === undefined) {
              return -1
            }
            if (a === b) {
              continue
            } else {
              return compareIdentifiers(a, b)
            }
          } while (++i)
        }

        SemVer.prototype.compareBuild = function(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options)
          }

          let i = 0

          do {
            const a = this.build[i]
            const b = other.build[i]
            debug('prerelease compare', i, a, b)

            if (a === undefined && b === undefined) {
              return 0
            }
            if (b === undefined) {
              return 1
            }
            if (a === undefined) {
              return -1
            }
            if (a === b) {
              continue
            } else {
              return compareIdentifiers(a, b)
            }
          } while (++i)
        } // preminor will bump the version up to the next minor release, and immediately
        // down to pre-release. premajor and prepatch work the same way.

        SemVer.prototype.inc = function(release, identifier) {
          switch (release) {
            case 'premajor':
              this.prerelease.length = 0
              this.patch = 0
              this.minor = 0
              this.major++
              this.inc('pre', identifier)
              break

            case 'preminor':
              this.prerelease.length = 0
              this.patch = 0
              this.minor++
              this.inc('pre', identifier)
              break

            case 'prepatch':
              // If this is already a prerelease, it will bump to the next version
              // drop any prereleases that might already exist, since they are not
              // relevant at this point.
              this.prerelease.length = 0
              this.inc('patch', identifier)
              this.inc('pre', identifier)
              break
            // If the input is a non-prerelease version, this acts the same as
            // prepatch.

            case 'prerelease':
              if (this.prerelease.length === 0) {
                this.inc('patch', identifier)
              }

              this.inc('pre', identifier)
              break

            case 'major':
              // If this is a pre-major version, bump up to the same major version.
              // Otherwise increment major.
              // 1.0.0-5 bumps to 1.0.0
              // 1.1.0 bumps to 2.0.0
              if (
                this.minor !== 0 ||
                this.patch !== 0 ||
                this.prerelease.length === 0
              ) {
                this.major++
              }

              this.minor = 0
              this.patch = 0
              this.prerelease = []
              break

            case 'minor':
              // If this is a pre-minor version, bump up to the same minor version.
              // Otherwise increment minor.
              // 1.2.0-5 bumps to 1.2.0
              // 1.2.1 bumps to 1.3.0
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++
              }

              this.patch = 0
              this.prerelease = []
              break

            case 'patch':
              // If this is not a pre-release version, it will increment the patch.
              // If it is a pre-release it will bump up to the same patch version.
              // 1.2.0-5 patches to 1.2.0
              // 1.2.0 patches to 1.2.1
              if (this.prerelease.length === 0) {
                this.patch++
              }

              this.prerelease = []
              break
            // This probably shouldn't be used publicly.
            // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.

            case 'pre':
              if (this.prerelease.length === 0) {
                this.prerelease = [0]
              } else {
                let i = this.prerelease.length

                while (--i >= 0) {
                  if (typeof this.prerelease[i] === 'number') {
                    this.prerelease[i]++
                    i = -2
                  }
                }

                if (i === -1) {
                  // didn't increment anything
                  this.prerelease.push(0)
                }
              }

              if (identifier) {
                // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                if (this.prerelease[0] === identifier) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = [identifier, 0]
                  }
                } else {
                  this.prerelease = [identifier, 0]
                }
              }

              break

            default:
              throw new Error(`invalid increment argument: ${release}`)
          }

          this.format()
          this.raw = this.version
          return this
        }

        exports.inc = inc

        function inc(version, release, loose, identifier) {
          if (typeof loose === 'string') {
            identifier = loose
            loose = undefined
          }

          try {
            return new SemVer(version, loose).inc(release, identifier).version
          } catch (error) {
            return null
          }
        }

        exports.diff = diff

        function diff(version1, version2) {
          if (eq(version1, version2)) {
            return null
          }
          const v1 = parse(version1)
          const v2 = parse(version2)
          let prefix = ''

          if (v1.prerelease.length || v2.prerelease.length) {
            prefix = 'pre'
            var defaultResult = 'prerelease'
          }

          for (const key in v1) {
            if (key === 'major' || key === 'minor' || key === 'patch') {
              if (v1[key] !== v2[key]) {
                return prefix + key
              }
            }
          }

          return defaultResult // may be undefined
        }

        exports.compareIdentifiers = compareIdentifiers
        const numeric = /^\d+$/

        function compareIdentifiers(a, b) {
          const anum = numeric.test(a)
          const bnum = numeric.test(b)

          if (anum && bnum) {
            a = Number(a)
            b = Number(b)
          }

          return a === b
            ? 0
            : anum && !bnum
            ? -1
            : bnum && !anum
            ? 1
            : a < b
            ? -1
            : 1
        }

        exports.rcompareIdentifiers = rcompareIdentifiers

        function rcompareIdentifiers(a, b) {
          return compareIdentifiers(b, a)
        }

        exports.major = major

        function major(a, loose) {
          return new SemVer(a, loose).major
        }

        exports.minor = minor

        function minor(a, loose) {
          return new SemVer(a, loose).minor
        }

        exports.patch = patch

        function patch(a, loose) {
          return new SemVer(a, loose).patch
        }

        exports.compare = compare

        function compare(a, b, loose) {
          return new SemVer(a, loose).compare(new SemVer(b, loose))
        }

        exports.compareLoose = compareLoose

        function compareLoose(a, b) {
          return compare(a, b, true)
        }

        exports.compareBuild = compareBuild

        function compareBuild(a, b, loose) {
          const versionA = new SemVer(a, loose)
          const versionB = new SemVer(b, loose)
          return versionA.compare(versionB) || versionA.compareBuild(versionB)
        }

        exports.rcompare = rcompare

        function rcompare(a, b, loose) {
          return compare(b, a, loose)
        }

        exports.sort = sort

        function sort(list, loose) {
          return list.sort(function(a, b) {
            return exports.compareBuild(a, b, loose)
          })
        }

        exports.rsort = rsort

        function rsort(list, loose) {
          return list.sort(function(a, b) {
            return exports.compareBuild(b, a, loose)
          })
        }

        exports.gt = gt

        function gt(a, b, loose) {
          return compare(a, b, loose) > 0
        }

        exports.lt = lt

        function lt(a, b, loose) {
          return compare(a, b, loose) < 0
        }

        exports.eq = eq

        function eq(a, b, loose) {
          return compare(a, b, loose) === 0
        }

        exports.neq = neq

        function neq(a, b, loose) {
          return compare(a, b, loose) !== 0
        }

        exports.gte = gte

        function gte(a, b, loose) {
          return compare(a, b, loose) >= 0
        }

        exports.lte = lte

        function lte(a, b, loose) {
          return compare(a, b, loose) <= 0
        }

        exports.cmp = cmp

        function cmp(a, op, b, loose) {
          switch (op) {
            case '===':
              if (typeof a === 'object') {
                a = a.version
              }
              if (typeof b === 'object') {
                b = b.version
              }
              return a === b

            case '!==':
              if (typeof a === 'object') {
                a = a.version
              }
              if (typeof b === 'object') {
                b = b.version
              }
              return a !== b

            case '':
            case '=':
            case '==':
              return eq(a, b, loose)

            case '!=':
              return neq(a, b, loose)

            case '>':
              return gt(a, b, loose)

            case '>=':
              return gte(a, b, loose)

            case '<':
              return lt(a, b, loose)

            case '<=':
              return lte(a, b, loose)

            default:
              throw new TypeError(`Invalid operator: ${op}`)
          }
        }

        exports.Comparator = Comparator

        function Comparator(comp, options) {
          if (!options || typeof options !== 'object') {
            options = {
              loose: !!options,
              includePrerelease: false,
            }
          }

          if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
              return comp
            }
            comp = comp.value
          }

          if (!(this instanceof Comparator)) {
            return new Comparator(comp, options)
          }

          debug('comparator', comp, options)
          this.options = options
          this.loose = !!options.loose
          this.parse(comp)

          if (this.semver === ANY) {
            this.value = ''
          } else {
            this.value = this.operator + this.semver.version
          }

          debug('comp', this)
        }

        var ANY = {}

        Comparator.prototype.parse = function(comp) {
          const r = this.options.loose
            ? re[t.COMPARATORLOOSE]
            : re[t.COMPARATOR]
          const m = comp.match(r)

          if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`)
          }

          this.operator = m[1] !== undefined ? m[1] : ''

          if (this.operator === '=') {
            this.operator = ''
          } // if it literally is just '>' or '' then allow anything.

          if (!m[2]) {
            this.semver = ANY
          } else {
            this.semver = new SemVer(m[2], this.options.loose)
          }
        }

        Comparator.prototype.toString = function() {
          return this.value
        }

        Comparator.prototype.test = function(version) {
          debug('Comparator.test', version, this.options.loose)

          if (this.semver === ANY || version === ANY) {
            return true
          }

          if (typeof version === 'string') {
            try {
              version = new SemVer(version, this.options)
            } catch (error) {
              return false
            }
          }

          return cmp(version, this.operator, this.semver, this.options)
        }

        Comparator.prototype.intersects = function(comp, options) {
          if (!(comp instanceof Comparator)) {
            throw new TypeError('a Comparator is required')
          }

          if (!options || typeof options !== 'object') {
            options = {
              loose: !!options,
              includePrerelease: false,
            }
          }

          let rangeTemporary

          if (this.operator === '') {
            if (this.value === '') {
              return true
            }

            rangeTemporary = new Range(comp.value, options)
            return satisfies(this.value, rangeTemporary, options)
          }
          if (comp.operator === '') {
            if (comp.value === '') {
              return true
            }

            rangeTemporary = new Range(this.value, options)
            return satisfies(comp.semver, rangeTemporary, options)
          }

          const sameDirectionIncreasing =
            (this.operator === '>=' || this.operator === '>') &&
            (comp.operator === '>=' || comp.operator === '>')
          const sameDirectionDecreasing =
            (this.operator === '<=' || this.operator === '<') &&
            (comp.operator === '<=' || comp.operator === '<')
          const sameSemVer = this.semver.version === comp.semver.version
          const differentDirectionsInclusive =
            (this.operator === '>=' || this.operator === '<=') &&
            (comp.operator === '>=' || comp.operator === '<=')
          const oppositeDirectionsLessThan =
            cmp(this.semver, '<', comp.semver, options) &&
            (this.operator === '>=' || this.operator === '>') &&
            (comp.operator === '<=' || comp.operator === '<')
          const oppositeDirectionsGreaterThan =
            cmp(this.semver, '>', comp.semver, options) &&
            (this.operator === '<=' || this.operator === '<') &&
            (comp.operator === '>=' || comp.operator === '>')
          return (
            sameDirectionIncreasing ||
            sameDirectionDecreasing ||
            (sameSemVer && differentDirectionsInclusive) ||
            oppositeDirectionsLessThan ||
            oppositeDirectionsGreaterThan
          )
        }

        exports.Range = Range

        function Range(range, options) {
          if (!options || typeof options !== 'object') {
            options = {
              loose: !!options,
              includePrerelease: false,
            }
          }

          if (range instanceof Range) {
            if (
              range.loose === !!options.loose &&
              range.includePrerelease === !!options.includePrerelease
            ) {
              return range
            }
            return new Range(range.raw, options)
          }

          if (range instanceof Comparator) {
            return new Range(range.value, options)
          }

          if (!(this instanceof Range)) {
            return new Range(range, options)
          }

          this.options = options
          this.loose = !!options.loose
          this.includePrerelease = !!options.includePrerelease // First, split based on boolean or ||

          this.raw = range
          this.set = range
            .split(/\s*\|\|\s*/)
            .map(function(range) {
              return this.parseRange(range.trim())
            }, this)
            .filter(function(c) {
              // throw out any that are not relevant for whatever reason
              return c.length
            })

          if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${range}`)
          }

          this.format()
        }

        Range.prototype.format = function() {
          this.range = this.set
            .map(function(comps) {
              return comps.join(' ').trim()
            })
            .join('||')
            .trim()
          return this.range
        }

        Range.prototype.toString = function() {
          return this.range
        }

        Range.prototype.parseRange = function(range) {
          const {loose} = this.options
          range = range.trim() // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`

          const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
          range = range.replace(hr, hyphenReplace)
          debug('hyphen replace', range) // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`

          range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
          debug('comparator trim', range, re[t.COMPARATORTRIM]) // `~ 1.2.3` => `~1.2.3`

          range = range.replace(re[t.TILDETRIM], tildeTrimReplace) // `^ 1.2.3` => `^1.2.3`

          range = range.replace(re[t.CARETTRIM], caretTrimReplace) // normalize spaces

          range = range.split(/\s+/).join(' ') // At this point, the range is completely trimmed and
          // ready to be split into comparators.

          const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
          let set = range
            .split(' ')
            .map(function(comp) {
              return parseComparator(comp, this.options)
            }, this)
            .join(' ')
            .split(/\s+/)

          if (this.options.loose) {
            // in loose mode, throw out any that are not valid comparators
            set = set.filter(function(comp) {
              return !!comp.match(compRe)
            })
          }

          set = set.map(function(comp) {
            return new Comparator(comp, this.options)
          }, this)
          return set
        }

        Range.prototype.intersects = function(range, options) {
          if (!(range instanceof Range)) {
            throw new TypeError('a Range is required')
          }

          return this.set.some(function(thisComparators) {
            return (
              isSatisfiable(thisComparators, options) &&
              range.set.some(function(rangeComparators) {
                return (
                  isSatisfiable(rangeComparators, options) &&
                  thisComparators.every(function(thisComparator) {
                    return rangeComparators.every(function(rangeComparator) {
                      return thisComparator.intersects(rangeComparator, options)
                    })
                  })
                )
              })
            )
          })
        } // take a set of comparators and determine whether there
        // exists a version which can satisfy it

        function isSatisfiable(comparators, options) {
          let result = true
          const remainingComparators = comparators.slice()
          let testComparator = remainingComparators.pop()

          while (result && remainingComparators.length) {
            result = remainingComparators.every(function(otherComparator) {
              return testComparator.intersects(otherComparator, options)
            })
            testComparator = remainingComparators.pop()
          }

          return result
        } // Mostly just for testing and legacy API reasons

        exports.toComparators = toComparators

        function toComparators(range, options) {
          return new Range(range, options).set.map(function(comp) {
            return comp
              .map(function(c) {
                return c.value
              })
              .join(' ')
              .trim()
              .split(' ')
          })
        } // comprised of xranges, tildes, stars, and gtlt's at this point.
        // already replaced the hyphen ranges
        // turn into a set of JUST comparators.

        function parseComparator(comp, options) {
          debug('comp', comp, options)
          comp = replaceCarets(comp, options)
          debug('caret', comp)
          comp = replaceTildes(comp, options)
          debug('tildes', comp)
          comp = replaceXRanges(comp, options)
          debug('xrange', comp)
          comp = replaceStars(comp, options)
          debug('stars', comp)
          return comp
        }

        function isX(id) {
          return !id || id.toLowerCase() === 'x' || id === '*'
        } // ~, ~> --> * (any, kinda silly)
        // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
        // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
        // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
        // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
        // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0

        function replaceTildes(comp, options) {
          return comp
            .trim()
            .split(/\s+/)
            .map(function(comp) {
              return replaceTilde(comp, options)
            })
            .join(' ')
        }

        function replaceTilde(comp, options) {
          const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
          return comp.replace(r, function(_, M, m, p, pr) {
            debug('tilde', comp, _, M, m, p, pr)
            let returnValue

            if (isX(M)) {
              returnValue = ''
            } else if (isX(m)) {
              returnValue = `>=${M}.0.0 <${Number(M) + 1}.0.0`
            } else if (isX(p)) {
              // ~1.2 == >=1.2.0 <1.3.0
              returnValue = `>=${M}.${m}.0 <${M}.${Number(m) + 1}.0`
            } else if (pr) {
              debug('replaceTilde pr', pr)
              returnValue = `>=${M}.${m}.${p}-${pr} <${M}.${Number(m) + 1}.0`
            } else {
              // ~1.2.3 == >=1.2.3 <1.3.0
              returnValue = `>=${M}.${m}.${p} <${M}.${Number(m) + 1}.0`
            }

            debug('tilde return', returnValue)
            return returnValue
          })
        } // ^ --> * (any, kinda silly)
        // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
        // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
        // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
        // ^1.2.3 --> >=1.2.3 <2.0.0
        // ^1.2.0 --> >=1.2.0 <2.0.0

        function replaceCarets(comp, options) {
          return comp
            .trim()
            .split(/\s+/)
            .map(function(comp) {
              return replaceCaret(comp, options)
            })
            .join(' ')
        }

        function replaceCaret(comp, options) {
          debug('caret', comp, options)
          const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
          return comp.replace(r, function(_, M, m, p, pr) {
            debug('caret', comp, _, M, m, p, pr)
            let returnValue

            if (isX(M)) {
              returnValue = ''
            } else if (isX(m)) {
              returnValue = `>=${M}.0.0 <${Number(M) + 1}.0.0`
            } else if (isX(p)) {
              if (M === '0') {
                returnValue = `>=${M}.${m}.0 <${M}.${Number(m) + 1}.0`
              } else {
                returnValue = `>=${M}.${m}.0 <${Number(M) + 1}.0.0`
              }
            } else if (pr) {
              debug('replaceCaret pr', pr)

              if (M === '0') {
                if (m === '0') {
                  returnValue = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${Number(p) +
                    1}`
                } else {
                  returnValue = `>=${M}.${m}.${p}-${pr} <${M}.${Number(m) +
                    1}.0`
                }
              } else {
                returnValue = `>=${M}.${m}.${p}-${pr} <${Number(M) + 1}.0.0`
              }
            } else {
              debug('no pr')

              if (M === '0') {
                if (m === '0') {
                  returnValue = `>=${M}.${m}.${p} <${M}.${m}.${Number(p) + 1}`
                } else {
                  returnValue = `>=${M}.${m}.${p} <${M}.${Number(m) + 1}.0`
                }
              } else {
                returnValue = `>=${M}.${m}.${p} <${Number(M) + 1}.0.0`
              }
            }

            debug('caret return', returnValue)
            return returnValue
          })
        }

        function replaceXRanges(comp, options) {
          debug('replaceXRanges', comp, options)
          return comp
            .split(/\s+/)
            .map(function(comp) {
              return replaceXRange(comp, options)
            })
            .join(' ')
        }

        function replaceXRange(comp, options) {
          comp = comp.trim()
          const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
          return comp.replace(r, function(returnValue, gtlt, M, m, p, pr) {
            debug('xRange', comp, returnValue, gtlt, M, m, p, pr)
            const xM = isX(M)
            const xm = xM || isX(m)
            const xp = xm || isX(p)
            const anyX = xp

            if (gtlt === '=' && anyX) {
              gtlt = ''
            } // if we're including prereleases in the match, then we need
            // to fix this to -0, the lowest possible prerelease value

            pr = options.includePrerelease ? '-0' : ''

            if (xM) {
              if (gtlt === '>' || gtlt === '<') {
                // nothing is allowed
                returnValue = '<0.0.0-0'
              } else {
                // nothing is forbidden
                returnValue = '*'
              }
            } else if (gtlt && anyX) {
              // we know patch is an x, because we have any x at all.
              // replace X with 0
              if (xm) {
                m = 0
              }

              p = 0

              if (gtlt === '>') {
                // >1 => >=2.0.0
                // >1.2 => >=1.3.0
                // >1.2.3 => >= 1.2.4
                gtlt = '>='

                if (xm) {
                  M = Number(M) + 1
                  m = 0
                  p = 0
                } else {
                  m = Number(m) + 1
                  p = 0
                }
              } else if (gtlt === '<=') {
                // <=0.7.x is actually <0.8.0, since any 0.7.x should
                // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                gtlt = '<'

                if (xm) {
                  M = Number(M) + 1
                } else {
                  m = Number(m) + 1
                }
              }

              returnValue = `${gtlt + M}.${m}.${p}${pr}`
            } else if (xm) {
              returnValue = `>=${M}.0.0${pr} <${Number(M) + 1}.0.0${pr}`
            } else if (xp) {
              returnValue = `>=${M}.${m}.0${pr} <${M}.${Number(m) + 1}.0${pr}`
            }

            debug('xRange return', returnValue)
            return returnValue
          })
        } // Because * is AND-ed with everything else in the comparator,
        // and '' means "any version", just remove the *s entirely.

        function replaceStars(comp, options) {
          debug('replaceStars', comp, options) // Looseness is ignored here.  star is always as loose as it gets!

          return comp.trim().replace(re[t.STAR], '')
        } // This function is passed to string.replace(re[t.HYPHENRANGE])
        // M, m, patch, prerelease, build
        // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
        // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
        // 1.2 - 3.4 => >=1.2.0 <3.5.0

        function hyphenReplace(
          $0,
          from,
          fM,
          fm,
          fp,
          fpr,
          fb,
          to,
          tM,
          tm,
          tp,
          tpr,
          tb
        ) {
          if (isX(fM)) {
            from = ''
          } else if (isX(fm)) {
            from = `>=${fM}.0.0`
          } else if (isX(fp)) {
            from = `>=${fM}.${fm}.0`
          } else {
            from = `>=${from}`
          }

          if (isX(tM)) {
            to = ''
          } else if (isX(tm)) {
            to = `<${Number(tM) + 1}.0.0`
          } else if (isX(tp)) {
            to = `<${tM}.${Number(tm) + 1}.0`
          } else if (tpr) {
            to = `<=${tM}.${tm}.${tp}-${tpr}`
          } else {
            to = `<=${to}`
          }

          return `${from} ${to}`.trim()
        } // if ANY of the sets match ALL of its comparators, then pass

        Range.prototype.test = function(version) {
          if (!version) {
            return false
          }

          if (typeof version === 'string') {
            try {
              version = new SemVer(version, this.options)
            } catch (error) {
              return false
            }
          }

          for (let i = 0; i < this.set.length; i++) {
            if (testSet(this.set[i], version, this.options)) {
              return true
            }
          }

          return false
        }

        function testSet(set, version, options) {
          for (var i = 0; i < set.length; i++) {
            if (!set[i].test(version)) {
              return false
            }
          }

          if (version.prerelease.length && !options.includePrerelease) {
            // Find the set of versions that are allowed to have prereleases
            // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
            // That should allow `1.2.3-pr.2` to pass.
            // However, `1.2.4-alpha.notready` should NOT be allowed,
            // even though it's within the range set by the comparators.
            for (i = 0; i < set.length; i++) {
              debug(set[i].semver)

              if (set[i].semver === ANY) {
                continue
              }

              if (set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver

                if (
                  allowed.major === version.major &&
                  allowed.minor === version.minor &&
                  allowed.patch === version.patch
                ) {
                  return true
                }
              }
            } // Version has a -pre, but it's not one of the ones we like.

            return false
          }

          return true
        }

        exports.satisfies = satisfies

        function satisfies(version, range, options) {
          try {
            range = new Range(range, options)
          } catch (error) {
            return false
          }

          return range.test(version)
        }

        exports.maxSatisfying = maxSatisfying

        function maxSatisfying(versions, range, options) {
          let max = null
          let maxSV = null

          try {
            var rangeObject = new Range(range, options)
          } catch (error) {
            return null
          }

          versions.forEach(function(v) {
            if (rangeObject.test(v)) {
              // satisfies(v, range, options)
              if (!max || maxSV.compare(v) === -1) {
                // compare(max, v, true)
                max = v
                maxSV = new SemVer(max, options)
              }
            }
          })
          return max
        }

        exports.minSatisfying = minSatisfying

        function minSatisfying(versions, range, options) {
          let min = null
          let minSV = null

          try {
            var rangeObject = new Range(range, options)
          } catch (error) {
            return null
          }

          versions.forEach(function(v) {
            if (rangeObject.test(v)) {
              // satisfies(v, range, options)
              if (!min || minSV.compare(v) === 1) {
                // compare(min, v, true)
                min = v
                minSV = new SemVer(min, options)
              }
            }
          })
          return min
        }

        exports.minVersion = minVersion

        function minVersion(range, loose) {
          range = new Range(range, loose)
          let minver = new SemVer('0.0.0')

          if (range.test(minver)) {
            return minver
          }

          minver = new SemVer('0.0.0-0')

          if (range.test(minver)) {
            return minver
          }

          minver = null

          for (let i = 0; i < range.set.length; ++i) {
            const comparators = range.set[i]
            comparators.forEach(function(comparator) {
              // Clone to avoid manipulating the comparator's semver object.
              const compver = new SemVer(comparator.semver.version)

              switch (comparator.operator) {
                case '>':
                  if (compver.prerelease.length === 0) {
                    compver.patch++
                  } else {
                    compver.prerelease.push(0)
                  }

                  compver.raw = compver.format()

                /* fallthrough */

                case '':
                case '>=':
                  if (!minver || gt(minver, compver)) {
                    minver = compver
                  }

                  break

                case '<':
                case '<=':
                  /* Ignore maximum versions */
                  break

                /* istanbul ignore next */

                default:
                  throw new Error(
                    `Unexpected operation: ${comparator.operator}`
                  )
              }
            })
          }

          if (minver && range.test(minver)) {
            return minver
          }

          return null
        }

        exports.validRange = validRange

        function validRange(range, options) {
          try {
            // Return '*' instead of '' so that truthiness works.
            // This will throw if it's invalid anyway
            return new Range(range, options).range || '*'
          } catch (error) {
            return null
          }
        } // Determine if version is less than all the versions possible in the range

        exports.ltr = ltr

        function ltr(version, range, options) {
          return outside(version, range, '<', options)
        } // Determine if version is greater than all the versions possible in the range.

        exports.gtr = gtr

        function gtr(version, range, options) {
          return outside(version, range, '>', options)
        }

        exports.outside = outside

        function outside(version, range, hilo, options) {
          version = new SemVer(version, options)
          range = new Range(range, options)
          let gtfn
          let ltefn
          let ltfn
          let comp
          let ecomp

          switch (hilo) {
            case '>':
              gtfn = gt
              ltefn = lte
              ltfn = lt
              comp = '>'
              ecomp = '>='
              break

            case '<':
              gtfn = lt
              ltefn = gte
              ltfn = gt
              comp = '<'
              ecomp = '<='
              break

            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"')
          } // If it satisifes the range it is not outside

          if (satisfies(version, range, options)) {
            return false
          } // From now on, variable terms are as if we're in "gtr" mode.
          // but note that everything is flipped for the "ltr" function.

          for (let i = 0; i < range.set.length; ++i) {
            const comparators = range.set[i]
            var high = null
            var low = null
            comparators.forEach(function(comparator) {
              if (comparator.semver === ANY) {
                comparator = new Comparator('>=0.0.0')
              }

              high = high || comparator
              low = low || comparator

              if (gtfn(comparator.semver, high.semver, options)) {
                high = comparator
              } else if (ltfn(comparator.semver, low.semver, options)) {
                low = comparator
              }
            }) // If the edge version comparator has a operator then our version
            // isn't outside it

            if (high.operator === comp || high.operator === ecomp) {
              return false
            } // If the lowest version comparator has an operator and our version
            // is less than it then it isn't higher than the range

            if (
              (!low.operator || low.operator === comp) &&
              ltefn(version, low.semver)
            ) {
              return false
            }
            if (low.operator === ecomp && ltfn(version, low.semver)) {
              return false
            }
          }

          return true
        }

        exports.prerelease = prerelease

        function prerelease(version, options) {
          const parsed = parse(version, options)
          return parsed && parsed.prerelease.length ? parsed.prerelease : null
        }

        exports.intersects = intersects

        function intersects(r1, r2, options) {
          r1 = new Range(r1, options)
          r2 = new Range(r2, options)
          return r1.intersects(r2)
        }

        exports.coerce = coerce

        function coerce(version, options) {
          if (version instanceof SemVer) {
            return version
          }

          if (typeof version === 'number') {
            version = String(version)
          }

          if (typeof version !== 'string') {
            return null
          }

          options = options || {}
          let match = null

          if (!options.rtl) {
            match = version.match(re[t.COERCE])
          } else {
            // Find the right-most coercible string that does not share
            // a terminus with a more left-ward coercible string.
            // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
            //
            // Walk through the string checking with a /g regexp
            // Manually set the index so as to pick up overlapping matches.
            // Stop when we get a match that ends at the string end, since no
            // coercible string can be more right-ward without the same terminus.
            let next

            while (
              (next = re[t.COERCERTL].exec(version)) &&
              (!match || match.index + match[0].length !== version.length)
            ) {
              if (
                !match ||
                next.index + next[0].length !== match.index + match[0].length
              ) {
                match = next
              }

              re[t.COERCERTL].lastIndex =
                next.index + next[1].length + next[2].length
            } // leave it in a clean state

            re[t.COERCERTL].lastIndex = -1
          }

          if (match === null) {
            return null
          }

          return parse(
            `${match[2]}.${match[3] || '0'}.${match[4] || '0'}`,
            options
          )
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 163 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          16
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          3
        )
        /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          14
        )

        const requireObjectCoercible = __webpack_require__(26)

        const whitespaces = __webpack_require__(131)

        const whitespace = `[${whitespaces}]`
        const ltrim = new RegExp(`^${whitespace}${whitespace}*`)
        const rtrim = new RegExp(`${whitespace + whitespace}*$`) // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

        const createMethod = function createMethod(TYPE) {
          return function($this) {
            let string = String(requireObjectCoercible($this))
            if (TYPE & 1) {
              string = string.replace(ltrim, '')
            }
            if (TYPE & 2) {
              string = string.replace(rtrim, '')
            }
            return string
          }
        }

        module.exports = {
          // `String.prototype.{ trimLeft, trimStart }` methods
          // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
          start: createMethod(1),
          // `String.prototype.{ trimRight, trimEnd }` methods
          // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
          end: createMethod(2),
          // `String.prototype.trim` method
          // https://tc39.github.io/ecma262/#sec-string.prototype.trim
          trim: createMethod(3),
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 164 */
    /** */ function(module, exports, __webpack_require__) {
      const fails = __webpack_require__(9)

      const whitespaces = __webpack_require__(131)

      const non = '\u200B\u0085\u180E' // check that a method works with the correct list
      // of whitespaces and has a correct name

      module.exports = function(METHOD_NAME) {
        return fails(function() {
          return (
            !!whitespaces[METHOD_NAME]() ||
            non[METHOD_NAME]() != non ||
            whitespaces[METHOD_NAME].name !== METHOD_NAME
          )
        })
      }

      /** */
    },
    /* 165 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        2
      )
      /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        1
      )
      /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        3
      )

      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.
      const pathModule = __webpack_require__(15)

      const isWindows = process.platform === 'win32'

      const fs = __webpack_require__(35) // JavaScript implementation of realpath, ported from node pre-v6

      const DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG)

      function rethrow() {
        // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
        // is fairly slow to generate.
        let callback

        if (DEBUG) {
          var backtrace = new Error()
          callback = debugCallback
        } else {
          callback = missingCallback
        }

        return callback

        function debugCallback(error) {
          if (error) {
            backtrace.message = error.message
            error = backtrace
            missingCallback(error)
          }
        }

        function missingCallback(error) {
          if (error) {
            if (process.throwDeprecation) {
              throw error
            }
            // Forgot a callback but don't know where? Use NODE_DEBUG=fs
            else if (!process.noDeprecation) {
              const message = `fs: missing callback ${error.stack ||
                error.message}`
              if (process.traceDeprecation) {
                console.trace(message)
              } else {
                console.error(message)
              }
            }
          }
        }
      }

      function maybeCallback(callback) {
        return typeof callback === 'function' ? callback : rethrow()
      }

      const {normalize} = pathModule // Regexp that finds the next partion of a (partial) path
      // result is [base_with_slash, base], e.g. ['somedir/', 'somedir']

      if (isWindows) {
        var nextPartRe = /(.*?)(?:[\/\\]+|$)/g
      } else {
        var nextPartRe = /(.*?)(?:[\/]+|$)/g
      } // Regex to find the device root, including trailing slash. E.g. 'c:\\'.

      if (isWindows) {
        var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/
      } else {
        var splitRootRe = /^[\/]*/
      }

      exports.realpathSync = function realpathSync(p, cache) {
        // make p is absolute
        p = pathModule.resolve(p)

        if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
          return cache[p]
        }

        const original = p
        const seenLinks = {}
        const knownHard = {} // current character position in p

        let pos // the partial path so far, including a trailing slash if any

        let current // the partial path without a trailing slash (except when pointing at a root)

        let base // the partial path scanned in the previous round, with slash

        let previous
        start()

        function start() {
          // Skip over roots
          const m = splitRootRe.exec(p)
          pos = m[0].length
          current = m[0]
          base = m[0]
          previous = '' // On windows, check that the root exists. On unix there is no need.

          if (isWindows && !knownHard[base]) {
            fs.lstatSync(base)
            knownHard[base] = true
          }
        } // walk down the path, swapping out linked pathparts for their real
        // values
        // NB: p.length changes.

        while (pos < p.length) {
          // find the next part
          nextPartRe.lastIndex = pos
          const result = nextPartRe.exec(p)
          previous = current
          current += result[0]
          base = previous + result[1]
          pos = nextPartRe.lastIndex // continue if not a symlink

          if (knownHard[base] || (cache && cache[base] === base)) {
            continue
          }

          var resolvedLink

          if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
            // some known symbolic link.  no need to stat again.
            resolvedLink = cache[base]
          } else {
            const stat = fs.lstatSync(base)

            if (!stat.isSymbolicLink()) {
              knownHard[base] = true
              if (cache) {
                cache[base] = base
              }
              continue
            } // read the link if it wasn't read before
            // dev/ino always return 0 on windows, so skip the check.

            let linkTarget = null

            if (!isWindows) {
              var id = `${stat.dev.toString(32)}:${stat.ino.toString(32)}`

              if (seenLinks.hasOwnProperty(id)) {
                linkTarget = seenLinks[id]
              }
            }

            if (linkTarget === null) {
              fs.statSync(base)
              linkTarget = fs.readlinkSync(base)
            }

            resolvedLink = pathModule.resolve(previous, linkTarget) // track this, if given a cache.

            if (cache) {
              cache[base] = resolvedLink
            }
            if (!isWindows) {
              seenLinks[id] = linkTarget
            }
          } // resolve the link, then start over

          p = pathModule.resolve(resolvedLink, p.slice(pos))
          start()
        }

        if (cache) {
          cache[original] = p
        }
        return p
      }

      exports.realpath = function realpath(p, cache, callback) {
        if (typeof callback !== 'function') {
          callback = maybeCallback(cache)
          cache = null
        } // make p is absolute

        p = pathModule.resolve(p)

        if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
          return process.nextTick(callback.bind(null, null, cache[p]))
        }

        const original = p
        const seenLinks = {}
        const knownHard = {} // current character position in p

        let pos // the partial path so far, including a trailing slash if any

        let current // the partial path without a trailing slash (except when pointing at a root)

        let base // the partial path scanned in the previous round, with slash

        let previous
        start()

        function start() {
          // Skip over roots
          const m = splitRootRe.exec(p)
          pos = m[0].length
          current = m[0]
          base = m[0]
          previous = '' // On windows, check that the root exists. On unix there is no need.

          if (isWindows && !knownHard[base]) {
            fs.lstat(base, function(error) {
              if (error) {
                return callback(error)
              }
              knownHard[base] = true
              LOOP()
            })
          } else {
            process.nextTick(LOOP)
          }
        } // walk down the path, swapping out linked pathparts for their real
        // values

        function LOOP() {
          // stop if scanned past end of path
          if (pos >= p.length) {
            if (cache) {
              cache[original] = p
            }
            return callback(null, p)
          } // find the next part

          nextPartRe.lastIndex = pos
          const result = nextPartRe.exec(p)
          previous = current
          current += result[0]
          base = previous + result[1]
          pos = nextPartRe.lastIndex // continue if not a symlink

          if (knownHard[base] || (cache && cache[base] === base)) {
            return process.nextTick(LOOP)
          }

          if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
            // known symbolic link.  no need to stat again.
            return gotResolvedLink(cache[base])
          }

          return fs.lstat(base, gotStat)
        }

        function gotStat(error, stat) {
          if (error) {
            return callback(error)
          } // if not a symlink, skip to the next path part

          if (!stat.isSymbolicLink()) {
            knownHard[base] = true
            if (cache) {
              cache[base] = base
            }
            return process.nextTick(LOOP)
          } // stat & read the link if not read before
          // call gotTarget as soon as the link target is known
          // dev/ino always return 0 on windows, so skip the check.

          if (!isWindows) {
            var id = `${stat.dev.toString(32)}:${stat.ino.toString(32)}`

            if (seenLinks.hasOwnProperty(id)) {
              return gotTarget(null, seenLinks[id], base)
            }
          }

          fs.stat(base, function(error) {
            if (error) {
              return callback(error)
            }
            fs.readlink(base, function(error, target) {
              if (!isWindows) {
                seenLinks[id] = target
              }
              gotTarget(error, target)
            })
          })
        }

        function gotTarget(error, target, base) {
          if (error) {
            return callback(error)
          }
          const resolvedLink = pathModule.resolve(previous, target)
          if (cache) {
            cache[base] = resolvedLink
          }
          gotResolvedLink(resolvedLink)
        }

        function gotResolvedLink(resolvedLink) {
          // resolve the link, then start over
          p = pathModule.resolve(resolvedLink, p.slice(pos))
          start()
        }
      }

      /** */
    },
    /* 166 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          21
        )
        /* harmony import */ const core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          23
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          28
        )
        /* harmony import */ const core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          24
        )

        const concatMap = __webpack_require__(167)

        const balanced = __webpack_require__(168)

        module.exports = expandTop
        const escSlash = `\0SLASH${Math.random()}\0`
        const escOpen = `\0OPEN${Math.random()}\0`
        const escClose = `\0CLOSE${Math.random()}\0`
        const escComma = `\0COMMA${Math.random()}\0`
        const escPeriod = `\0PERIOD${Math.random()}\0`

        function numeric(string) {
          return parseInt(string, 10) == string
            ? parseInt(string, 10)
            : string.charCodeAt(0)
        }

        function escapeBraces(string) {
          return string
            .split('\\\\')
            .join(escSlash)
            .split('\\{')
            .join(escOpen)
            .split('\\}')
            .join(escClose)
            .split('\\,')
            .join(escComma)
            .split('\\.')
            .join(escPeriod)
        }

        function unescapeBraces(string) {
          return string
            .split(escSlash)
            .join('\\')
            .split(escOpen)
            .join('{')
            .split(escClose)
            .join('}')
            .split(escComma)
            .join(',')
            .split(escPeriod)
            .join('.')
        } // Basically just str.split(","), but handling cases
        // where we have nested braced sections, which should be
        // treated as individual members, like {a,{b,c},d}

        function parseCommaParts(string) {
          if (!string) {
            return ['']
          }
          const parts = []
          const m = balanced('{', '}', string)
          if (!m) {
            return string.split(',')
          }
          const {pre} = m
          const {body} = m
          const {post} = m
          const p = pre.split(',')
          p[p.length - 1] += `{${body}}`
          const postParts = parseCommaParts(post)

          if (post.length) {
            p[p.length - 1] += postParts.shift()
            p.push.apply(p, postParts)
          }

          parts.push.apply(parts, p)
          return parts
        }

        function expandTop(string) {
          if (!string) {
            return []
          } // I don't know why Bash 4.3 does this, but it does.
          // Anything starting with {} will have the first two bytes preserved
          // but *only* at the top level, so {},a}b will not expand to anything,
          // but a{},b}c will be expanded to [a}c,abc].
          // One could argue that this is a bug in Bash, but since the goal of
          // this module is to match Bash's rules, we escape a leading {}

          if (string.substr(0, 2) === '{}') {
            string = `\\{\\}${string.substr(2)}`
          }

          return expand(escapeBraces(string), true).map(unescapeBraces)
        }

        function identity(e) {
          return e
        }

        function embrace(string) {
          return `{${string}}`
        }

        function isPadded(element) {
          return /^-?0\d/.test(element)
        }

        function lte(i, y) {
          return i <= y
        }

        function gte(i, y) {
          return i >= y
        }

        function expand(string, isTop) {
          const expansions = []
          const m = balanced('{', '}', string)
          if (!m || /\$$/.test(m.pre)) {
            return [string]
          }
          const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(
            m.body
          )
          const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(
            m.body
          )
          const isSequence = isNumericSequence || isAlphaSequence
          const isOptions = m.body.includes(',')

          if (!isSequence && !isOptions) {
            // {a},b}
            if (m.post.match(/,.*\}/)) {
              string = `${m.pre}{${m.body}${escClose}${m.post}`
              return expand(string)
            }

            return [string]
          }

          let n

          if (isSequence) {
            n = m.body.split(/\.\./)
          } else {
            n = parseCommaParts(m.body)

            if (n.length === 1) {
              // x{{a,b}}y ==> x{a}y x{b}y
              n = expand(n[0], false).map(embrace)

              if (n.length === 1) {
                var post = m.post.length ? expand(m.post, false) : ['']
                return post.map(function(p) {
                  return m.pre + n[0] + p
                })
              }
            }
          } // at this point, n is the parts, and we know it's not a comma set
          // with a single entry.
          // no need to expand pre, since it is guaranteed to be free of brace-sets

          const {pre} = m
          var post = m.post.length ? expand(m.post, false) : ['']
          let N

          if (isSequence) {
            const x = numeric(n[0])
            const y = numeric(n[1])
            const width = Math.max(n[0].length, n[1].length)
            let incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1
            let test = lte
            const reverse = y < x

            if (reverse) {
              incr *= -1
              test = gte
            }

            const pad = n.some(isPadded)
            N = []

            for (let i = x; test(i, y); i += incr) {
              var c

              if (isAlphaSequence) {
                c = String.fromCharCode(i)
                if (c === '\\') {
                  c = ''
                }
              } else {
                c = String(i)

                if (pad) {
                  const need = width - c.length

                  if (need > 0) {
                    const z = new Array(need + 1).join('0')
                    if (i < 0) {
                      c = `-${z}${c.slice(1)}`
                    } else {
                      c = z + c
                    }
                  }
                }
              }

              N.push(c)
            }
          } else {
            N = concatMap(n, function(element) {
              return expand(element, false)
            })
          }

          for (const element of N) {
            for (const element of post) {
              const expansion = pre + element + element
              if (!isTop || isSequence || expansion) {
                expansions.push(expansion)
              }
            }
          }

          return expansions
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 167 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          3
        )

        module.exports = function(xs, fn) {
          const res = []

          for (const [i, element] of xs.entries()) {
            const x = fn(element, i)
            if (isArray(x)) {
              res.push.apply(res, x)
            } else {
              res.push(x)
            }
          }

          return res
        }

        var isArray =
          Array.isArray ||
          function(xs) {
            return Object.prototype.toString.call(xs) === '[object Array]'
          }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 168 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          21
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          16
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          3
        )
        /* harmony import */ const core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          28
        )

        module.exports = balanced

        function balanced(a, b, string) {
          if (a instanceof RegExp) {
            a = maybeMatch(a, string)
          }
          if (b instanceof RegExp) {
            b = maybeMatch(b, string)
          }
          const r = range(a, b, string)
          return (
            r && {
              start: r[0],
              end: r[1],
              pre: string.slice(0, r[0]),
              body: string.slice(r[0] + a.length, r[1]),
              post: string.slice(r[1] + b.length),
            }
          )
        }

        function maybeMatch(reg, string) {
          const m = string.match(reg)
          return m ? m[0] : null
        }

        balanced.range = range

        function range(a, b, string) {
          let begs
          let beg
          let left
          let right
          let result
          let ai = string.indexOf(a)
          let bi = string.indexOf(b, ai + 1)
          let i = ai

          if (ai >= 0 && bi > 0) {
            begs = []
            left = string.length

            while (i >= 0 && !result) {
              if (i == ai) {
                begs.push(i)
                ai = string.indexOf(a, i + 1)
              } else if (begs.length == 1) {
                result = [begs.pop(), bi]
              } else {
                beg = begs.pop()

                if (beg < left) {
                  left = beg
                  right = bi
                }

                bi = string.indexOf(b, i + 1)
              }

              i = ai < bi && ai >= 0 ? ai : bi
            }

            if (begs.length) {
              result = [left, right]
            }
          }

          return result
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 169 */
    /** */ function(module, exports, __webpack_require__) {
      try {
        const util = __webpack_require__(36)
        /* istanbul ignore next */

        if (typeof util.inherits !== 'function') {
          throw ''
        }
        module.exports = util.inherits
      } catch (error) {
        /* istanbul ignore next */
        module.exports = __webpack_require__(170)
      }

      /** */
    },
    /* 170 */
    /** */ function(module, exports) {
      if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true,
              },
            })
          }
        }
      } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor

            const TemporaryCtor = function TemporaryCtor_() {}

            TemporaryCtor.prototype = superCtor.prototype
            ctor.prototype = new TemporaryCtor()
            ctor.prototype.constructor = ctor
          }
        }
      }

      /** */
    },
    /* 171 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          11
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          28
        )
        /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          14
        )

        module.exports = globSync
        globSync.GlobSync = GlobSync

        const fs = __webpack_require__(35)

        const rp = __webpack_require__(133)

        const minimatch = __webpack_require__(101)

        const {Minimatch} = minimatch

        const {Glob} = __webpack_require__(132)

        const util = __webpack_require__(36)

        const path = __webpack_require__(15)

        const assert = __webpack_require__(135)

        const isAbsolute = __webpack_require__(102)

        const common = __webpack_require__(136)

        const {alphasort} = common
        const {alphasorti} = common
        const {setopts} = common
        const {ownProperty} = common
        const {childrenIgnored} = common
        const {isIgnored} = common

        function globSync(pattern, options) {
          if (typeof options === 'function' || arguments.length === 3) {
            throw new TypeError(
              'callback provided to sync glob\n' +
                'See: https://github.com/isaacs/node-glob/issues/167'
            )
          }
          return new GlobSync(pattern, options).found
        }

        function GlobSync(pattern, options) {
          if (!pattern) {
            throw new Error('must provide pattern')
          }
          if (typeof options === 'function' || arguments.length === 3) {
            throw new TypeError(
              'callback provided to sync glob\n' +
                'See: https://github.com/isaacs/node-glob/issues/167'
            )
          }
          if (!(this instanceof GlobSync)) {
            return new GlobSync(pattern, options)
          }
          setopts(this, pattern, options)
          if (this.noprocess) {
            return this
          }
          const n = this.minimatch.set.length
          this.matches = new Array(n)

          for (let i = 0; i < n; i++) {
            this._process(this.minimatch.set[i], i, false)
          }

          this._finish()
        }

        GlobSync.prototype._finish = function() {
          assert(this instanceof GlobSync)

          if (this.realpath) {
            const self = this
            this.matches.forEach(function(matchset, index) {
              const set = (self.matches[index] = Object.create(null))

              for (let p in matchset) {
                try {
                  p = self._makeAbs(p)
                  const real = rp.realpathSync(p, self.realpathCache)
                  set[real] = true
                } catch (error) {
                  if (error.syscall === 'stat') {
                    set[self._makeAbs(p)] = true
                  } else {
                    throw error
                  }
                }
              }
            })
          }

          common.finish(this)
        }

        GlobSync.prototype._process = function(pattern, index, inGlobStar) {
          assert(this instanceof GlobSync) // Get the first [n] parts of pattern that are all strings.

          let n = 0

          while (typeof pattern[n] === 'string') {
            n++
          } // now n is the index of the first one that is *not* a string.
          // See if there's anything else

          let prefix

          switch (n) {
            // if not, then this is rather simple
            case pattern.length:
              this._processSimple(pattern.join('/'), index)

              return

            case 0:
              // pattern *starts* with some non-trivial item.
              // going to readdir(cwd), but not include the prefix in matches.
              prefix = null
              break

            default:
              // pattern has some string bits in the front.
              // whatever it starts with, whether that's 'absolute' like /foo/bar,
              // or 'relative' like '../baz'
              prefix = pattern.slice(0, n).join('/')
              break
          }

          const remain = pattern.slice(n) // get the list of entries.

          let read
          if (prefix === null) {
            read = '.'
          } else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
            if (!prefix || !isAbsolute(prefix)) {
              prefix = `/${prefix}`
            }
            read = prefix
          } else {
            read = prefix
          }

          const abs = this._makeAbs(read) // if ignored, skip processing

          if (childrenIgnored(this, read)) {
            return
          }
          const isGlobStar = remain[0] === minimatch.GLOBSTAR
          if (isGlobStar) {
            this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
          } else {
            this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
          }
        }

        GlobSync.prototype._processReaddir = function(
          prefix,
          read,
          abs,
          remain,
          index,
          inGlobStar
        ) {
          const entries = this._readdir(abs, inGlobStar) // if the abs isn't a dir, then nothing can match!

          if (!entries) {
            return
          } // It will only match dot entries if it starts with a dot, or if
          // dot is set.  Stuff like @(.foo|.bar) isn't allowed.

          const pn = remain[0]
          const negate = !!this.minimatch.negate
          const rawGlob = pn._glob
          const dotOk = this.dot || rawGlob.charAt(0) === '.'
          const matchedEntries = []

          for (var i = 0; i < entries.length; i++) {
            var e = entries[i]

            if (e.charAt(0) !== '.' || dotOk) {
              var m

              if (negate && !prefix) {
                m = !e.match(pn)
              } else {
                m = e.match(pn)
              }

              if (m) {
                matchedEntries.push(e)
              }
            }
          }

          const length_ = matchedEntries.length // If there are no matched entries, then nothing matches.

          if (length_ === 0) {
            return
          } // if this is the last remaining pattern bit, then no need for
          // an additional stat *unless* the user has specified mark or
          // stat explicitly.  We know they exist, since readdir returned
          // them.

          if (remain.length === 1 && !this.mark && !this.stat) {
            if (!this.matches[index]) {
              this.matches[index] = Object.create(null)
            }

            for (var i = 0; i < length_; i++) {
              var e = matchedEntries[i]

              if (prefix) {
                if (prefix.slice(-1) !== '/') {
                  e = `${prefix}/${e}`
                } else {
                  e = prefix + e
                }
              }

              if (e.charAt(0) === '/' && !this.nomount) {
                e = path.join(this.root, e)
              }

              this._emitMatch(index, e)
            } // This was the last one, and no stats were needed

            return
          } // now test all matched entries as stand-ins for that part
          // of the pattern.

          remain.shift()

          for (var i = 0; i < length_; i++) {
            var e = matchedEntries[i]
            var newPattern
            if (prefix) {
              newPattern = [prefix, e]
            } else {
              newPattern = [e]
            }

            this._process(newPattern.concat(remain), index, inGlobStar)
          }
        }

        GlobSync.prototype._emitMatch = function(index, e) {
          if (isIgnored(this, e)) {
            return
          }

          const abs = this._makeAbs(e)

          if (this.mark) {
            e = this._mark(e)
          }

          if (this.absolute) {
            e = abs
          }

          if (this.matches[index][e]) {
            return
          }

          if (this.nodir) {
            const c = this.cache[abs]
            if (c === 'DIR' || Array.isArray(c)) {
              return
            }
          }

          this.matches[index][e] = true
          if (this.stat) {
            this._stat(e)
          }
        }

        GlobSync.prototype._readdirInGlobStar = function(abs) {
          // follow all symlinked directories forever
          // just proceed as if this is a non-globstar situation
          if (this.follow) {
            return this._readdir(abs, false)
          }
          let entries
          let lstat
          let stat

          try {
            lstat = fs.lstatSync(abs)
          } catch (error) {
            if (error.code === 'ENOENT') {
              // lstat failed, doesn't exist
              return null
            }
          }

          const isSym = lstat && lstat.isSymbolicLink()
          this.symlinks[abs] = isSym // If it's not a symlink or a dir, then it's definitely a regular file.
          // don't bother doing a readdir in that case.

          if (!isSym && lstat && !lstat.isDirectory()) {
            this.cache[abs] = 'FILE'
          } else {
            entries = this._readdir(abs, false)
          }
          return entries
        }

        GlobSync.prototype._readdir = function(abs, inGlobStar) {
          let entries
          if (inGlobStar && !ownProperty(this.symlinks, abs)) {
            return this._readdirInGlobStar(abs)
          }

          if (ownProperty(this.cache, abs)) {
            const c = this.cache[abs]
            if (!c || c === 'FILE') {
              return null
            }
            if (Array.isArray(c)) {
              return c
            }
          }

          try {
            return this._readdirEntries(abs, fs.readdirSync(abs))
          } catch (error) {
            this._readdirError(abs, error)

            return null
          }
        }

        GlobSync.prototype._readdirEntries = function(abs, entries) {
          // if we haven't asked to stat everything, then just
          // assume that everything in there exists, so we can avoid
          // having to stat it a second time.
          if (!this.mark && !this.stat) {
            for (const e of entries) {
              if (abs === '/') {
                e = abs + e
              } else {
                e = `${abs}/${e}`
              }
              this.cache[e] = true
            }
          }

          this.cache[abs] = entries // mark and cache dir-ness

          return entries
        }

        GlobSync.prototype._readdirError = function(f, er) {
          // handle errors, and cache the information
          switch (er.code) {
            case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205

            case 'ENOTDIR':
              // totally normal. means it *does* exist.
              var abs = this._makeAbs(f)

              this.cache[abs] = 'FILE'

              if (abs === this.cwdAbs) {
                const error = new Error(`${er.code} invalid cwd ${this.cwd}`)
                error.path = this.cwd
                error.code = er.code
                throw error
              }

              break

            case 'ENOENT': // not terribly unusual

            case 'ELOOP':
            case 'ENAMETOOLONG':
            case 'UNKNOWN':
              this.cache[this._makeAbs(f)] = false
              break

            default:
              // some unusual error.  Treat as failure.
              this.cache[this._makeAbs(f)] = false
              if (this.strict) {
                throw er
              }
              if (!this.silent) {
                console.error('glob error', er)
              }
              break
          }
        }

        GlobSync.prototype._processGlobStar = function(
          prefix,
          read,
          abs,
          remain,
          index,
          inGlobStar
        ) {
          const entries = this._readdir(abs, inGlobStar) // no entries means not a dir, so it can never have matches
          // foo.txt/** doesn't match foo.txt

          if (!entries) {
            return
          } // test without the globstar, and with every child both below
          // and replacing the globstar.

          const remainWithoutGlobStar = remain.slice(1)
          const gspref = prefix ? [prefix] : []
          const noGlobStar = gspref.concat(remainWithoutGlobStar) // the noGlobStar pattern exits the inGlobStar state

          this._process(noGlobStar, index, false)

          const length_ = entries.length
          const isSym = this.symlinks[abs] // If it's a symlink, and we're in a globstar, then stop

          if (isSym && inGlobStar) {
            return
          }

          for (let i = 0; i < length_; i++) {
            const e = entries[i]
            if (e.charAt(0) === '.' && !this.dot) {
              continue
            } // these two cases enter the inGlobStar state

            const instead = gspref.concat(entries[i], remainWithoutGlobStar)

            this._process(instead, index, true)

            const below = gspref.concat(entries[i], remain)

            this._process(below, index, true)
          }
        }

        GlobSync.prototype._processSimple = function(prefix, index) {
          // XXX review this.  Shouldn't it be doing the mounting etc
          // before doing stat?  kinda weird?
          const exists = this._stat(prefix)

          if (!this.matches[index]) {
            this.matches[index] = Object.create(null)
          } // If it doesn't exist, then just mark the lack of results

          if (!exists) {
            return
          }

          if (prefix && isAbsolute(prefix) && !this.nomount) {
            const trail = /[\/\\]$/.test(prefix)

            if (prefix.charAt(0) === '/') {
              prefix = path.join(this.root, prefix)
            } else {
              prefix = path.resolve(this.root, prefix)
              if (trail) {
                prefix += '/'
              }
            }
          }

          if (process.platform === 'win32') {
            prefix = prefix.replace(/\\/g, '/')
          } // Mark this as a match

          this._emitMatch(index, prefix)
        } // Returns either 'DIR', 'FILE', or false

        GlobSync.prototype._stat = function(f) {
          const abs = this._makeAbs(f)

          const needDir = f.slice(-1) === '/'
          if (f.length > this.maxLength) {
            return false
          }

          if (!this.stat && ownProperty(this.cache, abs)) {
            var c = this.cache[abs]
            if (Array.isArray(c)) {
              c = 'DIR'
            } // It exists, but maybe not how we need it

            if (!needDir || c === 'DIR') {
              return c
            }
            if (needDir && c === 'FILE') {
              return false
            } // otherwise we have to stat, because maybe c=true
            // if we know it exists, but not what it is.
          }

          let exists
          let stat = this.statCache[abs]

          if (!stat) {
            let lstat

            try {
              lstat = fs.lstatSync(abs)
            } catch (error) {
              if (
                error &&
                (error.code === 'ENOENT' || error.code === 'ENOTDIR')
              ) {
                this.statCache[abs] = false
                return false
              }
            }

            if (lstat && lstat.isSymbolicLink()) {
              try {
                stat = fs.statSync(abs)
              } catch (error) {
                stat = lstat
              }
            } else {
              stat = lstat
            }
          }

          this.statCache[abs] = stat
          var c = true
          if (stat) {
            c = stat.isDirectory() ? 'DIR' : 'FILE'
          }
          this.cache[abs] = this.cache[abs] || c
          if (needDir && c === 'FILE') {
            return false
          }
          return c
        }

        GlobSync.prototype._mark = function(p) {
          return common.mark(this, p)
        }

        GlobSync.prototype._makeAbs = function(f) {
          return common.makeAbs(this, f)
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 172 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_splice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          94
        )
        /* harmony import */ const core_js_modules_es_array_splice__WEBPACK_IMPORTED_MODULE_0___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_splice__WEBPACK_IMPORTED_MODULE_0__
        )

        const wrappy = __webpack_require__(137)

        const reqs = Object.create(null)

        const once = __webpack_require__(138)

        module.exports = wrappy(inflight)

        function inflight(key, callback) {
          if (reqs[key]) {
            reqs[key].push(callback)
            return null
          }
          reqs[key] = [callback]
          return makeres(key)
        }

        function makeres(key) {
          return once(function RES() {
            const cbs = reqs[key]
            const length_ = cbs.length
            const arguments_ = slice(arguments) // XXX It's somewhat ambiguous whether a new callback added in this
            // pass should be queued for later execution if something in the
            // list of callbacks throws, or if it should just be discarded.
            // However, it's such an edge case that it hardly matters, and either
            // choice is likely as surprising as the other.
            // As it happens, we do go ahead and schedule it for later execution.

            try {
              for (let i = 0; i < length_; i++) {
                cbs[i].apply(null, arguments_)
              }
            } finally {
              if (cbs.length > length_) {
                // added more in the interim.
                // de-zalgo, just in case, but don't call again.
                cbs.splice(0, length_)
                process.nextTick(function() {
                  RES.apply(null, arguments_)
                })
              } else {
                delete reqs[key]
              }
            }
          })
        }

        function slice(arguments_) {
          const {length} = arguments_
          const array = []

          for (let i = 0; i < length; i++) {
            array[i] = arguments_[i]
          }

          return array
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 173 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          2
        )

        /*!
         * is-extglob <https://github.com/jonschlinkert/is-extglob>
         *
         * Copyright (c) 2014-2016, Jon Schlinkert.
         * Licensed under the MIT License.
         */
        module.exports = function isExtglob(string) {
          if (typeof string !== 'string' || string === '') {
            return false
          }

          let match

          while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(string))) {
            if (match[2]) {
              return true
            }
            string = string.slice(match.index + match[0].length)
          }

          return false
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 174 */
    /** */ function(module, exports, __webpack_require__) {
      Object.defineProperty(exports, '__esModule', {
        value: true,
      })

      const convert_1 = __webpack_require__(139)

      const convert_comments_1 = __webpack_require__(179)

      const node_utils_1 = __webpack_require__(73)

      function astConverter(ast, extra, shouldPreserveNodeMaps) {
        /**
         * The TypeScript compiler produced fundamental parse errors when parsing the
         * source.
         */
        // internal typescript api...
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const {parseDiagnostics} = ast

        if (parseDiagnostics.length) {
          throw convert_1.convertError(parseDiagnostics[0])
        }
        /**
         * Recursively convert the TypeScript AST into an ESTree-compatible AST
         */

        const instance = new convert_1.Converter(ast, {
          errorOnUnknownASTType: extra.errorOnUnknownASTType || false,
          useJSXTextNode: extra.useJSXTextNode || false,
          shouldPreserveNodeMaps,
        })
        const estree = instance.convertProgram()
        /**
         * Optionally convert and include all tokens in the AST
         */

        if (extra.tokens) {
          estree.tokens = node_utils_1.convertTokens(ast)
        }
        /**
         * Optionally convert and include all comments in the AST
         */

        if (extra.comment) {
          estree.comments = convert_comments_1.convertComments(ast, extra.code)
        }

        const astMaps = shouldPreserveNodeMaps
          ? instance.getASTMaps()
          : undefined
        return {
          estree,
          astMaps,
        }
      }

      exports.astConverter = astConverter

      /** */
    },
    /* 175 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_last_index_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          48
        )

        const toIndexedObject = __webpack_require__(29)

        const toInteger = __webpack_require__(39)

        const toLength = __webpack_require__(22)

        const sloppyArrayMethod = __webpack_require__(85)

        const {min} = Math
        const nativeLastIndexOf = [].lastIndexOf
        const NEGATIVE_ZERO =
          !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0
        const SLOPPY_METHOD = sloppyArrayMethod('lastIndexOf') // `Array.prototype.lastIndexOf` method implementation
        // https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof

        module.exports =
          NEGATIVE_ZERO || SLOPPY_METHOD
            ? function lastIndexOf(
                searchElement
                /* , fromIndex = @[*-1] */
              ) {
                // convert -0 to +0
                if (NEGATIVE_ZERO) {
                  return Reflect.apply(nativeLastIndexOf, this, arguments) || 0
                }
                const O = toIndexedObject(this)
                const length = toLength(O.length)
                let index = length - 1
                if (arguments.length > 1) {
                  index = min(index, toInteger(arguments[1]))
                }
                if (index < 0) {
                  index = length + index
                }

                for (; index >= 0; index--) {
                  if (index in O && O[index] === searchElement) {
                    return index || 0
                  }
                }

                return -1
              }
            : nativeLastIndexOf
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 176 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          16
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          3
        )
        /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          14
        )

        /**
         * lodash (Custom Build) <https://lodash.com/>
         * Build: `lodash modularize exports="npm" -o ./`
         * Copyright jQuery Foundation and other contributors <https://jquery.org/>
         * Released under MIT license <https://lodash.com/license>
         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
         */

        /** Used as references for various `Number` constants. */
        const INFINITY = 1 / 0
        /** `Object#toString` result references. */

        const symbolTag = '[object Symbol]'
        /** Used to match HTML entities and HTML characters. */

        const reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g
        const reHasEscapedHtml = new RegExp(reEscapedHtml.source)
        /** Used to map HTML entities to characters. */

        const htmlUnescapes = {
          '&amp;': '&',
          '&lt;': '<',
          '&gt;': '>',
          '&quot;': '"',
          '&#39;': "'",
          '&#96;': '`',
        }
        /** Detect free variable `global` from Node.js. */

        const freeGlobal =
          typeof global === 'object' &&
          global &&
          global.Object === Object &&
          global
        /** Detect free variable `self`. */

        const freeSelf =
          typeof self === 'object' && self && self.Object === Object && self
        /** Used as a reference to the global object. */

        const root = freeGlobal || freeSelf || new Function('return this')()
        /**
         * The base implementation of `_.propertyOf` without support for deep paths.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new accessor function.
         */

        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined : object[key]
          }
        }
        /**
         * Used by `_.unescape` to convert HTML entities to characters.
         *
         * @private
         * @param {string} chr The matched character to unescape.
         * @returns {string} Returns the unescaped character.
         */

        const unescapeHtmlChar = basePropertyOf(htmlUnescapes)
        /** Used for built-in method references. */

        const objectProto = Object.prototype
        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */

        const objectToString = objectProto.toString
        /** Built-in value references. */

        const {Symbol} = root
        /** Used to convert symbols to primitives and strings. */

        const symbolProto = Symbol ? Symbol.prototype : undefined
        const symbolToString = symbolProto ? symbolProto.toString : undefined
        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */

        function baseToString(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value === 'string') {
            return value
          }

          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : ''
          }

          const result = String(value)
          return result == '0' && 1 / value == -INFINITY ? '-0' : result
        }
        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */

        function isObjectLike(value) {
          return !!value && typeof value === 'object'
        }
        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */

        function isSymbol(value) {
          return (
            typeof value === 'symbol' ||
            (isObjectLike(value) && objectToString.call(value) == symbolTag)
          )
        }
        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */

        function toString(value) {
          return value == null ? '' : baseToString(value)
        }
        /**
         * The inverse of `_.escape`; this method converts the HTML entities
         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to
         * their corresponding characters.
         *
         * **Note:** No other HTML entities are unescaped. To unescape additional
         * HTML entities use a third-party library like [_he_](https://mths.be/he).
         *
         * @static
         * @memberOf _
         * @since 0.6.0
         * @category String
         * @param {string} [string=''] The string to unescape.
         * @returns {string} Returns the unescaped string.
         * @example
         *
         * _.unescape('fred, barney, &amp; pebbles');
         * // => 'fred, barney, & pebbles'
         */

        function unescape(string) {
          string = toString(string)
          return string && reHasEscapedHtml.test(string)
            ? string.replace(reEscapedHtml, unescapeHtmlChar)
            : string
        }

        module.exports = unescape
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 177 */
    /** */ function(module, exports, __webpack_require__) {
      Object.defineProperty(exports, '__esModule', {
        value: true,
      })

      /** */
    },
    /* 178 */
    /** */ function(module, exports, __webpack_require__) {
      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      let AST_NODE_TYPES
      ;(function(AST_NODE_TYPES) {
        AST_NODE_TYPES.ArrayExpression = 'ArrayExpression'
        AST_NODE_TYPES.ArrayPattern = 'ArrayPattern'
        AST_NODE_TYPES.ArrowFunctionExpression = 'ArrowFunctionExpression'
        AST_NODE_TYPES.AssignmentExpression = 'AssignmentExpression'
        AST_NODE_TYPES.AssignmentPattern = 'AssignmentPattern'
        AST_NODE_TYPES.AwaitExpression = 'AwaitExpression'
        AST_NODE_TYPES.BigIntLiteral = 'BigIntLiteral'
        AST_NODE_TYPES.BinaryExpression = 'BinaryExpression'
        AST_NODE_TYPES.BlockStatement = 'BlockStatement'
        AST_NODE_TYPES.BreakStatement = 'BreakStatement'
        AST_NODE_TYPES.CallExpression = 'CallExpression'
        AST_NODE_TYPES.CatchClause = 'CatchClause'
        AST_NODE_TYPES.ClassBody = 'ClassBody'
        AST_NODE_TYPES.ClassDeclaration = 'ClassDeclaration'
        AST_NODE_TYPES.ClassExpression = 'ClassExpression'
        AST_NODE_TYPES.ClassProperty = 'ClassProperty'
        AST_NODE_TYPES.ConditionalExpression = 'ConditionalExpression'
        AST_NODE_TYPES.ContinueStatement = 'ContinueStatement'
        AST_NODE_TYPES.DebuggerStatement = 'DebuggerStatement'
        AST_NODE_TYPES.Decorator = 'Decorator'
        AST_NODE_TYPES.DoWhileStatement = 'DoWhileStatement'
        AST_NODE_TYPES.EmptyStatement = 'EmptyStatement'
        AST_NODE_TYPES.ExportAllDeclaration = 'ExportAllDeclaration'
        AST_NODE_TYPES.ExportDefaultDeclaration = 'ExportDefaultDeclaration'
        AST_NODE_TYPES.ExportNamedDeclaration = 'ExportNamedDeclaration'
        AST_NODE_TYPES.ExportSpecifier = 'ExportSpecifier'
        AST_NODE_TYPES.ExpressionStatement = 'ExpressionStatement'
        AST_NODE_TYPES.ForInStatement = 'ForInStatement'
        AST_NODE_TYPES.ForOfStatement = 'ForOfStatement'
        AST_NODE_TYPES.ForStatement = 'ForStatement'
        AST_NODE_TYPES.FunctionDeclaration = 'FunctionDeclaration'
        AST_NODE_TYPES.FunctionExpression = 'FunctionExpression'
        AST_NODE_TYPES.Identifier = 'Identifier'
        AST_NODE_TYPES.IfStatement = 'IfStatement'
        AST_NODE_TYPES.Import = 'Import'
        AST_NODE_TYPES.ImportDeclaration = 'ImportDeclaration'
        AST_NODE_TYPES.ImportDefaultSpecifier = 'ImportDefaultSpecifier'
        AST_NODE_TYPES.ImportNamespaceSpecifier = 'ImportNamespaceSpecifier'
        AST_NODE_TYPES.ImportSpecifier = 'ImportSpecifier'
        AST_NODE_TYPES.JSXAttribute = 'JSXAttribute'
        AST_NODE_TYPES.JSXClosingElement = 'JSXClosingElement'
        AST_NODE_TYPES.JSXClosingFragment = 'JSXClosingFragment'
        AST_NODE_TYPES.JSXElement = 'JSXElement'
        AST_NODE_TYPES.JSXEmptyExpression = 'JSXEmptyExpression'
        AST_NODE_TYPES.JSXExpressionContainer = 'JSXExpressionContainer'
        AST_NODE_TYPES.JSXFragment = 'JSXFragment'
        AST_NODE_TYPES.JSXIdentifier = 'JSXIdentifier'
        AST_NODE_TYPES.JSXMemberExpression = 'JSXMemberExpression'
        AST_NODE_TYPES.JSXOpeningElement = 'JSXOpeningElement'
        AST_NODE_TYPES.JSXOpeningFragment = 'JSXOpeningFragment'
        AST_NODE_TYPES.JSXSpreadAttribute = 'JSXSpreadAttribute'
        AST_NODE_TYPES.JSXSpreadChild = 'JSXSpreadChild'
        AST_NODE_TYPES.JSXText = 'JSXText'
        AST_NODE_TYPES.LabeledStatement = 'LabeledStatement'
        AST_NODE_TYPES.Literal = 'Literal'
        AST_NODE_TYPES.LogicalExpression = 'LogicalExpression'
        AST_NODE_TYPES.MemberExpression = 'MemberExpression'
        AST_NODE_TYPES.MetaProperty = 'MetaProperty'
        AST_NODE_TYPES.MethodDefinition = 'MethodDefinition'
        AST_NODE_TYPES.NewExpression = 'NewExpression'
        AST_NODE_TYPES.ObjectExpression = 'ObjectExpression'
        AST_NODE_TYPES.ObjectPattern = 'ObjectPattern'
        AST_NODE_TYPES.OptionalCallExpression = 'OptionalCallExpression'
        AST_NODE_TYPES.OptionalMemberExpression = 'OptionalMemberExpression'
        AST_NODE_TYPES.Program = 'Program'
        AST_NODE_TYPES.Property = 'Property'
        AST_NODE_TYPES.RestElement = 'RestElement'
        AST_NODE_TYPES.ReturnStatement = 'ReturnStatement'
        AST_NODE_TYPES.SequenceExpression = 'SequenceExpression'
        AST_NODE_TYPES.SpreadElement = 'SpreadElement'
        AST_NODE_TYPES.Super = 'Super'
        AST_NODE_TYPES.SwitchCase = 'SwitchCase'
        AST_NODE_TYPES.SwitchStatement = 'SwitchStatement'
        AST_NODE_TYPES.TaggedTemplateExpression = 'TaggedTemplateExpression'
        AST_NODE_TYPES.TemplateElement = 'TemplateElement'
        AST_NODE_TYPES.TemplateLiteral = 'TemplateLiteral'
        AST_NODE_TYPES.ThisExpression = 'ThisExpression'
        AST_NODE_TYPES.ThrowStatement = 'ThrowStatement'
        AST_NODE_TYPES.TryStatement = 'TryStatement'
        AST_NODE_TYPES.UnaryExpression = 'UnaryExpression'
        AST_NODE_TYPES.UpdateExpression = 'UpdateExpression'
        AST_NODE_TYPES.VariableDeclaration = 'VariableDeclaration'
        AST_NODE_TYPES.VariableDeclarator = 'VariableDeclarator'
        AST_NODE_TYPES.WhileStatement = 'WhileStatement'
        AST_NODE_TYPES.WithStatement = 'WithStatement'
        AST_NODE_TYPES.YieldExpression = 'YieldExpression'
        /**
         * TS-prefixed nodes
         */

        AST_NODE_TYPES.TSAbstractClassProperty = 'TSAbstractClassProperty'
        AST_NODE_TYPES.TSAbstractKeyword = 'TSAbstractKeyword'
        AST_NODE_TYPES.TSAbstractMethodDefinition = 'TSAbstractMethodDefinition'
        AST_NODE_TYPES.TSAnyKeyword = 'TSAnyKeyword'
        AST_NODE_TYPES.TSArrayType = 'TSArrayType'
        AST_NODE_TYPES.TSAsExpression = 'TSAsExpression'
        AST_NODE_TYPES.TSAsyncKeyword = 'TSAsyncKeyword'
        AST_NODE_TYPES.TSBooleanKeyword = 'TSBooleanKeyword'
        AST_NODE_TYPES.TSBigIntKeyword = 'TSBigIntKeyword'
        AST_NODE_TYPES.TSConditionalType = 'TSConditionalType'
        AST_NODE_TYPES.TSConstructorType = 'TSConstructorType'
        AST_NODE_TYPES.TSCallSignatureDeclaration = 'TSCallSignatureDeclaration'
        AST_NODE_TYPES.TSClassImplements = 'TSClassImplements'
        AST_NODE_TYPES.TSConstructSignatureDeclaration =
          'TSConstructSignatureDeclaration'
        AST_NODE_TYPES.TSDeclareKeyword = 'TSDeclareKeyword'
        AST_NODE_TYPES.TSDeclareFunction = 'TSDeclareFunction'
        AST_NODE_TYPES.TSEmptyBodyFunctionExpression =
          'TSEmptyBodyFunctionExpression'
        AST_NODE_TYPES.TSEnumDeclaration = 'TSEnumDeclaration'
        AST_NODE_TYPES.TSEnumMember = 'TSEnumMember'
        AST_NODE_TYPES.TSExportAssignment = 'TSExportAssignment'
        AST_NODE_TYPES.TSExportKeyword = 'TSExportKeyword'
        AST_NODE_TYPES.TSExternalModuleReference = 'TSExternalModuleReference'
        AST_NODE_TYPES.TSImportType = 'TSImportType'
        AST_NODE_TYPES.TSInferType = 'TSInferType'
        AST_NODE_TYPES.TSLiteralType = 'TSLiteralType'
        AST_NODE_TYPES.TSIndexedAccessType = 'TSIndexedAccessType'
        AST_NODE_TYPES.TSIndexSignature = 'TSIndexSignature'
        AST_NODE_TYPES.TSInterfaceBody = 'TSInterfaceBody'
        AST_NODE_TYPES.TSInterfaceDeclaration = 'TSInterfaceDeclaration'
        AST_NODE_TYPES.TSInterfaceHeritage = 'TSInterfaceHeritage'
        AST_NODE_TYPES.TSImportEqualsDeclaration = 'TSImportEqualsDeclaration'
        AST_NODE_TYPES.TSFunctionType = 'TSFunctionType'
        AST_NODE_TYPES.TSMethodSignature = 'TSMethodSignature'
        AST_NODE_TYPES.TSModuleBlock = 'TSModuleBlock'
        AST_NODE_TYPES.TSModuleDeclaration = 'TSModuleDeclaration'
        AST_NODE_TYPES.TSNamespaceExportDeclaration =
          'TSNamespaceExportDeclaration'
        AST_NODE_TYPES.TSNonNullExpression = 'TSNonNullExpression'
        AST_NODE_TYPES.TSNeverKeyword = 'TSNeverKeyword'
        AST_NODE_TYPES.TSNullKeyword = 'TSNullKeyword'
        AST_NODE_TYPES.TSNumberKeyword = 'TSNumberKeyword'
        AST_NODE_TYPES.TSMappedType = 'TSMappedType'
        AST_NODE_TYPES.TSObjectKeyword = 'TSObjectKeyword'
        AST_NODE_TYPES.TSParameterProperty = 'TSParameterProperty'
        AST_NODE_TYPES.TSPrivateKeyword = 'TSPrivateKeyword'
        AST_NODE_TYPES.TSPropertySignature = 'TSPropertySignature'
        AST_NODE_TYPES.TSProtectedKeyword = 'TSProtectedKeyword'
        AST_NODE_TYPES.TSPublicKeyword = 'TSPublicKeyword'
        AST_NODE_TYPES.TSQualifiedName = 'TSQualifiedName'
        AST_NODE_TYPES.TSReadonlyKeyword = 'TSReadonlyKeyword'
        AST_NODE_TYPES.TSRestType = 'TSRestType'
        AST_NODE_TYPES.TSStaticKeyword = 'TSStaticKeyword'
        AST_NODE_TYPES.TSStringKeyword = 'TSStringKeyword'
        AST_NODE_TYPES.TSSymbolKeyword = 'TSSymbolKeyword'
        AST_NODE_TYPES.TSThisType = 'TSThisType'
        AST_NODE_TYPES.TSTypeAnnotation = 'TSTypeAnnotation'
        AST_NODE_TYPES.TSTypeAliasDeclaration = 'TSTypeAliasDeclaration'
        AST_NODE_TYPES.TSTypeAssertion = 'TSTypeAssertion'
        AST_NODE_TYPES.TSTypeLiteral = 'TSTypeLiteral'
        AST_NODE_TYPES.TSTypeOperator = 'TSTypeOperator'
        AST_NODE_TYPES.TSTypeParameter = 'TSTypeParameter'
        AST_NODE_TYPES.TSTypeParameterDeclaration = 'TSTypeParameterDeclaration'
        AST_NODE_TYPES.TSTypeParameterInstantiation =
          'TSTypeParameterInstantiation'
        AST_NODE_TYPES.TSTypePredicate = 'TSTypePredicate'
        AST_NODE_TYPES.TSTypeReference = 'TSTypeReference'
        AST_NODE_TYPES.TSTypeQuery = 'TSTypeQuery'
        AST_NODE_TYPES.TSIntersectionType = 'TSIntersectionType'
        AST_NODE_TYPES.TSTupleType = 'TSTupleType'
        AST_NODE_TYPES.TSOptionalType = 'TSOptionalType'
        AST_NODE_TYPES.TSParenthesizedType = 'TSParenthesizedType'
        AST_NODE_TYPES.TSUnionType = 'TSUnionType'
        AST_NODE_TYPES.TSUndefinedKeyword = 'TSUndefinedKeyword'
        AST_NODE_TYPES.TSUnknownKeyword = 'TSUnknownKeyword'
        AST_NODE_TYPES.TSVoidKeyword = 'TSVoidKeyword'
      })(
        (AST_NODE_TYPES =
          exports.AST_NODE_TYPES || (exports.AST_NODE_TYPES = {}))
      )

      let AST_TOKEN_TYPES
      ;(function(AST_TOKEN_TYPES) {
        AST_TOKEN_TYPES.Boolean = 'Boolean'
        AST_TOKEN_TYPES.Identifier = 'Identifier'
        AST_TOKEN_TYPES.JSXIdentifier = 'JSXIdentifier'
        AST_TOKEN_TYPES.JSXText = 'JSXText'
        AST_TOKEN_TYPES.Keyword = 'Keyword'
        AST_TOKEN_TYPES.Null = 'Null'
        AST_TOKEN_TYPES.Numeric = 'Numeric'
        AST_TOKEN_TYPES.Punctuator = 'Punctuator'
        AST_TOKEN_TYPES.RegularExpression = 'RegularExpression'
        AST_TOKEN_TYPES.String = 'String'
        AST_TOKEN_TYPES.Template = 'Template' // comment types

        AST_TOKEN_TYPES.Block = 'Block'
        AST_TOKEN_TYPES.Line = 'Line'
      })(
        (AST_TOKEN_TYPES =
          exports.AST_TOKEN_TYPES || (exports.AST_TOKEN_TYPES = {}))
      )

      /** */
    },
    /* 179 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        14
      )

      const __importStar =
        (undefined && undefined.__importStar) ||
        function(module_) {
          if (module_ && module_.__esModule) {
            return module_
          }
          const result = {}
          if (module_ != null) {
            for (const k in module_) {
              if (Object.hasOwnProperty.call(module_, k)) {
                result[k] = module_[k]
              }
            }
          }
          result.default = module_
          return result
        }

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })

      const ts = __importStar(__webpack_require__(47)) // leave this as * as ts so people using util package don't need syntheticDefaultImports

      const node_utils_1 = __webpack_require__(73)
      /**
       * Converts a TypeScript comment to an Esprima comment.
       * @param block True if it's a block comment, false if not.
       * @param text The text of the comment.
       * @param start The index at which the comment starts.
       * @param end The index at which the comment ends.
       * @param startLoc The location at which the comment starts.
       * @param endLoc The location at which the comment ends.
       * @returns The comment object.
       * @internal
       */

      function convertTypeScriptCommentToEsprimaComment(
        block,
        text,
        start,
        end,
        startLoc,
        endLoc
      ) {
        const comment = {
          type: block ? 'Block' : 'Line',
          value: text,
        }

        if (typeof start === 'number') {
          comment.range = [start, end]
        }

        if (typeof startLoc === 'object') {
          comment.loc = {
            start: startLoc,
            end: endLoc,
          }
        }

        return comment
      }
      /**
       * Convert comment from TypeScript Triva Scanner.
       * @param triviaScanner TS Scanner
       * @param ast the AST object
       * @param code TypeScript code
       * @returns the converted Comment
       * @private
       */

      function getCommentFromTriviaScanner(triviaScanner, ast, code) {
        const kind = triviaScanner.getToken()
        const isBlock = kind === ts.SyntaxKind.MultiLineCommentTrivia
        const range = {
          pos: triviaScanner.getTokenPos(),
          end: triviaScanner.getTextPos(),
          kind: triviaScanner.getToken(),
        }
        const comment = code.substring(range.pos, range.end)
        const text = isBlock
          ? comment.replace(/^\/\*/, '').replace(/\*\/$/, '')
          : comment.replace(/^\/\//, '')
        const loc = node_utils_1.getLocFor(range.pos, range.end, ast)
        return convertTypeScriptCommentToEsprimaComment(
          isBlock,
          text,
          range.pos,
          range.end,
          loc.start,
          loc.end
        )
      }
      /**
       * Convert all comments for the given AST.
       * @param ast the AST object
       * @param code the TypeScript code
       * @returns the converted ESTreeComment
       * @private
       */

      function convertComments(ast, code) {
        const comments = []
        /**
         * Create a TypeScript Scanner, with skipTrivia set to false so that
         * we can parse the comments
         */

        const triviaScanner = ts.createScanner(
          ast.languageVersion,
          false,
          ast.languageVariant,
          code
        )
        let kind = triviaScanner.scan()

        while (kind !== ts.SyntaxKind.EndOfFileToken) {
          const start = triviaScanner.getTokenPos()
          const end = triviaScanner.getTextPos()
          let container = null

          switch (kind) {
            case ts.SyntaxKind.SingleLineCommentTrivia:
            case ts.SyntaxKind.MultiLineCommentTrivia: {
              const comment = getCommentFromTriviaScanner(
                triviaScanner,
                ast,
                code
              )
              comments.push(comment)
              break
            }

            case ts.SyntaxKind.GreaterThanToken:
              container = node_utils_1.getNodeContainer(ast, start, end)

              if (
                (container.parent &&
                container.parent.parent && // Rescan after an opening element or fragment
                container.parent.kind === ts.SyntaxKind.JsxOpeningElement && // Make sure this is the end of a tag like `<Component<number>>`
                  container.parent.end === end) ||
                container.parent.kind === ts.SyntaxKind.JsxOpeningFragment || // Rescan after a self-closing element if it's inside another JSX element
                (container.parent.kind ===
                  ts.SyntaxKind.JsxSelfClosingElement &&
                  (container.parent.parent.kind === ts.SyntaxKind.JsxElement ||
                    container.parent.parent.kind ===
                      ts.SyntaxKind.JsxFragment)) || // Rescan after a closing element if it's inside another JSX element
                ((container.parent.kind === ts.SyntaxKind.JsxClosingElement ||
                  container.parent.kind === ts.SyntaxKind.JsxClosingFragment) &&
                  container.parent.parent.parent &&
                  (container.parent.parent.parent.kind ===
                    ts.SyntaxKind.JsxElement ||
                    container.parent.parent.parent.kind ===
                      ts.SyntaxKind.JsxFragment))
              ) {
                kind = triviaScanner.reScanJsxToken()
                continue
              }

              break

            case ts.SyntaxKind.CloseBraceToken:
              container = node_utils_1.getNodeContainer(ast, start, end) // Rescan after a JSX expression

              if (
                container.parent &&
                container.parent.kind === ts.SyntaxKind.JsxExpression &&
                container.parent.parent &&
                container.parent.parent.kind === ts.SyntaxKind.JsxElement
              ) {
                kind = triviaScanner.reScanJsxToken()
                continue
              }

              if (
                container.kind === ts.SyntaxKind.TemplateMiddle ||
                container.kind === ts.SyntaxKind.TemplateTail
              ) {
                kind = triviaScanner.reScanTemplateToken()
                continue
              }

              break

            case ts.SyntaxKind.SlashToken:
            case ts.SyntaxKind.SlashEqualsToken:
              container = node_utils_1.getNodeContainer(ast, start, end)

              if (container.kind === ts.SyntaxKind.RegularExpressionLiteral) {
                kind = triviaScanner.reScanSlashToken()
                continue
              }

              break

            default:
              break
          }

          kind = triviaScanner.scan()
        }

        return comments
      }

      exports.convertComments = convertComments

      /** */
    },
    /* 180 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        13
      )
      /* harmony import */ const core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        32
      )

      const __importStar =
        (undefined && undefined.__importStar) ||
        function(module_) {
          if (module_ && module_.__esModule) {
            return module_
          }
          const result = {}
          if (module_ != null) {
            for (const k in module_) {
              if (Object.hasOwnProperty.call(module_, k)) {
                result[k] = module_[k]
              }
            }
          }
          result.default = module_
          return result
        }

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })

      const ts = __importStar(__webpack_require__(47)) // leave this as * as ts so people using util package don't need syntheticDefaultImports

      /**
       * By default, diagnostics from the TypeScript compiler contain all errors - regardless of whether
       * they are related to generic ECMAScript standards, or TypeScript-specific constructs.
       *
       * Therefore, we filter out all diagnostics, except for the ones we explicitly want to consider when
       * the user opts in to throwing errors on semantic issues.
       */

      function getFirstSemanticOrSyntacticError(program, ast) {
        try {
          const supportedSyntacticDiagnostics = whitelistSupportedDiagnostics(
            program.getSyntacticDiagnostics(ast)
          )

          if (supportedSyntacticDiagnostics.length) {
            return convertDiagnosticToSemanticOrSyntacticError(
              supportedSyntacticDiagnostics[0]
            )
          }

          const supportedSemanticDiagnostics = whitelistSupportedDiagnostics(
            program.getSemanticDiagnostics(ast)
          )

          if (supportedSemanticDiagnostics.length) {
            return convertDiagnosticToSemanticOrSyntacticError(
              supportedSemanticDiagnostics[0]
            )
          }

          return undefined
        } catch (error) {
          /**
           * TypeScript compiler has certain Debug.fail() statements in, which will cause the diagnostics
           * retrieval above to throw.
           *
           * E.g. from ast-alignment-tests
           * "Debug Failure. Shouldn't ever directly check a JsxOpeningElement"
           *
           * For our current use-cases this is undesired behavior, so we just suppress it
           * and log a a warning.
           */

          /* istanbul ignore next */
          console.warn(`Warning From TSC: "${error.message}`) // eslint-disable-line no-console

          /* istanbul ignore next */

          return undefined
        }
      }

      exports.getFirstSemanticOrSyntacticError = getFirstSemanticOrSyntacticError

      function whitelistSupportedDiagnostics(diagnostics) {
        return diagnostics.filter(function(diagnostic) {
          switch (diagnostic.code) {
            case 1013: // ts 3.2 "A rest parameter or binding pattern may not have a trailing comma."

            case 1014: // ts 3.2 "A rest parameter must be last in a parameter list."

            case 1044: // ts 3.2 "'{0}' modifier cannot appear on a module or namespace element."

            case 1045: // ts 3.2 "A '{0}' modifier cannot be used with an interface declaration."

            case 1048: // ts 3.2 "A rest parameter cannot have an initializer."

            case 1049: // ts 3.2 "A 'set' accessor must have exactly one parameter."

            case 1070: // ts 3.2 "'{0}' modifier cannot appear on a type member."

            case 1071: // ts 3.2 "'{0}' modifier cannot appear on an index signature."

            case 1085: // ts 3.2 "Octal literals are not available when targeting ECMAScript 5 and higher. Use the syntax '{0}'."

            case 1090: // ts 3.2 "'{0}' modifier cannot appear on a parameter."

            case 1096: // ts 3.2 "An index signature must have exactly one parameter."

            case 1097: // ts 3.2 "'{0}' list cannot be empty."

            case 1098: // ts 3.3 "Type parameter list cannot be empty."

            case 1099: // ts 3.3 "Type argument list cannot be empty."

            case 1117: // ts 3.2 "An object literal cannot have multiple properties with the same name in strict mode."

            case 1121: // ts 3.2 "Octal literals are not allowed in strict mode."

            case 1123: // ts 3.2: "Variable declaration list cannot be empty."

            case 1141: // ts 3.2 "String literal expected."

            case 1162: // ts 3.2 "An object member cannot be declared optional."

            case 1172: // ts 3.2 "'extends' clause already seen."

            case 1173: // ts 3.2 "'extends' clause must precede 'implements' clause."

            case 1175: // ts 3.2 "'implements' clause already seen."

            case 1176: // ts 3.2 "Interface declaration cannot have 'implements' clause."

            case 1190: // ts 3.2 "The variable declaration of a 'for...of' statement cannot have an initializer."

            case 1200: // ts 3.2 "Line terminator not permitted before arrow."

            case 1206: // ts 3.2 "Decorators are not valid here."

            case 1211: // ts 3.2 "A class declaration without the 'default' modifier must have a name."

            case 1242: // ts 3.2 "'abstract' modifier can only appear on a class, method, or property declaration."

            case 1246: // ts 3.2 "An interface property cannot have an initializer."

            case 1255: // ts 3.2 "A definite assignment assertion '!' is not permitted in this context."

            case 1308: // ts 3.2 "'await' expression is only allowed within an async function."

            case 2364: // ts 3.2 "The left-hand side of an assignment expression must be a variable or a property access."

            case 2369: // ts 3.2 "A parameter property is only allowed in a constructor implementation."

            case 2462: // ts 3.2 "A rest element must be last in a destructuring pattern."

            case 8017: // ts 3.2 "Octal literal types must use ES2015 syntax. Use the syntax '{0}'."

            case 17012: // ts 3.2 "'{0}' is not a valid meta-property for keyword '{1}'. Did you mean '{2}'?"

            case 17013:
              // ts 3.2 "Meta-property '{0}' is only allowed in the body of a function declaration, function expression, or constructor."
              return true
          }

          return false
        })
      }

      function convertDiagnosticToSemanticOrSyntacticError(diagnostic) {
        return {
          ...diagnostic,
          message: ts.flattenDiagnosticMessageText(
            diagnostic.messageText,
            ts.sys.newLine
          ),
        }
      }

      /** */
    },
    /* 181 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        5
      )
      /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        10
      )
      /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        11
      )
      /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        13
      )
      /* harmony import */ const core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
        27
      )
      /* harmony import */ const core_js_modules_es_array_includes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
        34
      )
      /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
        4
      )
      /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_6___default = /* #__PURE__ */ __webpack_require__.n(
        core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_6__
      )
      /* harmony import */ const core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
        23
      )
      /* harmony import */ const core_js_modules_es_array_sort__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
        42
      )
      /* harmony import */ const core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
        74
      )
      /* harmony import */ const core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_9___default = /* #__PURE__ */ __webpack_require__.n(
        core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_9__
      )
      /* harmony import */ const core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
        32
      )
      /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
        1
      )
      /* harmony import */ const core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
        44
      )
      /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
        3
      )
      /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
        37
      )
      /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_14___default = /* #__PURE__ */ __webpack_require__.n(
        core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_14__
      )
      /* harmony import */ const core_js_modules_es_string_includes__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
        41
      )
      /* harmony import */ const core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
        28
      )
      /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(
        14
      )
      /* harmony import */ const core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(
        24
      )
      /* harmony import */ const regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(
        75
      )

      function _toConsumableArray(array) {
        return (
          _arrayWithoutHoles(array) ||
          _iterableToArray(array) ||
          _nonIterableSpread()
        )
      }

      function _nonIterableSpread() {
        throw new TypeError('Invalid attempt to spread non-iterable instance')
      }

      function _iterableToArray(iter) {
        if (
          Symbol.iterator in new Object(iter) ||
          Object.prototype.toString.call(iter) === '[object Arguments]'
        ) {
          return Array.from(iter)
        }
      }

      function _arrayWithoutHoles(array) {
        if (Array.isArray(array)) {
          for (
            var i = 0, array2 = new Array(array.length);
            i < array.length;
            i++
          ) {
            array2[i] = array[i]
          }
          return array2
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (typeof call === 'object' || typeof call === 'function')) {
          return call
        }
        return _assertThisInitialized(self)
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf
          ? Object.getPrototypeOf
          : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o)
            }
        return _getPrototypeOf(o)
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          )
        }
        return self
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== 'function' && superClass !== null) {
          throw new TypeError(
            'Super expression must either be null or a function'
          )
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {value: subClass, writable: true, configurable: true},
        })
        if (superClass) {
          _setPrototypeOf(subClass, superClass)
        }
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf =
          Object.setPrototypeOf ||
          function _setPrototypeOf(o, p) {
            o.__proto__ = p
            return o
          }
        return _setPrototypeOf(o, p)
      }

      function asyncGeneratorStep(
        gen,
        resolve,
        reject,
        _next,
        _throw,
        key,
        argument
      ) {
        try {
          var info = gen[key](argument)
          var {value} = info
        } catch (error) {
          reject(error)
          return
        }
        if (info.done) {
          resolve(value)
        } else {
          Promise.resolve(value).then(_next, _throw)
        }
      }

      function _asyncToGenerator(fn) {
        return function() {
          const self = this
          const arguments_ = arguments
          return new Promise(function(resolve, reject) {
            const gen = fn.apply(self, arguments_)
            function _next(value) {
              asyncGeneratorStep(
                gen,
                resolve,
                reject,
                _next,
                _throw,
                'next',
                value
              )
            }
            function _throw(error) {
              asyncGeneratorStep(
                gen,
                resolve,
                reject,
                _next,
                _throw,
                'throw',
                error
              )
            }
            _next(undefined)
          })
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function')
        }
      }

      function _defineProperties(target, properties) {
        for (const descriptor of properties) {
          descriptor.enumerable = descriptor.enumerable || false
          descriptor.configurable = true
          if ('value' in descriptor) {
            descriptor.writable = true
          }
          Object.defineProperty(target, descriptor.key, descriptor)
        }
      }

      function _createClass(Constructor, protoProperties, staticProperties) {
        if (protoProperties) {
          _defineProperties(Constructor.prototype, protoProperties)
        }
        if (staticProperties) {
          _defineProperties(Constructor, staticProperties)
        }
        return Constructor
      }

      const _require = __webpack_require__(134)
      const {EventEmitter} = _require

      const fs = __webpack_require__(35)

      const sysPath = __webpack_require__(15)

      const readdirp = __webpack_require__(189)

      const anymatch = __webpack_require__(194).default

      const globParent = __webpack_require__(195)

      const isGlob = __webpack_require__(103)

      const braces = __webpack_require__(197)

      const normalizePath = __webpack_require__(148)

      const _require2 = __webpack_require__(36)
      const {promisify} = _require2

      const NodeFsHandler = __webpack_require__(208)

      const FsEventsHandler = __webpack_require__(212)

      const _require3 = __webpack_require__(109)
      const {EV_ALL} = _require3
      const {EV_READY} = _require3
      const {EV_ADD} = _require3
      const {EV_CHANGE} = _require3
      const {EV_UNLINK} = _require3
      const {EV_ADD_DIR} = _require3
      const {EV_UNLINK_DIR} = _require3
      const {EV_RAW} = _require3
      const {EV_ERROR} = _require3
      const {STR_CLOSE} = _require3
      const {STR_END} = _require3
      const {BACK_SLASH_RE} = _require3
      const {DOUBLE_SLASH_RE} = _require3
      const {SLASH_OR_BACK_SLASH_RE} = _require3
      const {DOT_RE} = _require3
      const {REPLACER_RE} = _require3
      const {SLASH} = _require3
      const {BRACE_START} = _require3
      const {BANG} = _require3
      const {ONE_DOT} = _require3
      const {TWO_DOTS} = _require3
      const {GLOBSTAR} = _require3
      const {SLASH_GLOBSTAR} = _require3
      const {ANYMATCH_OPTS} = _require3
      const {STRING_TYPE} = _require3
      const {FUNCTION_TYPE} = _require3
      const {EMPTY_STR} = _require3
      const {EMPTY_FN} = _require3
      const {isWindows} = _require3
      const {isMacos} = _require3

      const stat = promisify(fs.stat)
      const readdir = promisify(fs.readdir)
      /**
       * @typedef {String} Path
       * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName
       * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType
       */

      /**
       *
       * @typedef {Object} WatchHelpers
       * @property {Boolean} followSymlinks
       * @property {'stat'|'lstat'} statMethod
       * @property {Path} path
       * @property {Path} watchPath
       * @property {Function} entryPath
       * @property {Boolean} hasGlob
       * @property {Object} globFilter
       * @property {Function} filterPath
       * @property {Function} filterDir
       */

      const arrify = function arrify() {
        const value =
          arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []
        return Array.isArray(value) ? value : [value]
      }

      const flatten = function flatten(list) {
        const result =
          arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : []
        list.forEach(function(item) {
          if (Array.isArray(item)) {
            flatten(item, result)
          } else {
            result.push(item)
          }
        })
        return result
      }

      const unifyPaths = function unifyPaths(paths_) {
        /**
         * @type {Array<String>}
         */
        const paths = flatten(arrify(paths_))

        if (
          !paths.every(function(p) {
            return typeof p === STRING_TYPE
          })
        ) {
          throw new TypeError(`Non-string provided as watch path: ${paths}`)
        }

        return paths.map(normalizePathToUnix)
      }

      const toUnix = function toUnix(string) {
        let string_ = string.replace(BACK_SLASH_RE, SLASH)

        while (string_.match(DOUBLE_SLASH_RE)) {
          string_ = string_.replace(DOUBLE_SLASH_RE, SLASH)
        }

        return string_
      } // Our version of upath.normalize
      // TODO: this is not equal to path-normalize module - investigate why

      var normalizePathToUnix = function normalizePathToUnix(path) {
        return toUnix(sysPath.normalize(toUnix(path)))
      }

      const normalizeIgnored = function normalizeIgnored() {
        const cwd =
          arguments.length > 0 && arguments[0] !== undefined
            ? arguments[0]
            : EMPTY_STR
        return function(path) {
          if (typeof path !== STRING_TYPE) {
            return path
          }
          return normalizePathToUnix(
            sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path)
          )
        }
      }

      const getAbsolutePath = function getAbsolutePath(path, cwd) {
        if (sysPath.isAbsolute(path)) {
          return path
        }
        if (path[0] === BANG) {
          return BANG + sysPath.join(cwd, path.substring(1))
        }
        return sysPath.join(cwd, path)
      }

      const undef = function undef(options, key) {
        return options[key] === undefined
      }
      /**
       * Directory entry.
       * @property {Path} path
       * @property {Set<Path>} items
       */

      const DirEntry =
        /* #__PURE__ */
        (function() {
          /**
           * @param {Path} dir
           * @param {Function} removeWatcher
           */
          function DirEntry(dir, removeWatcher) {
            _classCallCheck(this, DirEntry)

            this.path = dir
            this._removeWatcher = removeWatcher
            /** @type {Set<Path>} */

            this.items = new Set()
          }

          _createClass(DirEntry, [
            {
              key: 'add',
              value: function add(item) {
                const {items} = this
                if (!items) {
                  return
                }
                if (item !== ONE_DOT && item !== TWO_DOTS) {
                  items.add(item)
                }
              },
            },
            {
              key: 'remove',
              value: (function() {
                const _remove = _asyncToGenerator(
                  /* #__PURE__ */
                  regeneratorRuntime.mark(function _callee(item) {
                    let items
                    let dir
                    return regeneratorRuntime.wrap(
                      function _callee$(_context) {
                        while (1) {
                          switch ((_context.prev = _context.next)) {
                            case 0:
                              items = this.items

                              if (items) {
                                _context.next = 3
                                break
                              }

                              return _context.abrupt('return')

                            case 3:
                              items.delete(item)

                              if (items.size) {
                                _context.next = 14
                                break
                              }

                              dir = this.path
                              _context.prev = 6
                              _context.next = 9
                              return readdir(dir)

                            case 9:
                              _context.next = 14
                              break

                            case 11:
                              _context.prev = 11
                              _context.t0 = _context.catch(6)

                              this._removeWatcher(
                                sysPath.dirname(dir),
                                sysPath.basename(dir)
                              )

                            case 14:
                            case 'end':
                              return _context.stop()
                          }
                        }
                      },
                      _callee,
                      this,
                      [[6, 11]]
                    )
                  })
                )

                function remove(_x) {
                  return Reflect.apply(_remove, this, arguments)
                }

                return remove
              })(),
            },
            {
              key: 'has',
              value: function has(item) {
                const {items} = this
                if (!items) {
                  return
                }
                return items.has(item)
              },
              /**
               * @returns {Array<String>}
               */
            },
            {
              key: 'getChildren',
              value: function getChildren() {
                const {items} = this
                if (!items) {
                  return
                }
                return Array.from(items.values())
              },
            },
            {
              key: 'dispose',
              value: function dispose() {
                this.items.clear()
                delete this.path
                delete this._removeWatcher
                delete this.items
                Object.freeze(this)
              },
            },
          ])

          return DirEntry
        })()

      const STAT_METHOD_F = 'stat'
      const STAT_METHOD_L = 'lstat'

      const WatchHelper =
        /* #__PURE__ */
        (function() {
          function WatchHelper(path, watchPath, follow, fsw) {
            _classCallCheck(this, WatchHelper)

            this.fsw = fsw
            this.path = path = path.replace(REPLACER_RE, EMPTY_STR)
            this.watchPath = watchPath
            this.fullWatchPath = sysPath.resolve(watchPath)
            this.hasGlob = watchPath !== path
            /** @type {object|boolean} */

            if (path === EMPTY_STR) {
              this.hasGlob = false
            }
            this.globSymlink = this.hasGlob && follow ? undefined : false
            this.globFilter = this.hasGlob
              ? anymatch(path, undefined, ANYMATCH_OPTS)
              : false
            this.dirParts = this.getDirParts(path)
            this.dirParts.forEach(function(parts) {
              if (parts.length > 1) {
                parts.pop()
              }
            })
            this.followSymlinks = follow
            this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L
          }

          _createClass(WatchHelper, [
            {
              key: 'checkGlobSymlink',
              value: function checkGlobSymlink(entry) {
                // only need to resolve once
                // first entry should always have entry.parentDir === EMPTY_STR
                if (this.globSymlink === undefined) {
                  this.globSymlink =
                    entry.fullParentDir === this.fullWatchPath
                      ? false
                      : {
                          realPath: entry.fullParentDir,
                          linkPath: this.fullWatchPath,
                        }
                }

                if (this.globSymlink) {
                  return entry.fullPath.replace(
                    this.globSymlink.realPath,
                    this.globSymlink.linkPath
                  )
                }

                return entry.fullPath
              },
            },
            {
              key: 'entryPath',
              value: function entryPath(entry) {
                return sysPath.join(
                  this.watchPath,
                  sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
                )
              },
            },
            {
              key: 'filterPath',
              value: function filterPath(entry) {
                const {stats} = entry
                if (stats && stats.isSymbolicLink()) {
                  return this.filterDir(entry)
                }
                const resolvedPath = this.entryPath(entry)
                const matchesGlob =
                  this.hasGlob && typeof this.globFilter === FUNCTION_TYPE
                    ? this.globFilter(resolvedPath)
                    : true
                return (
                  matchesGlob &&
                  this.fsw._isntIgnored(resolvedPath, stats) &&
                  this.fsw._hasReadPermissions(stats)
                )
              },
            },
            {
              key: 'getDirParts',
              value: function getDirParts(path) {
                const _this = this

                if (!this.hasGlob) {
                  return []
                }
                const parts = []
                const expandedPath = path.includes(BRACE_START)
                  ? braces.expand(path)
                  : [path]
                expandedPath.forEach(function(path) {
                  parts.push(
                    sysPath
                      .relative(_this.watchPath, path)
                      .split(SLASH_OR_BACK_SLASH_RE)
                  )
                })
                return parts
              },
            },
            {
              key: 'filterDir',
              value: function filterDir(entry) {
                if (this.hasGlob) {
                  const entryParts = this.getDirParts(
                    this.checkGlobSymlink(entry)
                  )
                  let globstar = false
                  this.unmatchedGlob = !this.dirParts.some(function(parts) {
                    return parts.every(function(part, i) {
                      if (part === GLOBSTAR) {
                        globstar = true
                      }
                      return (
                        globstar ||
                        !entryParts[0][i] ||
                        anymatch(part, entryParts[0][i], ANYMATCH_OPTS)
                      )
                    })
                  })
                }

                return (
                  !this.unmatchedGlob &&
                  this.fsw._isntIgnored(this.entryPath(entry), entry.stats)
                )
              },
            },
          ])

          return WatchHelper
        })()
      /**
       * Watches files & directories for changes. Emitted events:
       * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
       *
       *     new FSWatcher()
       *       .add(directories)
       *       .on('add', path => log('File', path, 'was added'))
       */

      const FSWatcher =
        /* #__PURE__ */
        (function(_EventEmitter) {
          _inherits(FSWatcher, _EventEmitter)

          // Not indenting methods for history sake; for now.
          function FSWatcher(_options) {
            let _this2

            _classCallCheck(this, FSWatcher)

            _this2 = _possibleConstructorReturn(
              this,
              _getPrototypeOf(FSWatcher).call(this)
            )
            const options = {}
            if (_options) {
              Object.assign(options, _options)
            } // for frozen objects

            /** @type {Map<String, DirEntry>} */

            _this2._watched = new Map()
            /** @type {Map<String, Array>} */

            _this2._closers = new Map()
            /** @type {Set<String>} */

            _this2._ignoredPaths = new Set()
            /** @type {Map<ThrottleType, Map>} */

            _this2._throttled = new Map()
            /** @type {Map<Path, String|Boolean>} */

            _this2._symlinkPaths = new Map()
            _this2._streams = new Set()
            _this2.closed = false // Set up default options.

            if (undef(options, 'persistent')) {
              options.persistent = true
            }
            if (undef(options, 'ignoreInitial')) {
              options.ignoreInitial = false
            }
            if (undef(options, 'ignorePermissionErrors')) {
              options.ignorePermissionErrors = false
            }
            if (undef(options, 'interval')) {
              options.interval = 100
            }
            if (undef(options, 'binaryInterval')) {
              options.binaryInterval = 300
            }
            if (undef(options, 'disableGlobbing')) {
              options.disableGlobbing = false
            }
            options.enableBinaryInterval =
              options.binaryInterval !== options.interval // Enable fsevents on OS X when polling isn't explicitly enabled.

            if (undef(options, 'useFsEvents')) {
              options.useFsEvents = !options.usePolling
            } // If we can't use fsevents, ensure the options reflect it's disabled.

            const canUseFsEvents = FsEventsHandler.canUse()
            if (!canUseFsEvents) {
              options.useFsEvents = false
            } // Use polling on Mac if not using fsevents.
            // Other platforms use non-polling fs_watch.

            if (undef(options, 'usePolling') && !options.useFsEvents) {
              options.usePolling = isMacos
            } // Global override (useful for end-developers that need to force polling for all
            // instances of chokidar, regardless of usage/dependency depth)

            const environmentPoll = process.env.CHOKIDAR_USEPOLLING

            if (environmentPoll !== undefined) {
              const environmentLower = environmentPoll.toLowerCase()

              if (environmentLower === 'false' || environmentLower === '0') {
                options.usePolling = false
              } else if (
                environmentLower === 'true' ||
                environmentLower === '1'
              ) {
                options.usePolling = true
              } else {
                options.usePolling = !!environmentLower
              }
            }

            const environmentInterval = process.env.CHOKIDAR_INTERVAL

            if (environmentInterval) {
              options.interval = parseInt(environmentInterval)
            } // Editor atomic write normalization enabled by default with fs.watch

            if (undef(options, 'atomic')) {
              options.atomic = !options.usePolling && !options.useFsEvents
            }
            if (options.atomic) {
              _this2._pendingUnlinks = new Map()
            }
            if (undef(options, 'followSymlinks')) {
              options.followSymlinks = true
            }
            if (undef(options, 'awaitWriteFinish')) {
              options.awaitWriteFinish = false
            }
            if (options.awaitWriteFinish === true) {
              options.awaitWriteFinish = {}
            }
            const awf = options.awaitWriteFinish

            if (awf) {
              if (!awf.stabilityThreshold) {
                awf.stabilityThreshold = 2000
              }
              if (!awf.pollInterval) {
                awf.pollInterval = 100
              }
              _this2._pendingWrites = new Map()
            }

            if (options.ignored) {
              options.ignored = arrify(options.ignored)
            }
            let readyCalls = 0

            _this2._emitReady = function() {
              readyCalls++

              if (readyCalls >= _this2._readyCount) {
                _this2._emitReady = EMPTY_FN
                _this2._readyEmitted = true // use process.nextTick to allow time for listener to be bound

                process.nextTick(function() {
                  return _this2.emit(EV_READY)
                })
              }
            }

            _this2._emitRaw = function() {
              let _this3

              for (
                var _length = arguments.length,
                  arguments_ = new Array(_length),
                  _key = 0;
                _key < _length;
                _key++
              ) {
                arguments_[_key] = arguments[_key]
              }

              return (_this3 = _this2).emit.apply(
                _this3,
                [EV_RAW].concat(arguments_)
              )
            }

            _this2._readyEmitted = false
            _this2.options = options // Initialize with proper watcher.

            if (options.useFsEvents) {
              _this2._fsEventsHandler = new FsEventsHandler(
                _assertThisInitialized(_this2)
              )
            } else {
              _this2._nodeFsHandler = new NodeFsHandler(
                _assertThisInitialized(_this2)
              )
            } // Youre frozen when your hearts not open.

            Object.freeze(options)
            return _this2
          } // Public methods

          /**
           * Adds paths to be watched on an existing FSWatcher instance
           * @param {Path|Array<Path>} paths_
           * @param {String=} _origAdd private; for handling non-existent paths to be watched
           * @param {Boolean=} _internal private; indicates a non-user add
           * @returns {FSWatcher} for chaining
           */

          _createClass(FSWatcher, [
            {
              key: 'add',
              value: function add(paths_, _origAdd, _internal) {
                const _this4 = this

                const _this$options = this.options
                const {cwd} = _this$options
                const {disableGlobbing} = _this$options
                this.closed = false
                let paths = unifyPaths(paths_)

                if (cwd) {
                  paths = paths.map(function(path) {
                    const absPath = getAbsolutePath(path, cwd) // Check `path` instead of `absPath` because the cwd portion can't be a glob

                    if (disableGlobbing || !isGlob(path)) {
                      return absPath
                    }
                    return normalizePath(absPath)
                  })
                } // set aside negated glob strings

                paths = paths.filter(function(path) {
                  if (path[0] === BANG) {
                    _this4._ignoredPaths.add(path.substring(1))

                    return false
                  }
                  // if a path is being added that was previously ignored, stop ignoring it
                  _this4._ignoredPaths.delete(path)

                  _this4._ignoredPaths.delete(path + SLASH_GLOBSTAR) // reset the cached userIgnored anymatch fn
                  // to make ignoredPaths changes effective

                  _this4._userIgnored = undefined
                  return true
                })

                if (this.options.useFsEvents && this._fsEventsHandler) {
                  if (!this._readyCount) {
                    this._readyCount = paths.length
                  }
                  if (this.options.persistent) {
                    this._readyCount *= 2
                  }
                  paths.forEach(function(path) {
                    return _this4._fsEventsHandler._addToFsEvents(path)
                  })
                } else {
                  if (!this._readyCount) {
                    this._readyCount = 0
                  }
                  this._readyCount += paths.length
                  Promise.all(
                    paths.map(
                      /* #__PURE__ */
                      (function() {
                        const _reference = _asyncToGenerator(
                          /* #__PURE__ */
                          regeneratorRuntime.mark(function _callee2(path) {
                            let res
                            return regeneratorRuntime.wrap(function _callee2$(
                              _context2
                            ) {
                              while (1) {
                                switch ((_context2.prev = _context2.next)) {
                                  case 0:
                                    _context2.next = 2
                                    return _this4._nodeFsHandler._addToNodeFs(
                                      path,
                                      !_internal,
                                      0,
                                      0,
                                      _origAdd
                                    )

                                  case 2:
                                    res = _context2.sent
                                    if (res) {
                                      _this4._emitReady()
                                    }
                                    return _context2.abrupt('return', res)

                                  case 5:
                                  case 'end':
                                    return _context2.stop()
                                }
                              }
                            },
                            _callee2)
                          })
                        )

                        return function(_x2) {
                          return Reflect.apply(_reference, this, arguments)
                        }
                      })()
                    )
                  ).then(function(results) {
                    if (_this4.closed) {
                      return
                    }
                    results
                      .filter(function(item) {
                        return item
                      })
                      .forEach(function(item) {
                        _this4.add(
                          sysPath.dirname(item),
                          sysPath.basename(_origAdd || item)
                        )
                      })
                  })
                }

                return this
              },
              /**
               * Close watchers or start ignoring events from specified paths.
               * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
               * @returns {FSWatcher} for chaining
               */
            },
            {
              key: 'unwatch',
              value: function unwatch(paths_) {
                const _this5 = this

                if (this.closed) {
                  return this
                }
                const paths = unifyPaths(paths_)
                const {cwd} = this.options
                paths.forEach(function(path) {
                  // convert to absolute path unless relative path already matches
                  if (!sysPath.isAbsolute(path) && !_this5._closers.has(path)) {
                    if (cwd) {
                      path = sysPath.join(cwd, path)
                    }
                    path = sysPath.resolve(path)
                  }

                  _this5._closePath(path)

                  _this5._ignoredPaths.add(path)

                  if (_this5._watched.has(path)) {
                    _this5._ignoredPaths.add(path + SLASH_GLOBSTAR)
                  } // reset the cached userIgnored anymatch fn
                  // to make ignoredPaths changes effective

                  _this5._userIgnored = undefined
                })
                return this
              },
              /**
               * Close watchers and remove all listeners from watched paths.
               * @returns {FSWatcher} for chaining.
               */
            },
            {
              key: 'close',
              value: function close() {
                const _this6 = this

                if (this.closed) {
                  return this
                }
                this.closed = true // Memory management.

                this.removeAllListeners()

                this._closers.forEach(function(closerList) {
                  return closerList.forEach(function(closer) {
                    return closer()
                  })
                })

                this._streams.forEach(function(stream) {
                  return stream.destroy()
                })

                this._userIgnored = undefined
                this._readyCount = 0
                this._readyEmitted = false

                this._watched.forEach(function(dirent) {
                  return dirent.dispose()
                })
                ;[
                  'closers',
                  'watched',
                  'streams',
                  'symlinkPaths',
                  'throttled',
                ].forEach(function(key) {
                  _this6[`_${key}`].clear()
                })
                return this
              },
              /**
               * Expose list of watched paths
               * @returns {Object} for chaining
               */
            },
            {
              key: 'getWatched',
              value: function getWatched() {
                const _this7 = this

                const watchList = {}

                this._watched.forEach(function(entry, dir) {
                  const key = _this7.options.cwd
                    ? sysPath.relative(_this7.options.cwd, dir)
                    : dir
                  watchList[key || ONE_DOT] = entry.getChildren().sort()
                })

                return watchList
              },
            },
            {
              key: 'emitWithAll',
              value: function emitWithAll(event, arguments_) {
                this.emit.apply(this, _toConsumableArray(arguments_))
                if (event !== EV_ERROR) {
                  this.emit.apply(
                    this,
                    [EV_ALL].concat(_toConsumableArray(arguments_))
                  )
                }
              }, // Common helpers
              // --------------

              /**
               * Normalize and emit events.
               * Calling _emit DOES NOT MEAN emit() would be called!
               * @param {EventName} event Type of event
               * @param {Path} path File or directory path
               * @param {*=} val1 arguments to be passed with event
               * @param {*=} val2
               * @param {*=} val3
               * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
               */
            },
            {
              key: '_emit',
              value: (function() {
                const _emit2 = _asyncToGenerator(
                  /* #__PURE__ */
                  regeneratorRuntime.mark(function _callee3(
                    event,
                    path,
                    value1,
                    value2,
                    value3
                  ) {
                    const _this8 = this

                    let options
                    let arguments_
                    let awf
                    let pw
                    let awfEmit
                    let isThrottled
                    let fullPath
                    let stats
                    return regeneratorRuntime.wrap(
                      function _callee3$(_context3) {
                        while (1) {
                          switch ((_context3.prev = _context3.next)) {
                            case 0:
                              if (!this.closed) {
                                _context3.next = 2
                                break
                              }

                              return _context3.abrupt('return')

                            case 2:
                              options = this.options
                              if (isWindows) {
                                path = sysPath.normalize(path)
                              }
                              if (options.cwd) {
                                path = sysPath.relative(options.cwd, path)
                              }
                              /** @type Array<any> */

                              arguments_ = [event, path]
                              if (value3 !== undefined) {
                                arguments_.push(value1, value2, value3)
                              } else if (value2 !== undefined) {
                                arguments_.push(value1, value2)
                              } else if (value1 !== undefined) {
                                arguments_.push(value1)
                              }
                              awf = options.awaitWriteFinish

                              if (
                                !(awf && (pw = this._pendingWrites.get(path)))
                              ) {
                                _context3.next = 11
                                break
                              }

                              pw.lastChange = new Date()
                              return _context3.abrupt('return', this)

                            case 11:
                              if (!options.atomic) {
                                _context3.next = 19
                                break
                              }

                              if (!(event === EV_UNLINK)) {
                                _context3.next = 18
                                break
                              }

                              this._pendingUnlinks.set(path, arguments_)

                              setTimeout(
                                function() {
                                  _this8._pendingUnlinks.forEach(function(
                                    entry,
                                    path
                                  ) {
                                    _this8.emit.apply(
                                      _this8,
                                      _toConsumableArray(entry)
                                    )

                                    _this8.emit.apply(
                                      _this8,
                                      [EV_ALL].concat(_toConsumableArray(entry))
                                    )

                                    _this8._pendingUnlinks.delete(path)
                                  })
                                },
                                typeof options.atomic === 'number'
                                  ? options.atomic
                                  : 100
                              )
                              return _context3.abrupt('return', this)

                            case 18:
                              if (
                                event === EV_ADD &&
                                this._pendingUnlinks.has(path)
                              ) {
                                event = arguments_[0] = EV_CHANGE

                                this._pendingUnlinks.delete(path)
                              }

                            case 19:
                              if (
                                !(
                                  awf &&
                                  (event === EV_ADD || event === EV_CHANGE) &&
                                  this._readyEmitted
                                )
                              ) {
                                _context3.next = 23
                                break
                              }

                              awfEmit = function awfEmit(error, stats) {
                                if (error) {
                                  event = arguments_[0] = EV_ERROR
                                  arguments_[1] = error

                                  _this8.emitWithAll(event, arguments_)
                                } else if (stats) {
                                  // if stats doesn't exist the file must have been deleted
                                  if (arguments_.length > 2) {
                                    arguments_[2] = stats
                                  } else {
                                    arguments_.push(stats)
                                  }

                                  _this8.emitWithAll(event, arguments_)
                                }
                              }

                              this._awaitWriteFinish(
                                path,
                                awf.stabilityThreshold,
                                event,
                                awfEmit
                              )

                              return _context3.abrupt('return', this)

                            case 23:
                              if (!(event === EV_CHANGE)) {
                                _context3.next = 27
                                break
                              }

                              isThrottled = !this._throttle(EV_CHANGE, path, 50)

                              if (!isThrottled) {
                                _context3.next = 27
                                break
                              }

                              return _context3.abrupt('return', this)

                            case 27:
                              if (
                                !(
                                  options.alwaysStat &&
                                  value1 === undefined &&
                                  (event === EV_ADD ||
                                    event === EV_ADD_DIR ||
                                    event === EV_CHANGE)
                                )
                              ) {
                                _context3.next = 43
                                break
                              }

                              fullPath = options.cwd
                                ? sysPath.join(options.cwd, path)
                                : path
                              _context3.prev = 29
                              _context3.next = 32
                              return stat(fullPath)

                            case 32:
                              stats = _context3.sent

                              if (stats) {
                                _context3.next = 35
                                break
                              }

                              return _context3.abrupt('return')

                            case 35:
                              arguments_.push(stats)
                              this.emitWithAll(event, arguments_)
                              _context3.next = 41
                              break

                            case 39:
                              _context3.prev = 39
                              _context3.t0 = _context3.catch(29)

                            case 41:
                              _context3.next = 44
                              break

                            case 43:
                              this.emitWithAll(event, arguments_)

                            case 44:
                              return _context3.abrupt('return', this)

                            case 45:
                            case 'end':
                              return _context3.stop()
                          }
                        }
                      },
                      _callee3,
                      this,
                      [[29, 39]]
                    )
                  })
                )

                function _emit(_x3, _x4, _x5, _x6, _x7) {
                  return Reflect.apply(_emit2, this, arguments)
                }

                return _emit
              })(),
              /**
               * Common handler for errors
               * @param {Error} error
               * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
               */
            },
            {
              key: '_handleError',
              value: function _handleError(error) {
                const code = error && error.code

                if (
                  error &&
                  code !== 'ENOENT' &&
                  code !== 'ENOTDIR' &&
                  (!this.options.ignorePermissionErrors ||
                    (code !== 'EPERM' && code !== 'EACCES'))
                ) {
                  this.emit(EV_ERROR, error)
                }

                return error || this.closed
              },
              /**
               * Helper utility for throttling
               * @param {ThrottleType} actionType type being throttled
               * @param {Path} path being acted upon
               * @param {Number} timeout duration of time to suppress duplicate actions
               * @returns {Object|false} tracking object or false if action should be suppressed
               */
            },
            {
              key: '_throttle',
              value: function _throttle(actionType, path, timeout) {
                if (!this._throttled.has(actionType)) {
                  this._throttled.set(actionType, new Map())
                }
                /** @type {Map<Path, Object>} */

                const action = this._throttled.get(actionType)
                /** @type {Object} */

                const actionPath = action.get(path)

                if (actionPath) {
                  actionPath.count++
                  return false
                }

                let timeoutObject

                const clear = function clear() {
                  const item = action.get(path)
                  const count = item ? item.count : 0
                  action.delete(path)
                  clearTimeout(timeoutObject)
                  if (item) {
                    clearTimeout(item.timeoutObject)
                  }
                  return count
                }

                timeoutObject = setTimeout(clear, timeout)
                const thr = {
                  timeoutObject,
                  clear,
                  count: 0,
                }
                action.set(path, thr)
                return thr
              },
            },
            {
              key: '_incrReadyCount',
              value: function _incrReadyCount() {
                return this._readyCount++
              },
              /**
               * Awaits write operation to finish.
               * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
               * @param {Path} path being acted upon
               * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
               * @param {EventName} event
               * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
               */
            },
            {
              key: '_awaitWriteFinish',
              value: function _awaitWriteFinish(
                path,
                threshold,
                event,
                awfEmit
              ) {
                const _this9 = this

                let timeoutHandler
                let fullPath = path

                if (this.options.cwd && !sysPath.isAbsolute(path)) {
                  fullPath = sysPath.join(this.options.cwd, path)
                }

                const now = new Date()

                const awaitWriteFinish = function awaitWriteFinish(
                  previousStat
                ) {
                  fs.stat(fullPath, function(error, currentStat) {
                    if (error || !_this9._pendingWrites.has(path)) {
                      if (error && error.code !== 'ENOENT') {
                        awfEmit(error)
                      }
                      return
                    }

                    const now = Number(new Date())

                    if (previousStat && currentStat.size != previousStat.size) {
                      _this9._pendingWrites.get(path).lastChange = now
                    }

                    const pw = _this9._pendingWrites.get(path)

                    const df = now - pw.lastChange

                    if (df >= threshold) {
                      _this9._pendingWrites.delete(path)

                      awfEmit(undefined, currentStat)
                    } else {
                      timeoutHandler = setTimeout(
                        awaitWriteFinish,
                        _this9.options.awaitWriteFinish.pollInterval,
                        currentStat
                      )
                    }
                  })
                }

                if (!this._pendingWrites.has(path)) {
                  this._pendingWrites.set(path, {
                    lastChange: now,
                    cancelWait: function cancelWait() {
                      _this9._pendingWrites.delete(path)

                      clearTimeout(timeoutHandler)
                      return event
                    },
                  })

                  timeoutHandler = setTimeout(
                    awaitWriteFinish,
                    this.options.awaitWriteFinish.pollInterval
                  )
                }
              },
            },
            {
              key: '_getGlobIgnored',
              value: function _getGlobIgnored() {
                return Array.from(this._ignoredPaths.values())
              },
              /**
               * Determines whether user has asked to ignore this path.
               * @param {Path} path filepath or dir
               * @param {fs.Stats=} stats result of fs.stat
               * @returns {Boolean}
               */
            },
            {
              key: '_isIgnored',
              value: function _isIgnored(path, stats) {
                if (this.options.atomic && DOT_RE.test(path)) {
                  return true
                }

                if (!this._userIgnored) {
                  const {cwd} = this.options
                  const ign = this.options.ignored
                  const ignored = ign && ign.map(normalizeIgnored(cwd))
                  const paths = arrify(ignored)
                    .filter(function(path) {
                      return typeof path === STRING_TYPE && !isGlob(path)
                    })
                    .map(function(path) {
                      return path + SLASH_GLOBSTAR
                    })

                  const list = this._getGlobIgnored()
                    .map(normalizeIgnored(cwd))
                    .concat(ignored, paths)

                  this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS)
                }

                return this._userIgnored([path, stats])
              },
            },
            {
              key: '_isntIgnored',
              value: function _isntIgnored(path, stat) {
                return !this._isIgnored(path, stat)
              },
              /**
               * Provides a set of common helpers and properties relating to symlink and glob handling.
               * @param {Path} path file, directory, or glob pattern being watched
               * @param {Number=} depth at any depth > 0, this isn't a glob
               * @returns {WatchHelper} object containing helpers for this path
               */
            },
            {
              key: '_getWatchHelpers',
              value: function _getWatchHelpers(path, depth) {
                const watchPath =
                  depth || this.options.disableGlobbing || !isGlob(path)
                    ? path
                    : globParent(path)
                const follow = this.options.followSymlinks
                return new WatchHelper(path, watchPath, follow, this)
              }, // Directory helpers
              // -----------------

              /**
               * Provides directory tracking objects
               * @param {String} directory path of the directory
               * @returns {DirEntry} the directory's tracking object
               */
            },
            {
              key: '_getWatchedDir',
              value: function _getWatchedDir(directory) {
                if (!this._boundRemove) {
                  this._boundRemove = this._remove.bind(this)
                }
                const dir = sysPath.resolve(directory)
                if (!this._watched.has(dir)) {
                  this._watched.set(dir, new DirEntry(dir, this._boundRemove))
                }
                return this._watched.get(dir)
              }, // File helpers
              // ------------

              /**
               * Check for read permissions.
               * Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405
               * @param {fs.Stats} stats - object, result of fs_stat
               * @returns {Boolean} indicates whether the file can be read
               */
            },
            {
              key: '_hasReadPermissions',
              value: function _hasReadPermissions(stats) {
                if (this.options.ignorePermissionErrors) {
                  return true
                } // stats.mode may be bigint

                const md = stats && Number.parseInt(stats.mode)
                const st = md & 0o777
                const it = parseInt(st.toString(8)[0], 10)
                return Boolean(4 & it)
              },
              /**
               * Handles emitting unlink events for
               * files and directories, and via recursion, for
               * files and directories within directories that are unlinked
               * @param {String} directory within which the following item is located
               * @param {String} item      base path of item/directory
               * @returns {void}
               */
            },
            {
              key: '_remove',
              value: function _remove(directory, item) {
                const _this10 = this

                // if what is being deleted is a directory, get that directory's paths
                // for recursive deleting and cleaning of watched object
                // if it is not a directory, nestedDirectoryChildren will be empty array
                const path = sysPath.join(directory, item)
                const fullPath = sysPath.resolve(path)

                const isDirectory =
                  this._watched.has(path) || this._watched.has(fullPath) // prevent duplicate handling in case of arriving here nearly simultaneously
                // via multiple paths (such as _handleFile and _handleDir)

                if (!this._throttle('remove', path, 100)) {
                  return
                } // if the only watched file is removed, watch for its return

                if (
                  !isDirectory &&
                  !this.options.useFsEvents &&
                  this._watched.size === 1
                ) {
                  this.add(directory, item, true)
                } // This will create a new entry in the watched object in either case
                // so we got to do the directory check beforehand

                const wp = this._getWatchedDir(path)

                const nestedDirectoryChildren = wp.getChildren() // Recursively remove children directories / files.

                nestedDirectoryChildren.forEach(function(nested) {
                  return _this10._remove(path, nested)
                }) // Check if item was on the watched list and remove it

                const parent = this._getWatchedDir(directory)

                const wasTracked = parent.has(item)
                parent.remove(item) // If we wait for this file to be fully written, cancel the wait.

                let relPath = path
                if (this.options.cwd) {
                  relPath = sysPath.relative(this.options.cwd, path)
                }

                if (
                  this.options.awaitWriteFinish &&
                  this._pendingWrites.has(relPath)
                ) {
                  const event = this._pendingWrites.get(relPath).cancelWait()

                  if (event === EV_ADD) {
                    return
                  }
                } // The Entry will either be a directory that just got removed
                // or a bogus entry to a file, in either case we have to remove it

                this._watched.delete(path)

                this._watched.delete(fullPath)

                const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK
                if (wasTracked && !this._isIgnored(path)) {
                  this._emit(eventName, path)
                } // Avoid conflicts if we later create another file with the same name

                if (!this.options.useFsEvents) {
                  this._closePath(path)
                }
              },
              /**
               *
               * @param {Path} path
               */
            },
            {
              key: '_closePath',
              value: function _closePath(path) {
                let closers = this._closers.get(path)

                if (!closers) {
                  return
                }
                closers.forEach(function(closer) {
                  return closer()
                })

                this._closers.delete(path)

                closers = []
                const dir = sysPath.dirname(path)

                this._getWatchedDir(dir).remove(sysPath.basename(path))
              },
              /**
               *
               * @param {Path} path
               * @param {Function} closer
               */
            },
            {
              key: '_addPathCloser',
              value: function _addPathCloser(path, closer) {
                if (!closer) {
                  return
                }

                let list = this._closers.get(path)

                if (!list) {
                  list = []

                  this._closers.set(path, list)
                }

                list.push(closer)
              },
            },
            {
              key: '_readdirp',
              value: function _readdirp(root, options_) {
                const _this11 = this

                if (this.closed) {
                  return
                }
                const options = {
                  type: EV_ALL,
                  alwaysStat: true,
                  lstat: true,
                  ...options_,
                }
                let stream = readdirp(root, options)

                this._streams.add(stream)

                stream.once(STR_CLOSE, function() {
                  stream = undefined
                })
                stream.once(STR_END, function() {
                  if (stream) {
                    _this11._streams.delete(stream)

                    stream = undefined
                  }
                })
                return stream
              },
            },
          ])

          return FSWatcher
        })(EventEmitter) // Export FSWatcher class

      exports.FSWatcher = FSWatcher
      /**
       * Instantiates watcher with paths to be tracked.
       * @param {String|Array<String>} paths file/directory paths and/or globs
       * @param {Object=} options chokidar opts
       * @returns an instance of FSWatcher for chaining.
       */

      const watch = function watch(paths, options) {
        const watcher = new FSWatcher(options)
        watcher.add(paths)
        return watcher
      }

      exports.watch = watch

      /** */
    },
    /* 182 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          44
        )

        const global = __webpack_require__(8)

        const getOwnPropertyDescriptor = __webpack_require__(49).f

        const classof = __webpack_require__(33)

        const macrotask = __webpack_require__(145).set

        const userAgent = __webpack_require__(105)

        const MutationObserver =
          global.MutationObserver || global.WebKitMutationObserver
        const {process} = global
        const {Promise} = global
        const IS_NODE = classof(process) == 'process' // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`

        const queueMicrotaskDescriptor = getOwnPropertyDescriptor(
          global,
          'queueMicrotask'
        )
        const queueMicrotask =
          queueMicrotaskDescriptor && queueMicrotaskDescriptor.value
        let flush
        let head
        let last
        let notify
        let toggle
        let node
        let promise
        let then // modern engines have queueMicrotask method

        if (!queueMicrotask) {
          flush = function flush() {
            let parent
            let fn
            if (IS_NODE && (parent = process.domain)) {
              parent.exit()
            }

            while (head) {
              fn = head.fn
              head = head.next

              try {
                fn()
              } catch (error) {
                if (head) {
                  notify()
                } else {
                  last = undefined
                }
                throw error
              }
            }

            last = undefined
            if (parent) {
              parent.enter()
            }
          } // Node.js

          if (IS_NODE) {
            notify = function notify() {
              process.nextTick(flush)
            } // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
          } else if (
            MutationObserver &&
            !/(iphone|ipod|ipad).*applewebkit/i.test(userAgent)
          ) {
            toggle = true
            node = document.createTextNode('')
            new MutationObserver(flush).observe(node, {
              characterData: true,
            }) // eslint-disable-line no-new

            notify = function notify() {
              node.data = toggle = !toggle
            } // environments with maybe non-completely correct, but existent Promise
          } else if (Promise && Promise.resolve) {
            // Promise.resolve without an argument throws an error in LG WebOS 2
            promise = Promise.resolve(undefined)
            then = promise.then

            notify = function notify() {
              then.call(promise, flush)
            } // for other environments - macrotask based on:
            // - setImmediate
            // - MessageChannel
            // - window.postMessag
            // - onreadystatechange
            // - setTimeout
          } else {
            notify = function notify() {
              // strange IE + webpack dev server bug - use .call(global)
              macrotask.call(global, flush)
            }
          }
        }

        module.exports =
          queueMicrotask ||
          function(fn) {
            const task = {
              fn,
              next: undefined,
            }
            if (last) {
              last.next = task
            }

            if (!head) {
              head = task
              notify()
            }

            last = task
          }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 183 */
    /** */ function(module, exports, __webpack_require__) {
      const global = __webpack_require__(8)

      module.exports = function(a, b) {
        const {console} = global

        if (console && console.error) {
          arguments.length === 1 ? console.error(a) : console.error(a, b)
        }
      }

      /** */
    },
    /* 184 */
    /** */ function(module, exports) {
      module.exports = function(exec) {
        try {
          return {
            error: false,
            value: exec(),
          }
        } catch (error) {
          return {
            error: true,
            value: error,
          }
        }
      }

      /** */
    },
    /* 185 */
    /** */ function(module, exports, __webpack_require__) {
      const defineWellKnownSymbol = __webpack_require__(89) // `Symbol.asyncIterator` well-known symbol
      // https://tc39.github.io/ecma262/#sec-symbol.asynciterator

      defineWellKnownSymbol('asyncIterator')

      /** */
    },
    /* 186 */
    /** */ function(module, exports, __webpack_require__) {
      const defineWellKnownSymbol = __webpack_require__(89) // `Symbol.toStringTag` well-known symbol
      // https://tc39.github.io/ecma262/#sec-symbol.tostringtag

      defineWellKnownSymbol('toStringTag')

      /** */
    },
    /* 187 */
    /** */ function(module, exports, __webpack_require__) {
      const global = __webpack_require__(8)

      const setToStringTag = __webpack_require__(40) // JSON[@@toStringTag] property
      // https://tc39.github.io/ecma262/#sec-json-@@tostringtag

      setToStringTag(global.JSON, 'JSON', true)

      /** */
    },
    /* 188 */
    /** */ function(module, exports, __webpack_require__) {
      const setToStringTag = __webpack_require__(40) // Math[@@toStringTag] property
      // https://tc39.github.io/ecma262/#sec-math-@@tostringtag

      setToStringTag(Math, 'Math', true)

      /** */
    },
    /* 189 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_array_includes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          34
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3__
        )
        /* harmony import */ const core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          23
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          32
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          44
        )
        /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          37
        )
        /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_9___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_9__
        )
        /* harmony import */ const core_js_modules_es_string_trim__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
          46
        )
        /* harmony import */ const regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
          75
        )

        function asyncGeneratorStep(
          gen,
          resolve,
          reject,
          _next,
          _throw,
          key,
          argument
        ) {
          try {
            var info = gen[key](argument)
            var {value} = info
          } catch (error) {
            reject(error)
            return
          }
          if (info.done) {
            resolve(value)
          } else {
            Promise.resolve(value).then(_next, _throw)
          }
        }

        function _asyncToGenerator(fn) {
          return function() {
            const self = this
            const arguments_ = arguments
            return new Promise(function(resolve, reject) {
              const gen = fn.apply(self, arguments_)
              function _next(value) {
                asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  'next',
                  value
                )
              }
              function _throw(error) {
                asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  'throw',
                  error
                )
              }
              _next(undefined)
            })
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (
            call &&
            (typeof call === 'object' || typeof call === 'function')
          ) {
            return call
          }
          return _assertThisInitialized(self)
        }

        function _assertThisInitialized(self) {
          if (self === void 0) {
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            )
          }
          return self
        }

        function _getPrototypeOf(o) {
          _getPrototypeOf = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o)
              }
          return _getPrototypeOf(o)
        }

        function _defineProperties(target, properties) {
          for (const descriptor of properties) {
            descriptor.enumerable = descriptor.enumerable || false
            descriptor.configurable = true
            if ('value' in descriptor) {
              descriptor.writable = true
            }
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }

        function _createClass(Constructor, protoProperties, staticProperties) {
          if (protoProperties) {
            _defineProperties(Constructor.prototype, protoProperties)
          }
          if (staticProperties) {
            _defineProperties(Constructor, staticProperties)
          }
          return Constructor
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError(
              'Super expression must either be null or a function'
            )
          }
          subClass.prototype = Object.create(
            superClass && superClass.prototype,
            {constructor: {value: subClass, writable: true, configurable: true}}
          )
          if (superClass) {
            _setPrototypeOf(subClass, superClass)
          }
        }

        function _setPrototypeOf(o, p) {
          _setPrototypeOf =
            Object.setPrototypeOf ||
            function _setPrototypeOf(o, p) {
              o.__proto__ = p
              return o
            }
          return _setPrototypeOf(o, p)
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function')
          }
        }

        const fs = __webpack_require__(35)

        const _require = __webpack_require__(190)
        const {Readable} = _require

        const sysPath = __webpack_require__(15)

        const picomatch = __webpack_require__(146)

        const _require2 = __webpack_require__(36)
        const {promisify} = _require2

        const _reference = [
          promisify(fs.readdir),
          promisify(fs.stat),
          promisify(fs.lstat),
        ]
        const readdir = _reference[0]
        const stat = _reference[1]
        const lstat = _reference[2]
        const supportsDirent = 'Dirent' in fs
        /**
         * @typedef {Object} EntryInfo
         * @property {String} path
         * @property {String} fullPath
         * @property {fs.Stats=} stats
         * @property {fs.Dirent=} dirent
         * @property {String} basename
         */

        const isWindows = process.platform === 'win32'
        const supportsBigint = typeof BigInt === 'function'
        const BANG = '!'
        const NORMAL_FLOW_ERRORS = new Set([
          'ENOENT',
          'EPERM',
          'EACCES',
          'ELOOP',
        ])
        const STAT_OPTIONS_SUPPORT_LENGTH = 3
        const FILE_TYPE = 'files'
        const DIR_TYPE = 'directories'
        const FILE_DIR_TYPE = 'files_directories'
        const EVERYTHING_TYPE = 'all'
        const FILE_TYPES = new Set([FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE])
        const DIR_TYPES = new Set([DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE])
        const ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE]

        const isNormalFlowError = function isNormalFlowError(errorCode) {
          return NORMAL_FLOW_ERRORS.has(errorCode)
        }

        const checkBasename = function checkBasename(f) {
          return f(entry.basename)
        }

        const normalizeFilter = function normalizeFilter(filter) {
          if (filter === undefined) {
            return
          }
          if (typeof filter === 'function') {
            return filter
          }

          if (typeof filter === 'string') {
            const glob = picomatch(filter.trim())
            return function(entry) {
              return glob(entry.basename)
            }
          }

          if (Array.isArray(filter)) {
            const positive = []
            const negative = []
            let _iteratorNormalCompletion = true
            let _didIteratorError = false
            let _iteratorError

            try {
              for (
                var _iterator = filter[Symbol.iterator](), _step;
                !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
                _iteratorNormalCompletion = true
              ) {
                const item = _step.value
                const trimmed = item.trim()

                if (trimmed.charAt(0) === BANG) {
                  negative.push(picomatch(trimmed.slice(1)))
                } else {
                  positive.push(picomatch(trimmed))
                }
              }
            } catch (error) {
              _didIteratorError = true
              _iteratorError = error
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return()
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError
                }
              }
            }

            if (negative.length > 0) {
              if (positive.length > 0) {
                return function(entry) {
                  return (
                    positive.some(function(f) {
                      return f(entry.basename)
                    }) &&
                    !negative.some(function(f) {
                      return f(entry.basename)
                    })
                  )
                }
              }
              return function(entry) {
                return !negative.some(function(f) {
                  return f(entry.basename)
                })
              }
            }
            return function(entry) {
              return positive.some(function(f) {
                return f(entry.basename)
              })
            }
          }
        }

        const ExploringDir = function ExploringDir(path, depth) {
          _classCallCheck(this, ExploringDir)

          this.path = path
          this.depth = depth
        }

        const ReaddirpStream =
          /* #__PURE__ */
          (function(_Readable) {
            _inherits(ReaddirpStream, _Readable)

            _createClass(ReaddirpStream, null, [
              {
                key: 'defaultOptions',
                get: function get() {
                  return {
                    root: '.',
                    fileFilter: function fileFilter(path) {
                      return true
                    },
                    directoryFilter: function directoryFilter(path) {
                      return true
                    },
                    type: 'files',
                    lstat: false,
                    depth: 2147483648,
                    alwaysStat: false,
                  }
                },
              },
            ])

            function ReaddirpStream() {
              let _this

              const options =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {}

              _classCallCheck(this, ReaddirpStream)

              _this = _possibleConstructorReturn(
                this,
                _getPrototypeOf(ReaddirpStream).call(this, {
                  objectMode: true,
                  highWaterMark: 1,
                  autoDestroy: true,
                })
              )
              const options_ = {
                ...ReaddirpStream.defaultOptions,
                ...options,
              }
              const {root} = options_
              _this._fileFilter = normalizeFilter(options_.fileFilter)
              _this._directoryFilter = normalizeFilter(options_.directoryFilter)
              _this._statMethod = options_.lstat ? lstat : stat
              _this._statOpts = {
                bigint: isWindows,
              }
              _this._maxDepth = options_.depth
              _this._entryType = options_.type
              _this._root = sysPath.resolve(root)
              _this._isDirent = !options_.alwaysStat && supportsDirent
              _this._statsProp = _this._isDirent ? 'dirent' : 'stats'
              _this._readdir_options = {
                encoding: 'utf8',
                withFileTypes: _this._isDirent,
              } // Launch stream with one parent, the root dir.

              /** @type Array<[string, number]>  */

              _this.parents = [new ExploringDir(root, 0)]
              _this.filesToRead = 0
              return _this
            }

            _createClass(ReaddirpStream, [
              {
                key: '_read',
                value: (function() {
                  const _read2 = _asyncToGenerator(
                    /* #__PURE__ */
                    regeneratorRuntime.mark(function _callee() {
                      let parent
                      return regeneratorRuntime.wrap(
                        function _callee$(_context) {
                          while (1) {
                            switch ((_context.prev = _context.next)) {
                              case 0:
                                if (!this.destroyed) {
                                  _context.next = 2
                                  break
                                }

                                return _context.abrupt('return')

                              case 2:
                                parent = this.parents.pop()

                                if (parent) {
                                  _context.next = 5
                                  break
                                }

                                return _context.abrupt('break', 8)

                              case 5:
                                _context.next = 7
                                return this._exploreDirectory(parent)

                              case 7:
                                if (!this.isPaused() && !this._isQueueEmpty()) {
                                  _context.next = 0
                                  break
                                }

                              case 8:
                                this._endStreamIfQueueIsEmpty()

                              case 9:
                              case 'end':
                                return _context.stop()
                            }
                          }
                        },
                        _callee,
                        this
                      )
                    })
                  )

                  function _read() {
                    return Reflect.apply(_read2, this, arguments)
                  }

                  return _read
                })(),
              },
              {
                key: '_exploreDirectory',
                value: (function() {
                  const _exploreDirectory2 = _asyncToGenerator(
                    /* #__PURE__ */
                    regeneratorRuntime.mark(function _callee2(parent) {
                      const _this2 = this

                      let files
                      let entries
                      let i
                      let _entry

                      return regeneratorRuntime.wrap(
                        function _callee2$(_context2) {
                          while (1) {
                            switch ((_context2.prev = _context2.next)) {
                              case 0:
                                /** @type Array<fs.Dirent|string> */
                                files = [] // To prevent race conditions, we increase counter while awaiting readdir.

                                this.filesToRead++
                                _context2.prev = 2
                                _context2.next = 5
                                return readdir(
                                  parent.path,
                                  this._readdir_options
                                )

                              case 5:
                                files = _context2.sent
                                _context2.next = 11
                                break

                              case 8:
                                _context2.prev = 8
                                _context2.t0 = _context2.catch(2)

                                if (isNormalFlowError(_context2.t0.code)) {
                                  this._handleError(_context2.t0)
                                } else {
                                  this._handleFatalError(_context2.t0)
                                }

                              case 11:
                                this.filesToRead-- // If the stream was destroyed, after readdir is completed

                                if (!this.destroyed) {
                                  _context2.next = 14
                                  break
                                }

                                return _context2.abrupt('return')

                              case 14:
                                this.filesToRead += files.length
                                _context2.next = 17
                                return Promise.all(
                                  files.map(function(dirent) {
                                    return _this2._formatEntry(dirent, parent)
                                  })
                                )

                              case 17:
                                entries = _context2.sent

                                if (!this.destroyed) {
                                  _context2.next = 20
                                  break
                                }

                                return _context2.abrupt('return')

                              case 20:
                                i = 0

                              case 21:
                                if (!(i < entries.length)) {
                                  _context2.next = 30
                                  break
                                }

                                _entry = entries[i]
                                this.filesToRead--

                                if (_entry) {
                                  _context2.next = 26
                                  break
                                }

                                return _context2.abrupt('continue', 27)

                              case 26:
                                if (this._isDirAndMatchesFilter(_entry)) {
                                  this._pushNewParentIfLessThanMaxDepth(
                                    _entry.fullPath,
                                    parent.depth + 1
                                  )

                                  this._emitPushIfUserWantsDir(_entry)
                                } else if (
                                  this._isFileAndMatchesFilter(_entry)
                                ) {
                                  this._emitPushIfUserWantsFile(_entry)
                                }

                              case 27:
                                i++
                                _context2.next = 21
                                break

                              case 30:
                              case 'end':
                                return _context2.stop()
                            }
                          }
                        },
                        _callee2,
                        this,
                        [[2, 8]]
                      )
                    })
                  )

                  function _exploreDirectory(_x) {
                    return Reflect.apply(_exploreDirectory2, this, arguments)
                  }

                  return _exploreDirectory
                })(),
              },
              {
                key: '_isStatOptionsSupported',
                value: function _isStatOptionsSupported() {
                  return this._statMethod.length === STAT_OPTIONS_SUPPORT_LENGTH
                },
              },
              {
                key: '_stat',
                value: function _stat(fullPath) {
                  if (isWindows && this._isStatOptionsSupported()) {
                    return this._statMethod(fullPath, this._statOpts)
                  }
                  return this._statMethod(fullPath)
                },
              },
              {
                key: '_formatEntry',
                value: (function() {
                  const _formatEntry2 = _asyncToGenerator(
                    /* #__PURE__ */
                    regeneratorRuntime.mark(function _callee3(dirent, parent) {
                      let basename
                      let fullPath
                      let stats
                      let path
                      let entry
                      return regeneratorRuntime.wrap(
                        function _callee3$(_context3) {
                          while (1) {
                            switch ((_context3.prev = _context3.next)) {
                              case 0:
                                basename = this._isDirent ? dirent.name : dirent
                                fullPath = sysPath.resolve(
                                  sysPath.join(parent.path, basename)
                                )

                                if (!this._isDirent) {
                                  _context3.next = 6
                                  break
                                }

                                stats = dirent
                                _context3.next = 16
                                break

                              case 6:
                                _context3.prev = 6
                                _context3.next = 9
                                return this._stat(fullPath)

                              case 9:
                                stats = _context3.sent
                                _context3.next = 16
                                break

                              case 12:
                                _context3.prev = 12
                                _context3.t0 = _context3.catch(6)

                                if (isNormalFlowError(_context3.t0.code)) {
                                  this._handleError(_context3.t0)
                                } else {
                                  this._handleFatalError(_context3.t0)
                                }

                                return _context3.abrupt('return')

                              case 16:
                                path = sysPath.relative(this._root, fullPath)
                                /** @type {EntryInfo} */

                                entry = {
                                  path,
                                  fullPath,
                                  basename,
                                  [this._statsProp]: stats,
                                }
                                return _context3.abrupt('return', entry)

                              case 19:
                              case 'end':
                                return _context3.stop()
                            }
                          }
                        },
                        _callee3,
                        this,
                        [[6, 12]]
                      )
                    })
                  )

                  function _formatEntry(_x2, _x3) {
                    return Reflect.apply(_formatEntry2, this, arguments)
                  }

                  return _formatEntry
                })(),
              },
              {
                key: '_isQueueEmpty',
                value: function _isQueueEmpty() {
                  return (
                    this.parents.length === 0 &&
                    this.filesToRead === 0 &&
                    this.readable
                  )
                },
              },
              {
                key: '_endStreamIfQueueIsEmpty',
                value: function _endStreamIfQueueIsEmpty() {
                  if (this._isQueueEmpty()) {
                    this.push(null)
                  }
                },
              },
              {
                key: '_pushNewParentIfLessThanMaxDepth',
                value: function _pushNewParentIfLessThanMaxDepth(
                  parentPath,
                  depth
                ) {
                  if (depth <= this._maxDepth) {
                    this.parents.push(new ExploringDir(parentPath, depth))
                    return true
                  }
                  return false
                },
              },
              {
                key: '_isDirAndMatchesFilter',
                value: function _isDirAndMatchesFilter(entry) {
                  return (
                    entry[this._statsProp].isDirectory() &&
                    this._directoryFilter(entry)
                  )
                },
              },
              {
                key: '_isFileAndMatchesFilter',
                value: function _isFileAndMatchesFilter(entry) {
                  const stats = entry[this._statsProp]
                  const isFileType =
                    (this._entryType === EVERYTHING_TYPE &&
                      !stats.isDirectory()) ||
                    stats.isFile() ||
                    stats.isSymbolicLink()
                  return isFileType && this._fileFilter(entry)
                },
              },
              {
                key: '_emitPushIfUserWantsDir',
                value: function _emitPushIfUserWantsDir(entry) {
                  const _this3 = this

                  if (DIR_TYPES.has(this._entryType)) {
                    // TODO: Understand why this happens.
                    const fn = function fn() {
                      _this3.push(entry)
                    }

                    if (this._isDirent) {
                      setImmediate(fn)
                    } else {
                      fn()
                    }
                  }
                },
              },
              {
                key: '_emitPushIfUserWantsFile',
                value: function _emitPushIfUserWantsFile(entry) {
                  if (FILE_TYPES.has(this._entryType)) {
                    this.push(entry)
                  }
                },
              },
              {
                key: '_handleError',
                value: function _handleError(error) {
                  if (!this.destroyed) {
                    this.emit('warn', error)
                  }
                },
              },
              {
                key: '_handleFatalError',
                value: function _handleFatalError(error) {
                  this.destroy(error)
                },
              },
            ])

            return ReaddirpStream
          })(Readable)
        /**
         * @typedef {Object} ReaddirpArguments
         * @property {Function=} fileFilter
         * @property {Function=} directoryFilter
         * @property {String=} type
         * @property {Number=} depth
         * @property {String=} root
         * @property {Boolean=} lstat
         * @property {Boolean=} bigint
         */

        /**
         * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
         * @param {String} root Root directory
         * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth
         */

        const readdirp = function readdirp(root) {
          const options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}
          let type = options.entryType || options.type
          if (type === 'both') {
            type = FILE_DIR_TYPE
          } // backwards-compatibility

          if (type) {
            options.type = type
          }

          if (root == null || typeof root === 'undefined') {
            throw new Error(
              'readdirp: root argument is required. Usage: readdirp(root, options)'
            )
          } else if (typeof root !== 'string') {
            throw new TypeError(
              `readdirp: root argument must be a string. Usage: readdirp(root, options)`
            )
          } else if (type && !ALL_TYPES.includes(type)) {
            throw new Error(
              `readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(
                ', '
              )}`
            )
          }

          options.root = root
          return new ReaddirpStream(options)
        }

        const readdirpPromise = function readdirpPromise(root) {
          const options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}
          return new Promise(function(resolve, reject) {
            const files = []
            readdirp(root, options)
              .on('data', function(entry) {
                return files.push(entry)
              })
              .on('end', function() {
                return resolve(files)
              })
              .on('error', function(error) {
                return reject(error)
              })
          })
        }

        readdirp.promise = readdirpPromise
        readdirp.ReaddirpStream = ReaddirpStream
        readdirp.default = readdirp
        module.exports = readdirp
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 190 */
    /** */ function(module, exports) {
      module.exports = require('stream')

      /** */
    },
    /* 191 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          13
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3__
        )
        /* harmony import */ const core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          23
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          43
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          16
        )
        /* harmony import */ const core_js_modules_es_regexp_flags__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          59
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
          3
        )
        /* harmony import */ const core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
          28
        )
        /* harmony import */ const core_js_modules_es_string_starts_with__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
          147
        )

        function ownKeys(object, enumerableOnly) {
          const keys = Object.keys(object)
          if (Object.getOwnPropertySymbols) {
            let symbols = Object.getOwnPropertySymbols(object)
            if (enumerableOnly) {
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable
              })
            }
            keys.push.apply(keys, symbols)
          }
          return keys
        }

        function _objectSpread(target) {
          for (let i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {}
            if (i % 2) {
              ownKeys(source, true).forEach(function(key) {
                _defineProperty(target, key, source[key])
              })
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(
                target,
                Object.getOwnPropertyDescriptors(source)
              )
            } else {
              ownKeys(source).forEach(function(key) {
                Object.defineProperty(
                  target,
                  key,
                  Object.getOwnPropertyDescriptor(source, key)
                )
              })
            }
          }
          return target
        }

        function _defineProperty(object, key, value) {
          if (key in object) {
            Object.defineProperty(object, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true,
            })
          } else {
            object[key] = value
          }
          return object
        }

        const path = __webpack_require__(15)

        const scan = __webpack_require__(192)

        const parse = __webpack_require__(193)

        const utils = __webpack_require__(106)
        /**
         * Creates a matcher function from one or more glob patterns. The
         * returned function takes a string to match as its first argument,
         * and returns true if the string is a match. The returned matcher
         * function also takes a boolean as the second argument that, when true,
         * returns an object with additional information.
         *
         * ```js
         * const picomatch = require('picomatch');
         * // picomatch(glob[, options]);
         *
         * const isMatch = picomatch('*.!(*a)');
         * console.log(isMatch('a.a')); //=> false
         * console.log(isMatch('a.b')); //=> true
         * ```
         * @name picomatch
         * @param {String|Array} `globs` One or more glob patterns.
         * @param {Object=} `options`
         * @return {Function=} Returns a matcher function.
         * @api public
         */

        const picomatch = function picomatch(glob, options) {
          const returnState =
            arguments.length > 2 && arguments[2] !== undefined
              ? arguments[2]
              : false

          if (Array.isArray(glob)) {
            const fns = glob.map(function(input) {
              return picomatch(input, options, returnState)
            })
            return function(string) {
              let _iteratorNormalCompletion = true
              let _didIteratorError = false
              let _iteratorError

              try {
                for (
                  var _iterator = fns[Symbol.iterator](), _step;
                  !(_iteratorNormalCompletion = (_step = _iterator.next())
                    .done);
                  _iteratorNormalCompletion = true
                ) {
                  const isMatch = _step.value

                  const _state = isMatch(string)

                  if (_state) {
                    return _state
                  }
                }
              } catch (error) {
                _didIteratorError = true
                _iteratorError = error
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return()
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError
                  }
                }
              }

              return false
            }
          }

          if (typeof glob !== 'string' || glob === '') {
            throw new TypeError('Expected pattern to be a non-empty string')
          }

          const options_ = options || {}
          const posix = utils.isWindows(options)
          const regex = picomatch.makeRe(glob, options, false, true)
          const {state} = regex
          delete regex.state

          let isIgnored = function isIgnored() {
            return false
          }

          if (options_.ignore) {
            const ignoreOptions = _objectSpread({}, options, {
              ignore: null,
              onMatch: null,
              onResult: null,
            })

            isIgnored = picomatch(options_.ignore, ignoreOptions, returnState)
          }

          const matcher = function matcher(input) {
            const returnObject =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : false

            const _picomatch$test = picomatch.test(input, regex, options, {
              glob,
              posix,
            })
            const {isMatch} = _picomatch$test
            const {match} = _picomatch$test
            const {output} = _picomatch$test

            const result = {
              glob,
              state,
              regex,
              posix,
              input,
              output,
              match,
              isMatch,
            }

            if (typeof options_.onResult === 'function') {
              options_.onResult(result)
            }

            if (isMatch === false) {
              result.isMatch = false
              return returnObject ? result : false
            }

            if (isIgnored(input)) {
              if (typeof options_.onIgnore === 'function') {
                options_.onIgnore(result)
              }

              result.isMatch = false
              return returnObject ? result : false
            }

            if (typeof options_.onMatch === 'function') {
              options_.onMatch(result)
            }

            return returnObject ? result : true
          }

          if (returnState) {
            matcher.state = state
          }

          return matcher
        }
        /**
         * Test `input` with the given `regex`. This is used by the main
         * `picomatch()` function to test the input string.
         *
         * ```js
         * const picomatch = require('picomatch');
         * // picomatch.test(input, regex[, options]);
         *
         * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
         * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
         * ```
         * @param {String} `input` String to test.
         * @param {RegExp} `regex`
         * @return {Object} Returns an object with matching info.
         * @api public
         */

        picomatch.test = function(input, regex, options) {
          const _reference =
            arguments.length > 3 && arguments[3] !== undefined
              ? arguments[3]
              : {}
          const {glob} = _reference
          const {posix} = _reference

          if (typeof input !== 'string') {
            throw new TypeError('Expected input to be a string')
          }

          if (input === '') {
            return {
              isMatch: false,
              output: '',
            }
          }

          const options_ = options || {}
          const format =
            options_.format || (posix ? utils.toPosixSlashes : null)
          let match = input === glob
          let output = match && format ? format(input) : input

          if (match === false) {
            output = format ? format(input) : input
            match = output === glob
          }

          if (match === false || options_.capture === true) {
            if (options_.matchBase === true || options_.basename === true) {
              match = picomatch.matchBase(input, regex, options, posix)
            } else {
              match = regex.exec(output)
            }
          }

          return {
            isMatch: !!match,
            match,
            output,
          }
        }
        /**
         * Match the basename of a filepath.
         *
         * ```js
         * const picomatch = require('picomatch');
         * // picomatch.matchBase(input, glob[, options]);
         * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
         * ```
         * @param {String} `input` String to test.
         * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
         * @return {Boolean}
         * @api public
         */

        picomatch.matchBase = function(input, glob, options) {
          const posix =
            arguments.length > 3 && arguments[3] !== undefined
              ? arguments[3]
              : utils.isWindows(options)
          const regex =
            glob instanceof RegExp ? glob : picomatch.makeRe(glob, options)
          return regex.test(path.basename(input))
        }
        /**
         * Returns true if **any** of the given glob `patterns` match the specified `string`.
         *
         * ```js
         * const picomatch = require('picomatch');
         * // picomatch.isMatch(string, patterns[, options]);
         *
         * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
         * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
         * ```
         * @param {String|Array} str The string to test.
         * @param {String|Array} patterns One or more glob patterns to use for matching.
         * @param {Object} [options] See available [options](#options).
         * @return {Boolean} Returns true if any patterns match `str`
         * @api public
         */

        picomatch.isMatch = function(string, patterns, options) {
          return picomatch(patterns, options)(string)
        }
        /**
         * Parse a glob pattern to create the source string for a regular
         * expression.
         *
         * ```js
         * const picomatch = require('picomatch');
         * const result = picomatch.parse(glob[, options]);
         * ```
         * @param {String} `glob`
         * @param {Object} `options`
         * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
         * @api public
         */

        picomatch.parse = function(glob, options) {
          return parse(glob, options)
        }
        /**
         * Scan a glob pattern to separate the pattern into segments.
         *
         * ```js
         * const picomatch = require('picomatch');
         * // picomatch.scan(input[, options]);
         *
         * const result = picomatch.scan('!./foo/*.js');
         * console.log(result);
         * // { prefix: '!./',
         * //   input: '!./foo/*.js',
         * //   base: 'foo',
         * //   glob: '*.js',
         * //   negated: true,
         * //   isGlob: true }
         * ```
         * @param {String} `input` Glob pattern to scan.
         * @param {Object} `options`
         * @return {Object} Returns an object with
         * @api public
         */

        picomatch.scan = function(input, options) {
          return scan(input, options)
        }
        /**
         * Create a regular expression from a glob pattern.
         *
         * ```js
         * const picomatch = require('picomatch');
         * // picomatch.makeRe(input[, options]);
         *
         * console.log(picomatch.makeRe('*.js'));
         * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
         * ```
         * @param {String} `input` A glob pattern to convert to regex.
         * @param {Object} `options`
         * @return {RegExp} Returns a regex created from the given pattern.
         * @api public
         */

        picomatch.makeRe = function(input, options) {
          const returnOutput =
            arguments.length > 2 && arguments[2] !== undefined
              ? arguments[2]
              : false
          const returnState =
            arguments.length > 3 && arguments[3] !== undefined
              ? arguments[3]
              : false

          if (!input || typeof input !== 'string') {
            throw new TypeError('Expected a non-empty string')
          }

          const options_ = options || {}
          const prepend = options_.contains ? '' : '^'
          const append = options_.contains ? '' : '$'
          let state = {
            negated: false,
            fastpaths: true,
          }
          let prefix = ''
          let output

          if (input.startsWith('./')) {
            input = input.slice(2)
            prefix = state.prefix = './'
          }

          if (
            options_.fastpaths !== false &&
            (input[0] === '.' || input[0] === '*')
          ) {
            output = parse.fastpaths(input, options)
          }

          if (output === void 0) {
            state = picomatch.parse(input, options)
            state.prefix = prefix + (state.prefix || '')
            output = state.output
          }

          if (returnOutput === true) {
            return output
          }

          let source = `${prepend}(?:${output})${append}`

          if (state && state.negated === true) {
            source = `^(?!${source}).*$`
          }

          const regex = picomatch.toRegex(source, options)

          if (returnState === true) {
            regex.state = state
          }

          return regex
        }
        /**
         * Create a regular expression from the given regex source string.
         *
         * ```js
         * const picomatch = require('picomatch');
         * // picomatch.toRegex(source[, options]);
         *
         * const { output } = picomatch.parse('*.js');
         * console.log(picomatch.toRegex(output));
         * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
         * ```
         * @param {String} `source` Regular expression source string.
         * @param {Object} `options`
         * @return {RegExp}
         * @api public
         */

        picomatch.toRegex = function(source, options) {
          try {
            const options_ = options || {}
            return new RegExp(
              source,
              options_.flags || (options_.nocase ? 'i' : '')
            )
          } catch (error) {
            if (options && options.debug === true) {
              throw error
            }
            return /$^/
          }
        }
        /**
         * Picomatch constants.
         * @return {Object}
         */

        picomatch.constants = __webpack_require__(76)
        /**
         * Expose "picomatch"
         */

        module.exports = picomatch
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 192 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          2
        )

        const utils = __webpack_require__(106)

        const _require = __webpack_require__(76)
        const {CHAR_ASTERISK} = _require
        const {CHAR_AT} = _require
        const {CHAR_BACKWARD_SLASH} = _require
        const {CHAR_COMMA} = _require
        const {CHAR_DOT} = _require
        const {CHAR_EXCLAMATION_MARK} = _require
        const {CHAR_FORWARD_SLASH} = _require
        const {CHAR_LEFT_CURLY_BRACE} = _require
        const {CHAR_LEFT_PARENTHESES} = _require
        const {CHAR_LEFT_SQUARE_BRACKET} = _require
        const {CHAR_PLUS} = _require
        const {CHAR_QUESTION_MARK} = _require
        const {CHAR_RIGHT_CURLY_BRACE} = _require
        const {CHAR_RIGHT_PARENTHESES} = _require
        const {CHAR_RIGHT_SQUARE_BRACKET} = _require

        const isPathSeparator = function isPathSeparator(code) {
          return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH
        }
        /**
         * Quickly scans a glob pattern and returns an object with a handful of
         * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
         * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).
         *
         * ```js
         * const pm = require('picomatch');
         * console.log(pm.scan('foo/bar/*.js'));
         * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
         * ```
         * @param {String} `str`
         * @param {Object} `options`
         * @return {Object} Returns an object with tokens and regex source string.
         * @api public
         */

        module.exports = function(input, options) {
          const options_ = options || {}
          const length = input.length - 1
          let index = -1
          let start = 0
          let lastIndex = 0
          let isGlob = false
          let backslashes = false
          let negated = false
          let braces = 0
          let previous
          let code
          let braceEscaped = false

          const eos = function eos() {
            return index >= length
          }

          const advance = function advance() {
            previous = code
            return input.charCodeAt(++index)
          }

          while (index < length) {
            code = advance()
            let next = void 0

            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = true
              next = advance()

              if (next === CHAR_LEFT_CURLY_BRACE) {
                braceEscaped = true
              }

              continue
            }

            if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
              braces++

              while (!eos() && (next = advance())) {
                if (next === CHAR_BACKWARD_SLASH) {
                  backslashes = true
                  next = advance()
                  continue
                }

                if (next === CHAR_LEFT_CURLY_BRACE) {
                  braces++
                  continue
                }

                if (
                  !braceEscaped &&
                  next === CHAR_DOT &&
                  (next = advance()) === CHAR_DOT
                ) {
                  isGlob = true
                  break
                }

                if (!braceEscaped && next === CHAR_COMMA) {
                  isGlob = true
                  break
                }

                if (next === CHAR_RIGHT_CURLY_BRACE) {
                  braces--

                  if (braces === 0) {
                    braceEscaped = false
                    break
                  }
                }
              }
            }

            if (code === CHAR_FORWARD_SLASH) {
              if (previous === CHAR_DOT && index === start + 1) {
                start += 2
                continue
              }

              lastIndex = index + 1
              continue
            }

            if (code === CHAR_ASTERISK) {
              isGlob = true
              break
            }

            if (code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK) {
              isGlob = true
              break
            }

            if (code === CHAR_LEFT_SQUARE_BRACKET) {
              while (!eos() && (next = advance())) {
                if (next === CHAR_BACKWARD_SLASH) {
                  backslashes = true
                  next = advance()
                  continue
                }

                if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                  isGlob = true
                  break
                }
              }
            }

            const isExtglobChar =
              code === CHAR_PLUS ||
              code === CHAR_AT ||
              code === CHAR_EXCLAMATION_MARK

            if (
              isExtglobChar &&
              input.charCodeAt(index + 1) === CHAR_LEFT_PARENTHESES
            ) {
              isGlob = true
              break
            }

            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negated = true
              start++
              continue
            }

            if (code === CHAR_LEFT_PARENTHESES) {
              while (!eos() && (next = advance())) {
                if (next === CHAR_BACKWARD_SLASH) {
                  backslashes = true
                  next = advance()
                  continue
                }

                if (next === CHAR_RIGHT_PARENTHESES) {
                  isGlob = true
                  break
                }
              }
            }

            if (isGlob) {
              break
            }
          }

          let prefix = ''
          const orig = input
          let base = input
          let glob = ''

          if (start > 0) {
            prefix = input.slice(0, start)
            input = input.slice(start)
            lastIndex -= start
          }

          if (base && isGlob === true && lastIndex > 0) {
            base = input.slice(0, lastIndex)
            glob = input.slice(lastIndex)
          } else if (isGlob === true) {
            base = ''
            glob = input
          } else {
            base = input
          }

          if (base && base !== '' && base !== '/' && base !== input) {
            if (isPathSeparator(base.charCodeAt(base.length - 1))) {
              base = base.slice(0, -1)
            }
          }

          if (options_.unescape === true) {
            if (glob) {
              glob = utils.removeBackslashes(glob)
            }

            if (base && backslashes === true) {
              base = utils.removeBackslashes(base)
            }
          }

          return {
            prefix,
            input: orig,
            base,
            glob,
            negated,
            isGlob,
          }
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 193 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          11
        )
        /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          13
        )
        /* harmony import */ const core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          27
        )
        /* harmony import */ const core_js_modules_es_array_includes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          34
        )
        /* harmony import */ const core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          21
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_7___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_7__
        )
        /* harmony import */ const core_js_modules_es_array_last_index_of__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          48
        )
        /* harmony import */ const core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          23
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_array_sort__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
          42
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
          43
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_12___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_12__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
          16
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
          3
        )
        /* harmony import */ const core_js_modules_es_string_includes__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
          41
        )
        /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(
          14
        )

        function ownKeys(object, enumerableOnly) {
          const keys = Object.keys(object)
          if (Object.getOwnPropertySymbols) {
            let symbols = Object.getOwnPropertySymbols(object)
            if (enumerableOnly) {
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable
              })
            }
            keys.push.apply(keys, symbols)
          }
          return keys
        }

        function _objectSpread(target) {
          for (let i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {}
            if (i % 2) {
              ownKeys(source, true).forEach(function(key) {
                _defineProperty(target, key, source[key])
              })
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(
                target,
                Object.getOwnPropertyDescriptors(source)
              )
            } else {
              ownKeys(source).forEach(function(key) {
                Object.defineProperty(
                  target,
                  key,
                  Object.getOwnPropertyDescriptor(source, key)
                )
              })
            }
          }
          return target
        }

        function _defineProperty(object, key, value) {
          if (key in object) {
            Object.defineProperty(object, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true,
            })
          } else {
            object[key] = value
          }
          return object
        }

        function _toConsumableArray(array) {
          return (
            _arrayWithoutHoles(array) ||
            _iterableToArray(array) ||
            _nonIterableSpread()
          )
        }

        function _nonIterableSpread() {
          throw new TypeError('Invalid attempt to spread non-iterable instance')
        }

        function _iterableToArray(iter) {
          if (
            Symbol.iterator in new Object(iter) ||
            Object.prototype.toString.call(iter) === '[object Arguments]'
          ) {
            return Array.from(iter)
          }
        }

        function _arrayWithoutHoles(array) {
          if (Array.isArray(array)) {
            for (
              var i = 0, array2 = new Array(array.length);
              i < array.length;
              i++
            ) {
              array2[i] = array[i]
            }
            return array2
          }
        }

        const utils = __webpack_require__(106)

        const constants = __webpack_require__(76)
        /**
         * Constants
         */

        const {MAX_LENGTH} = constants
        const {POSIX_REGEX_SOURCE} = constants
        const {REGEX_NON_SPECIAL_CHAR} = constants
        const {REGEX_SPECIAL_CHARS_BACKREF} = constants
        const {REPLACEMENTS} = constants
        /**
         * Helpers
         */

        const expandRange = function expandRange(arguments_, options) {
          if (typeof options.expandRange === 'function') {
            return options.expandRange.apply(
              options,
              _toConsumableArray(arguments_).concat([options])
            )
          }

          arguments_.sort()
          const value = `[${arguments_.join('-')}]`

          try {
            /* eslint-disable no-new */
            new RegExp(value)
          } catch (error) {
            return arguments_
              .map(function(v) {
                return utils.escapeRegex(v)
              })
              .join('..')
          }

          return value
        }

        const negate = function negate(state) {
          let count = 1

          while (
            state.peek() === '!' &&
            (state.peek(2) !== '(' || state.peek(3) === '?')
          ) {
            state.advance()
            state.start++
            count++
          }

          if (count % 2 === 0) {
            return false
          }

          state.negated = true
          state.start++
          return true
        }
        /**
         * Create the message for a syntax error
         */

        const syntaxError = function syntaxError(type, char) {
          return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`
        }
        /**
         * Parse the given input string.
         * @param {String} input
         * @param {Object} options
         * @return {Object}
         */

        const parse = function parse(input, options) {
          if (typeof input !== 'string') {
            throw new TypeError('Expected a string')
          }

          input = REPLACEMENTS[input] || input

          const options_ = _objectSpread({}, options)

          const max =
            typeof options_.maxLength === 'number'
              ? Math.min(MAX_LENGTH, options_.maxLength)
              : MAX_LENGTH
          const length_ = input.length

          if (length_ > max) {
            throw new SyntaxError(
              `Input length: ${length_}, exceeds maximum allowed length: ${max}`
            )
          }

          const bos = {
            type: 'bos',
            value: '',
            output: options_.prepend || '',
          }
          const tokens = [bos]
          const capture = options_.capture ? '' : '?:'
          const win32 = utils.isWindows(options) // create constants based on platform, for windows or posix

          const PLATFORM_CHARS = constants.globChars(win32)
          const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS)
          const {DOT_LITERAL} = PLATFORM_CHARS
          const {PLUS_LITERAL} = PLATFORM_CHARS
          const {SLASH_LITERAL} = PLATFORM_CHARS
          const {ONE_CHAR} = PLATFORM_CHARS
          const {DOTS_SLASH} = PLATFORM_CHARS
          const {NO_DOT} = PLATFORM_CHARS
          const {NO_DOT_SLASH} = PLATFORM_CHARS
          const {NO_DOTS_SLASH} = PLATFORM_CHARS
          const {QMARK} = PLATFORM_CHARS
          const {QMARK_NO_DOT} = PLATFORM_CHARS
          const {STAR} = PLATFORM_CHARS
          const {START_ANCHOR} = PLATFORM_CHARS

          const globstar = function globstar(options__) {
            return `(${capture}(?:(?!${START_ANCHOR}${
              options__.dot ? DOTS_SLASH : DOT_LITERAL
            }).)*?)`
          }

          const nodot = options_.dot ? '' : NO_DOT
          let star = options_.bash === true ? globstar(options_) : STAR
          const qmarkNoDot = options_.dot ? QMARK : QMARK_NO_DOT

          if (options_.capture) {
            star = `(${star})`
          } // minimatch options support

          if (typeof options_.noext === 'boolean') {
            options_.noextglob = options_.noext
          }

          const state = {
            index: -1,
            start: 0,
            consumed: '',
            output: '',
            backtrack: false,
            brackets: 0,
            braces: 0,
            parens: 0,
            quotes: 0,
            tokens,
          }
          const extglobs = []
          const stack = []
          let previous = bos
          let value
          /**
           * Tokenizing helpers
           */

          const eos = function eos() {
            return state.index === length_ - 1
          }

          const peek = (state.peek = function() {
            const n =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : 1
            return input[state.index + n]
          })

          const advance = (state.advance = function() {
            return input[++state.index]
          })

          const append = function append(token) {
            state.output += token.output != null ? token.output : token.value
            state.consumed += token.value || ''
          }

          const increment = function increment(type) {
            state[type]++
            stack.push(type)
          }

          const decrement = function decrement(type) {
            state[type]--
            stack.pop()
          }
          /**
           * Push tokens onto the tokens array. This helper speeds up
           * tokenizing by 1) helping us avoid backtracking as much as possible,
           * and 2) helping us avoid creating extra tokens when consecutive
           * characters are plain text. This improves performance and simplifies
           * lookbehinds.
           */

          const push = function push(tok) {
            if (previous.type === 'globstar') {
              const isBrace =
                state.braces > 0 &&
                (tok.type === 'comma' || tok.type === 'brace')
              const isExtglob =
                extglobs.length && (tok.type === 'pipe' || tok.type === 'paren')

              if (
                tok.type !== 'slash' &&
                tok.type !== 'paren' &&
                !isBrace &&
                !isExtglob
              ) {
                state.output = state.output.slice(0, -previous.output.length)
                previous.type = 'star'
                previous.value = '*'
                previous.output = star
                state.output += previous.output
              }
            }

            if (
              extglobs.length &&
              tok.type !== 'paren' &&
              !EXTGLOB_CHARS[tok.value]
            ) {
              extglobs[extglobs.length - 1].inner += tok.value
            }

            if (tok.value || tok.output) {
              append(tok)
            }

            if (previous && previous.type === 'text' && tok.type === 'text') {
              previous.value += tok.value
              return
            }

            tok.prev = previous
            tokens.push(tok)
            previous = tok
          }

          const extglobOpen = function extglobOpen(type, value) {
            const token = _objectSpread({}, EXTGLOB_CHARS[value], {
              conditions: 1,
              inner: '',
            })

            token.prev = previous
            token.parens = state.parens
            token.output = state.output
            const output = (options_.capture ? '(' : '') + token.open
            push({
              type,
              value,
              output: state.output ? '' : ONE_CHAR,
            })
            push({
              type: 'paren',
              extglob: true,
              value: advance(),
              output,
            })
            increment('parens')
            extglobs.push(token)
          }

          const extglobClose = function extglobClose(token) {
            let output = token.close + (options_.capture ? ')' : '')

            if (token.type === 'negate') {
              let extglobStar = star

              if (
                token.inner &&
                token.inner.length > 1 &&
                token.inner.includes('/')
              ) {
                extglobStar = globstar(options_)
              }

              if (
                extglobStar !== star ||
                eos() ||
                /^\)+$/.test(input.slice(state.index + 1))
              ) {
                output = token.close = `)$))${extglobStar}`
              }

              if (token.prev.type === 'bos' && eos()) {
                state.negatedExtglob = true
              }
            }

            push({
              type: 'paren',
              extglob: true,
              value,
              output,
            })
            decrement('parens')
          }

          if (
            options_.fastpaths !== false &&
            !/(^[*!]|[/{[()\]}"])/.test(input)
          ) {
            let backslashes = false
            let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, function(
              m,
              esc,
              chars,
              first,
              rest,
              index
            ) {
              if (first === '\\') {
                backslashes = true
                return m
              }

              if (first === '?') {
                if (esc) {
                  return esc + first + (rest ? QMARK.repeat(rest.length) : '')
                }

                if (index === 0) {
                  return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '')
                }

                return QMARK.repeat(chars.length)
              }

              if (first === '.') {
                return DOT_LITERAL.repeat(chars.length)
              }

              if (first === '*') {
                if (esc) {
                  return esc + first + (rest ? star : '')
                }

                return star
              }

              return esc ? m : `\\${m}`
            })

            if (backslashes === true) {
              if (options_.unescape === true) {
                output = output.replace(/\\/g, '')
              } else {
                output = output.replace(/\\+/g, function(m) {
                  return m.length % 2 === 0 ? '\\\\' : m ? '\\' : ''
                })
              }
            }

            state.output = output
            return state
          }
          /**
           * Tokenize input until we reach end-of-string
           */

          while (!eos()) {
            value = advance()

            if (value === '\u0000') {
              continue
            }
            /**
             * Escaped characters
             */

            if (value === '\\') {
              const next = peek()

              if (next === '/' && options_.bash !== true) {
                continue
              }

              if (next === '.' || next === ';') {
                continue
              }

              if (!next) {
                value += '\\'
                push({
                  type: 'text',
                  value,
                })
                continue
              } // collapse slashes to reduce potential for exploits

              const match = /^\\+/.exec(input.slice(state.index + 1))
              let slashes = 0

              if (match && match[0].length > 2) {
                slashes = match[0].length
                state.index += slashes

                if (slashes % 2 !== 0) {
                  value += '\\'
                }
              }

              if (options_.unescape === true) {
                value = advance() || ''
              } else {
                value += advance() || ''
              }

              if (state.brackets === 0) {
                push({
                  type: 'text',
                  value,
                })
                continue
              }
            }
            /**
             * If we're inside a regex character class, continue
             * until we reach the closing bracket.
             */

            if (
              state.brackets > 0 &&
              (value !== ']' ||
                previous.value === '[' ||
                previous.value === '[^')
            ) {
              if (options_.posix !== false && value === ':') {
                const inner = previous.value.slice(1)

                if (inner.includes('[')) {
                  previous.posix = true

                  if (inner.includes(':')) {
                    const idx = previous.value.lastIndexOf('[')
                    const pre = previous.value.slice(0, idx)
                    const rest = previous.value.slice(idx + 2)
                    const posix = POSIX_REGEX_SOURCE[rest]

                    if (posix) {
                      previous.value = pre + posix
                      state.backtrack = true
                      advance()

                      if (!bos.output && tokens.indexOf(previous) === 1) {
                        bos.output = ONE_CHAR
                      }

                      continue
                    }
                  }
                }
              }

              if (
                (value === '[' && peek() !== ':') ||
                (value === '-' && peek() === ']')
              ) {
                value = `\\${value}`
              }

              if (
                value === ']' &&
                (previous.value === '[' || previous.value === '[^')
              ) {
                value = `\\${value}`
              }

              if (
                options_.posix === true &&
                value === '!' &&
                previous.value === '['
              ) {
                value = '^'
              }

              previous.value += value
              append({
                value,
              })
              continue
            }
            /**
             * If we're inside a quoted string, continue
             * until we reach the closing double quote.
             */

            if (state.quotes === 1 && value !== '"') {
              value = utils.escapeRegex(value)
              previous.value += value
              append({
                value,
              })
              continue
            }
            /**
             * Double quotes
             */

            if (value === '"') {
              state.quotes = state.quotes === 1 ? 0 : 1

              if (options_.keepQuotes === true) {
                push({
                  type: 'text',
                  value,
                })
              }

              continue
            }
            /**
             * Parentheses
             */

            if (value === '(') {
              push({
                type: 'paren',
                value,
              })
              increment('parens')
              continue
            }

            if (value === ')') {
              if (state.parens === 0 && options_.strictBrackets === true) {
                throw new SyntaxError(syntaxError('opening', '('))
              }

              const extglob = extglobs[extglobs.length - 1]

              if (extglob && state.parens === extglob.parens + 1) {
                extglobClose(extglobs.pop())
                continue
              }

              push({
                type: 'paren',
                value,
                output: state.parens ? ')' : '\\)',
              })
              decrement('parens')
              continue
            }
            /**
             * Brackets
             */

            if (value === '[') {
              if (
                options_.nobracket === true ||
                !input.slice(state.index + 1).includes(']')
              ) {
                if (
                  options_.nobracket !== true &&
                  options_.strictBrackets === true
                ) {
                  throw new SyntaxError(syntaxError('closing', ']'))
                }

                value = `\\${value}`
              } else {
                increment('brackets')
              }

              push({
                type: 'bracket',
                value,
              })
              continue
            }

            if (value === ']') {
              if (
                options_.nobracket === true ||
                (previous &&
                  previous.type === 'bracket' &&
                  previous.value.length === 1)
              ) {
                push({
                  type: 'text',
                  value,
                  output: `\\${value}`,
                })
                continue
              }

              if (state.brackets === 0) {
                if (options_.strictBrackets === true) {
                  throw new SyntaxError(syntaxError('opening', '['))
                }

                push({
                  type: 'text',
                  value,
                  output: `\\${value}`,
                })
                continue
              }

              decrement('brackets')
              const previousValue = previous.value.slice(1)

              if (
                previous.posix !== true &&
                previousValue[0] === '^' &&
                !previousValue.includes('/')
              ) {
                value = `/${value}`
              }

              previous.value += value
              append({
                value,
              }) // when literal brackets are explicitly disabled
              // assume we should match with a regex character class

              if (
                options_.literalBrackets === false ||
                utils.hasRegexChars(previousValue)
              ) {
                continue
              }

              const escaped = utils.escapeRegex(previous.value)
              state.output = state.output.slice(0, -previous.value.length) // when literal brackets are explicitly enabled
              // assume we should escape the brackets to match literal characters

              if (options_.literalBrackets === true) {
                state.output += escaped
                previous.value = escaped
                continue
              } // when the user specifies nothing, try to match both

              previous.value = `(${capture}${escaped}|${previous.value})`
              state.output += previous.value
              continue
            }
            /**
             * Braces
             */

            if (value === '{' && options_.nobrace !== true) {
              push({
                type: 'brace',
                value,
                output: '(',
              })
              increment('braces')
              continue
            }

            if (value === '}') {
              if (options_.nobrace === true || state.braces === 0) {
                push({
                  type: 'text',
                  value,
                  output: `\\${value}`,
                })
                continue
              }

              let _output = ')'

              if (state.dots === true) {
                const array = tokens.slice()
                const range = []

                for (let i = array.length - 1; i >= 0; i--) {
                  tokens.pop()

                  if (array[i].type === 'brace') {
                    break
                  }

                  if (array[i].type !== 'dots') {
                    range.unshift(array[i].value)
                  }
                }

                _output = expandRange(range, options_)
                state.backtrack = true
              }

              push({
                type: 'brace',
                value,
                output: _output,
              })
              decrement('braces')
              continue
            }
            /**
             * Pipes
             */

            if (value === '|') {
              if (extglobs.length > 0) {
                extglobs[extglobs.length - 1].conditions++
              }

              push({
                type: 'text',
                value,
              })
              continue
            }
            /**
             * Commas
             */

            if (value === ',') {
              let _output2 = value

              if (state.braces > 0 && stack[stack.length - 1] === 'braces') {
                _output2 = '|'
              }

              push({
                type: 'comma',
                value,
                output: _output2,
              })
              continue
            }
            /**
             * Slashes
             */

            if (value === '/') {
              // if the beginning of the glob is "./", advance the start
              // to the current index, and don't add the "./" characters
              // to the state. This greatly simplifies lookbehinds when
              // checking for BOS characters like "!" and "." (not "./")
              if (previous.type === 'dot' && state.index === 1) {
                state.start = state.index + 1
                state.consumed = ''
                state.output = ''
                tokens.pop()
                previous = bos // reset "prev" to the first token

                continue
              }

              push({
                type: 'slash',
                value,
                output: SLASH_LITERAL,
              })
              continue
            }
            /**
             * Dots
             */

            if (value === '.') {
              if (state.braces > 0 && previous.type === 'dot') {
                if (previous.value === '.') {
                  previous.output = DOT_LITERAL
                }
                previous.type = 'dots'
                previous.output += value
                previous.value += value
                state.dots = true
                continue
              }

              push({
                type: 'dot',
                value,
                output: DOT_LITERAL,
              })
              continue
            }
            /**
             * Question marks
             */

            if (value === '?') {
              if (previous && previous.type === 'paren') {
                const _next = peek()

                let _output3 = value

                if (_next === '<' && !utils.supportsLookbehinds()) {
                  throw new Error(
                    'Node.js v10 or higher is required for regex lookbehinds'
                  )
                }

                if (
                  (previous.value === '(' && !/[!=<:]/.test(_next)) ||
                  (_next === '<' && !/[!=]/.test(peek(2)))
                ) {
                  _output3 = `\\${value}`
                }

                push({
                  type: 'text',
                  value,
                  output: _output3,
                })
                continue
              }

              if (
                options_.noextglob !== true &&
                peek() === '(' &&
                peek(2) !== '?'
              ) {
                extglobOpen('qmark', value)
                continue
              }

              if (
                options_.dot !== true &&
                (previous.type === 'slash' || previous.type === 'bos')
              ) {
                push({
                  type: 'qmark',
                  value,
                  output: QMARK_NO_DOT,
                })
                continue
              }

              push({
                type: 'qmark',
                value,
                output: QMARK,
              })
              continue
            }
            /**
             * Exclamation
             */

            if (value === '!') {
              if (options_.noextglob !== true && peek() === '(') {
                if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
                  extglobOpen('negate', value)
                  continue
                }
              }

              if (options_.nonegate !== true && state.index === 0) {
                negate(state)
                continue
              }
            }
            /**
             * Plus
             */

            if (value === '+') {
              if (
                options_.noextglob !== true &&
                peek() === '(' &&
                peek(2) !== '?'
              ) {
                extglobOpen('plus', value)
                continue
              }

              if (
                previous &&
                (previous.type === 'bracket' ||
                  previous.type === 'paren' ||
                  previous.type === 'brace')
              ) {
                const _output4 =
                  previous.extglob === true ? `\\${value}` : value

                push({
                  type: 'plus',
                  value,
                  output: _output4,
                })
                continue
              } // use regex behavior inside parens

              if (state.parens > 0 && options_.regex !== false) {
                push({
                  type: 'plus',
                  value,
                })
                continue
              }

              push({
                type: 'plus',
                value: PLUS_LITERAL,
              })
              continue
            }
            /**
             * Plain text
             */

            if (value === '@') {
              if (
                options_.noextglob !== true &&
                peek() === '(' &&
                peek(2) !== '?'
              ) {
                push({
                  type: 'at',
                  value,
                  output: '',
                })
                continue
              }

              push({
                type: 'text',
                value,
              })
              continue
            }
            /**
             * Plain text
             */

            if (value !== '*') {
              if (value === '$' || value === '^') {
                value = `\\${value}`
              }

              const _match = REGEX_NON_SPECIAL_CHAR.exec(
                input.slice(state.index + 1)
              )

              if (_match) {
                value += _match[0]
                state.index += _match[0].length
              }

              push({
                type: 'text',
                value,
              })
              continue
            }
            /**
             * Stars
             */

            if (
              previous &&
              (previous.type === 'globstar' || previous.star === true)
            ) {
              previous.type = 'star'
              previous.star = true
              previous.value += value
              previous.output = star
              state.backtrack = true
              state.consumed += value
              continue
            }

            if (
              options_.noextglob !== true &&
              peek() === '(' &&
              peek(2) !== '?'
            ) {
              extglobOpen('star', value)
              continue
            }

            if (previous.type === 'star') {
              if (options_.noglobstar === true) {
                state.consumed += value
                continue
              }

              const prior = previous.prev
              const before = prior.prev
              const isStart = prior.type === 'slash' || prior.type === 'bos'
              const afterStar =
                before && (before.type === 'star' || before.type === 'globstar')

              if (
                options_.bash === true &&
                (!isStart || (!eos() && peek() !== '/'))
              ) {
                push({
                  type: 'star',
                  value,
                  output: '',
                })
                continue
              }

              const isBrace =
                state.braces > 0 &&
                (prior.type === 'comma' || prior.type === 'brace')
              const isExtglob =
                extglobs.length &&
                (prior.type === 'pipe' || prior.type === 'paren')

              if (
                !isStart &&
                prior.type !== 'paren' &&
                !isBrace &&
                !isExtglob
              ) {
                push({
                  type: 'star',
                  value,
                  output: '',
                })
                continue
              } // strip consecutive `/**/`

              while (input.slice(state.index + 1, state.index + 4) === '/**') {
                const after = input[state.index + 4]

                if (after && after !== '/') {
                  break
                }

                state.consumed += '/**'
                state.index += 3
              }

              if (prior.type === 'bos' && eos()) {
                previous.type = 'globstar'
                previous.value += value
                previous.output = globstar(options_)
                state.output = previous.output
                state.consumed += value
                continue
              }

              if (
                prior.type === 'slash' &&
                prior.prev.type !== 'bos' &&
                !afterStar &&
                eos()
              ) {
                state.output = state.output.slice(
                  0,
                  -(prior.output + previous.output).length
                )
                prior.output = `(?:${prior.output}`
                previous.type = 'globstar'
                previous.output = `${globstar(options_)}|$)`
                previous.value += value
                state.output += prior.output + previous.output
                state.consumed += value
                continue
              }

              const _next2 = peek()

              if (
                prior.type === 'slash' &&
                prior.prev.type !== 'bos' &&
                _next2 === '/'
              ) {
                const end = peek(2) !== void 0 ? '|$' : ''
                state.output = state.output.slice(
                  0,
                  -(prior.output + previous.output).length
                )
                prior.output = `(?:${prior.output}`
                previous.type = 'globstar'
                previous.output = `${globstar(
                  options_
                )}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`
                previous.value += value
                state.output += prior.output + previous.output
                state.consumed += value + advance()
                push({
                  type: 'slash',
                  value,
                  output: '',
                })
                continue
              }

              if (prior.type === 'bos' && _next2 === '/') {
                previous.type = 'globstar'
                previous.value += value
                previous.output = `(?:^|${SLASH_LITERAL}|${globstar(
                  options_
                )}${SLASH_LITERAL})`
                state.output = previous.output
                state.consumed += value + advance()
                push({
                  type: 'slash',
                  value,
                  output: '',
                })
                continue
              } // remove single star from output

              state.output = state.output.slice(0, -previous.output.length) // reset previous token to globstar

              previous.type = 'globstar'
              previous.output = globstar(options_)
              previous.value += value // reset output with globstar

              state.output += previous.output
              state.consumed += value
              continue
            }

            const token = {
              type: 'star',
              value,
              output: star,
            }

            if (options_.bash === true) {
              token.output = '.*?'

              if (previous.type === 'bos' || previous.type === 'slash') {
                token.output = nodot + token.output
              }

              push(token)
              continue
            }

            if (
              previous &&
              (previous.type === 'bracket' || previous.type === 'paren') &&
              options_.regex === true
            ) {
              token.output = value
              push(token)
              continue
            }

            if (
              state.index === state.start ||
              previous.type === 'slash' ||
              previous.type === 'dot'
            ) {
              if (previous.type === 'dot') {
                state.output += NO_DOT_SLASH
                previous.output += NO_DOT_SLASH
              } else if (options_.dot === true) {
                state.output += NO_DOTS_SLASH
                previous.output += NO_DOTS_SLASH
              } else {
                state.output += nodot
                previous.output += nodot
              }

              if (peek() !== '*') {
                state.output += ONE_CHAR
                previous.output += ONE_CHAR
              }
            }

            push(token)
          }

          while (state.brackets > 0) {
            if (options_.strictBrackets === true) {
              throw new SyntaxError(syntaxError('closing', ']'))
            }
            state.output = utils.escapeLast(state.output, '[')
            decrement('brackets')
          }

          while (state.parens > 0) {
            if (options_.strictBrackets === true) {
              throw new SyntaxError(syntaxError('closing', ')'))
            }
            state.output = utils.escapeLast(state.output, '(')
            decrement('parens')
          }

          while (state.braces > 0) {
            if (options_.strictBrackets === true) {
              throw new SyntaxError(syntaxError('closing', '}'))
            }
            state.output = utils.escapeLast(state.output, '{')
            decrement('braces')
          }

          if (
            options_.strictSlashes !== true &&
            (previous.type === 'star' || previous.type === 'bracket')
          ) {
            push({
              type: 'maybe_slash',
              value: '',
              output: `${SLASH_LITERAL}?`,
            })
          } // rebuild the output if we had to backtrack at any point

          if (state.backtrack === true) {
            state.output = ''
            let _iteratorNormalCompletion = true
            let _didIteratorError = false
            let _iteratorError

            try {
              for (
                var _iterator = state.tokens[Symbol.iterator](), _step;
                !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
                _iteratorNormalCompletion = true
              ) {
                const _token = _step.value
                state.output +=
                  _token.output != null ? _token.output : _token.value

                if (_token.suffix) {
                  state.output += _token.suffix
                }
              }
            } catch (error) {
              _didIteratorError = true
              _iteratorError = error
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return()
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError
                }
              }
            }
          }

          return state
        }
        /**
         * Fast paths for creating regular expressions for common glob patterns.
         * This can significantly speed up processing and has very little downside
         * impact when none of the fast paths match.
         */

        parse.fastpaths = function(input, options) {
          const options_ = _objectSpread({}, options)

          const max =
            typeof options_.maxLength === 'number'
              ? Math.min(MAX_LENGTH, options_.maxLength)
              : MAX_LENGTH
          const length_ = input.length

          if (length_ > max) {
            throw new SyntaxError(
              `Input length: ${length_}, exceeds maximum allowed length: ${max}`
            )
          }

          input = REPLACEMENTS[input] || input
          const win32 = utils.isWindows(options) // create constants based on platform, for windows or posix

          const _constants$globChars = constants.globChars(win32)
          const {DOT_LITERAL} = _constants$globChars
          const {SLASH_LITERAL} = _constants$globChars
          const {ONE_CHAR} = _constants$globChars
          const {DOTS_SLASH} = _constants$globChars
          const {NO_DOT} = _constants$globChars
          const {NO_DOTS} = _constants$globChars
          const {NO_DOTS_SLASH} = _constants$globChars
          const {STAR} = _constants$globChars
          const {START_ANCHOR} = _constants$globChars

          const capture = options_.capture ? '' : '?:'
          let star = options_.bash === true ? '.*?' : STAR
          const nodot = options_.dot ? NO_DOTS : NO_DOT
          const slashDot = options_.dot ? NO_DOTS_SLASH : NO_DOT

          if (options_.capture) {
            star = `(${star})`
          }

          const globstar = function globstar(options__) {
            return `(${capture}(?:(?!${START_ANCHOR}${
              options__.dot ? DOTS_SLASH : DOT_LITERAL
            }).)*?)`
          }

          const create = function create(string) {
            switch (string) {
              case '*':
                return `${nodot}${ONE_CHAR}${star}`

              case '.*':
                return `${DOT_LITERAL}${ONE_CHAR}${star}`

              case '*.*':
                return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`

              case '*/*':
                return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`

              case '**':
                return nodot + globstar(options_)

              case '**/*':
                return `(?:${nodot}${globstar(
                  options_
                )}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`

              case '**/*.*':
                return `(?:${nodot}${globstar(
                  options_
                )}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`

              case '**/.*':
                return `(?:${nodot}${globstar(
                  options_
                )}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`

              default: {
                const match = /^(.*?)\.(\w+)$/.exec(string)
                if (!match) {
                  return
                }
                const source = create(match[1], options)
                if (!source) {
                  return
                }
                return source + DOT_LITERAL + match[2]
              }
            }
          }

          let output = create(input)

          if (output && options_.strictSlashes !== true) {
            output += `${SLASH_LITERAL}?`
          }

          return output
        }

        module.exports = parse
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 194 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          11
        )
        /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          13
        )
        /* harmony import */ const core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          27
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5__
        )
        /* harmony import */ const core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          23
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          16
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
          3
        )

        function _toConsumableArray(array) {
          return (
            _arrayWithoutHoles(array) ||
            _iterableToArray(array) ||
            _nonIterableSpread()
          )
        }

        function _nonIterableSpread() {
          throw new TypeError('Invalid attempt to spread non-iterable instance')
        }

        function _iterableToArray(iter) {
          if (
            Symbol.iterator in new Object(iter) ||
            Object.prototype.toString.call(iter) === '[object Arguments]'
          ) {
            return Array.from(iter)
          }
        }

        function _arrayWithoutHoles(array) {
          if (Array.isArray(array)) {
            for (
              var i = 0, array2 = new Array(array.length);
              i < array.length;
              i++
            ) {
              array2[i] = array[i]
            }
            return array2
          }
        }

        Object.defineProperty(exports, '__esModule', {
          value: true,
        })

        const picomatch = __webpack_require__(146)

        const normalizePath = __webpack_require__(148)
        /**
         * @typedef {(testString: string) => boolean} AnymatchFn
         * @typedef {string|RegExp|AnymatchFn} AnymatchPattern
         * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher
         */

        const BANG = '!'
        const DEFAULT_OPTIONS = {
          returnIndex: false,
        }

        const arrify = function arrify(item) {
          return Array.isArray(item) ? item : [item]
        }
        /**
         * @param {AnymatchPattern} matcher
         * @param {object} options
         * @returns {AnymatchFn}
         */

        const createPattern = function createPattern(matcher, options) {
          if (typeof matcher === 'function') {
            return matcher
          }

          if (typeof matcher === 'string') {
            const glob = picomatch(matcher, options)
            return function(string) {
              return matcher === string || glob(string)
            }
          }

          if (matcher instanceof RegExp) {
            return function(string) {
              return matcher.test(string)
            }
          }

          return function(string) {
            return false
          }
        }
        /**
         * @param {Array<Function>} patterns
         * @param {Array<Function>} negPatterns
         * @param {String|Array} args
         * @param {Boolean} returnIndex
         * @returns {boolean|number}
         */

        const matchPatterns = function matchPatterns(
          patterns,
          negPatterns,
          arguments_,
          returnIndex
        ) {
          const isList = Array.isArray(arguments_)

          const _path = isList ? arguments_[0] : arguments_

          if (!isList && typeof _path !== 'string') {
            throw new TypeError(
              `anymatch: second argument must be a string: got ${Object.prototype.toString.call(
                _path
              )}`
            )
          }

          const path = normalizePath(_path)

          for (const nglob of negPatterns) {
            if (nglob(path)) {
              return returnIndex ? -1 : false
            }
          }

          const applied = isList && [path].concat(arguments_.slice(1))

          for (const [_index, pattern] of patterns.entries()) {
            if (
              isList
                ? pattern.apply(void 0, _toConsumableArray(applied))
                : pattern(path)
            ) {
              return returnIndex ? _index : true
            }
          }

          return returnIndex ? -1 : false
        }
        /**
         * @param {AnymatchMatcher} matchers
         * @param {Array|string} testString
         * @param {object} options
         * @returns {boolean|number|Function}
         */

        const anymatch = function anymatch(matchers, testString) {
          const options =
            arguments.length > 2 && arguments[2] !== undefined
              ? arguments[2]
              : DEFAULT_OPTIONS

          if (matchers == null) {
            throw new TypeError('anymatch: specify first argument')
          }

          const options_ =
            typeof options === 'boolean'
              ? {
                  returnIndex: options,
                }
              : options
          const returnIndex = options_.returnIndex || false // Early cache for matchers.

          const mtchers = arrify(matchers)
          const negatedGlobs = mtchers
            .filter(function(item) {
              return typeof item === 'string' && item.charAt(0) === BANG
            })
            .map(function(item) {
              return item.slice(1)
            })
            .map(function(item) {
              return picomatch(item, options_)
            })
          const patterns = mtchers.map(function(matcher) {
            return createPattern(matcher, options_)
          })

          if (testString == null) {
            return function(testString) {
              const ri =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : false
              const returnIndex = typeof ri === 'boolean' ? ri : false
              return matchPatterns(
                patterns,
                negatedGlobs,
                testString,
                returnIndex
              )
            }
          }

          return matchPatterns(patterns, negatedGlobs, testString, returnIndex)
        }

        anymatch.default = anymatch
        module.exports = anymatch
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 195 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          21
        )
        /* harmony import */ const core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          32
        )
        /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          14
        )

        const isGlob = __webpack_require__(103)

        const pathPosixDirname = __webpack_require__(15).posix.dirname

        const isWin32 = __webpack_require__(196).platform() === 'win32'
        const slash = '/'
        const backslash = /\\/g
        const enclosure = /[\{\[].*[\/]*.*[\}\]]$/
        const globby = /(^|[^\\])([\{\[]|\([^\)]+$)/
        const escaped = /\\([\*\?\|\[\]\(\)\{\}])/g
        /**
         * @param {string} str
         * @param {Object} opts
         * @param {boolean} [opts.flipBackslashes=true]
         */

        module.exports = function globParent(string, options_) {
          const options = {
            flipBackslashes: true,
            ...options_,
          } // flip windows path separators

          if (options.flipBackslashes && isWin32 && !string.includes(slash)) {
            string = string.replace(backslash, slash)
          } // special case for strings ending in enclosure containing path separator

          if (enclosure.test(string)) {
            string += slash
          } // preserves full path in case of trailing path separator

          string += 'a' // remove path parts that are globby

          do {
            string = pathPosixDirname(string)
          } while (isGlob(string) || globby.test(string)) // remove escape chars and return result

          return string.replace(escaped, '$1')
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 196 */
    /** */ function(module, exports) {
      module.exports = require('os')

      /** */
    },
    /* 197 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          11
        )
        /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          13
        )
        /* harmony import */ const core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          27
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          3
        )
        /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          37
        )
        /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_8___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_8__
        )

        function _toConsumableArray(array) {
          return (
            _arrayWithoutHoles(array) ||
            _iterableToArray(array) ||
            _nonIterableSpread()
          )
        }

        function _nonIterableSpread() {
          throw new TypeError('Invalid attempt to spread non-iterable instance')
        }

        function _iterableToArray(iter) {
          if (
            Symbol.iterator in new Object(iter) ||
            Object.prototype.toString.call(iter) === '[object Arguments]'
          ) {
            return Array.from(iter)
          }
        }

        function _arrayWithoutHoles(array) {
          if (Array.isArray(array)) {
            for (
              var i = 0, array2 = new Array(array.length);
              i < array.length;
              i++
            ) {
              array2[i] = array[i]
            }
            return array2
          }
        }

        const stringify = __webpack_require__(107)

        const compile = __webpack_require__(198)

        const expand = __webpack_require__(205)

        const parse = __webpack_require__(206)
        /**
         * Expand the given pattern or create a regex-compatible string.
         *
         * ```js
         * const braces = require('braces');
         * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
         * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
         * ```
         * @param {String} `str`
         * @param {Object} `options`
         * @return {String}
         * @api public
         */

        const braces = function braces(input) {
          const options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}
          let output = []

          if (Array.isArray(input)) {
            let _iteratorNormalCompletion = true
            let _didIteratorError = false
            let _iteratorError

            try {
              for (
                var _iterator = input[Symbol.iterator](), _step;
                !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
                _iteratorNormalCompletion = true
              ) {
                const pattern = _step.value
                const result = braces.create(pattern, options)

                if (Array.isArray(result)) {
                  var _output
                  ;(_output = output).push.apply(
                    _output,
                    _toConsumableArray(result)
                  )
                } else {
                  output.push(result)
                }
              }
            } catch (error) {
              _didIteratorError = true
              _iteratorError = error
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return()
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError
                }
              }
            }
          } else {
            output = [].concat(braces.create(input, options))
          }

          if (options && options.expand === true && options.nodupes === true) {
            output = _toConsumableArray(new Set(output))
          }

          return output
        }
        /**
         * Parse the given `str` with the given `options`.
         *
         * ```js
         * // braces.parse(pattern, [, options]);
         * const ast = braces.parse('a/{b,c}/d');
         * console.log(ast);
         * ```
         * @param {String} pattern Brace pattern to parse
         * @param {Object} options
         * @return {Object} Returns an AST
         * @api public
         */

        braces.parse = function(input) {
          const options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}
          return parse(input, options)
        }
        /**
         * Creates a braces string from an AST, or an AST node.
         *
         * ```js
         * const braces = require('braces');
         * let ast = braces.parse('foo/{a,b}/bar');
         * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
         * ```
         * @param {String} `input` Brace pattern or AST.
         * @param {Object} `options`
         * @return {Array} Returns an array of expanded values.
         * @api public
         */

        braces.stringify = function(input) {
          const options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

          if (typeof input === 'string') {
            return stringify(braces.parse(input, options), options)
          }

          return stringify(input, options)
        }
        /**
         * Compiles a brace pattern into a regex-compatible, optimized string.
         * This method is called by the main [braces](#braces) function by default.
         *
         * ```js
         * const braces = require('braces');
         * console.log(braces.compile('a/{b,c}/d'));
         * //=> ['a/(b|c)/d']
         * ```
         * @param {String} `input` Brace pattern or AST.
         * @param {Object} `options`
         * @return {Array} Returns an array of expanded values.
         * @api public
         */

        braces.compile = function(input) {
          const options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

          if (typeof input === 'string') {
            input = braces.parse(input, options)
          }

          return compile(input, options)
        }
        /**
         * Expands a brace pattern into an array. This method is called by the
         * main [braces](#braces) function when `options.expand` is true. Before
         * using this method it's recommended that you read the [performance notes](#performance))
         * and advantages of using [.compile](#compile) instead.
         *
         * ```js
         * const braces = require('braces');
         * console.log(braces.expand('a/{b,c}/d'));
         * //=> ['a/b/d', 'a/c/d'];
         * ```
         * @param {String} `pattern` Brace pattern
         * @param {Object} `options`
         * @return {Array} Returns an array of expanded values.
         * @api public
         */

        braces.expand = function(input) {
          const options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

          if (typeof input === 'string') {
            input = braces.parse(input, options)
          }

          let result = expand(input, options) // filter out empty strings if specified

          if (options.noempty === true) {
            result = result.filter(Boolean)
          } // filter out duplicates if specified

          if (options.nodupes === true) {
            result = _toConsumableArray(new Set(result))
          }

          return result
        }
        /**
         * Processes a brace pattern and returns either an expanded array
         * (if `options.expand` is true), a highly optimized regex-compatible string.
         * This method is called by the main [braces](#braces) function.
         *
         * ```js
         * const braces = require('braces');
         * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
         * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
         * ```
         * @param {String} `pattern` Brace pattern
         * @param {Object} `options`
         * @return {Array} Returns an array of expanded values.
         * @api public
         */

        braces.create = function(input) {
          const options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

          if (input === '' || input.length < 3) {
            return [input]
          }

          return options.expand !== true
            ? braces.compile(input, options)
            : braces.expand(input, options)
        }
        /**
         * Expose "braces"
         */

        module.exports = braces
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 198 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          11
        )
        /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          13
        )
        /* harmony import */ const core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          27
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5__
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          43
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          3
        )

        function ownKeys(object, enumerableOnly) {
          const keys = Object.keys(object)
          if (Object.getOwnPropertySymbols) {
            let symbols = Object.getOwnPropertySymbols(object)
            if (enumerableOnly) {
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable
              })
            }
            keys.push.apply(keys, symbols)
          }
          return keys
        }

        function _objectSpread(target) {
          for (let i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {}
            if (i % 2) {
              ownKeys(source, true).forEach(function(key) {
                _defineProperty(target, key, source[key])
              })
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(
                target,
                Object.getOwnPropertyDescriptors(source)
              )
            } else {
              ownKeys(source).forEach(function(key) {
                Object.defineProperty(
                  target,
                  key,
                  Object.getOwnPropertyDescriptor(source, key)
                )
              })
            }
          }
          return target
        }

        function _defineProperty(object, key, value) {
          if (key in object) {
            Object.defineProperty(object, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true,
            })
          } else {
            object[key] = value
          }
          return object
        }

        function _toConsumableArray(array) {
          return (
            _arrayWithoutHoles(array) ||
            _iterableToArray(array) ||
            _nonIterableSpread()
          )
        }

        function _nonIterableSpread() {
          throw new TypeError('Invalid attempt to spread non-iterable instance')
        }

        function _iterableToArray(iter) {
          if (
            Symbol.iterator in new Object(iter) ||
            Object.prototype.toString.call(iter) === '[object Arguments]'
          ) {
            return Array.from(iter)
          }
        }

        function _arrayWithoutHoles(array) {
          if (Array.isArray(array)) {
            for (
              var i = 0, array2 = new Array(array.length);
              i < array.length;
              i++
            ) {
              array2[i] = array[i]
            }
            return array2
          }
        }

        const fill = __webpack_require__(149)

        const utils = __webpack_require__(108)

        const compile = function compile(ast) {
          const options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

          const walk = function walk(node) {
            const parent =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : {}
            const invalidBlock = utils.isInvalidBrace(parent)
            const invalidNode =
              node.invalid === true && options.escapeInvalid === true
            const invalid = invalidBlock === true || invalidNode === true
            const prefix = options.escapeInvalid === true ? '\\' : ''
            let output = ''

            if (node.isOpen === true) {
              return prefix + node.value
            }

            if (node.isClose === true) {
              return prefix + node.value
            }

            if (node.type === 'open') {
              return invalid ? prefix + node.value : '('
            }

            if (node.type === 'close') {
              return invalid ? prefix + node.value : ')'
            }

            if (node.type === 'comma') {
              return node.prev.type === 'comma'
                ? ''
                : invalid
                ? node.value
                : '|'
            }

            if (node.value) {
              return node.value
            }

            if (node.nodes && node.ranges > 0) {
              const arguments_ = utils.reduce(node.nodes)
              const range = fill.apply(
                void 0,
                _toConsumableArray(arguments_).concat([
                  _objectSpread({}, options, {
                    wrap: false,
                    toRegex: true,
                  }),
                ])
              )

              if (range.length !== 0) {
                return arguments_.length > 1 && range.length > 1
                  ? `(${range})`
                  : range
              }
            }

            if (node.nodes) {
              let _iteratorNormalCompletion = true
              let _didIteratorError = false
              let _iteratorError

              try {
                for (
                  var _iterator = node.nodes[Symbol.iterator](), _step;
                  !(_iteratorNormalCompletion = (_step = _iterator.next())
                    .done);
                  _iteratorNormalCompletion = true
                ) {
                  const child = _step.value
                  output += walk(child, node)
                }
              } catch (error) {
                _didIteratorError = true
                _iteratorError = error
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return()
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError
                  }
                }
              }
            }

            return output
          }

          return walk(ast)
        }

        module.exports = compile
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 199 */
    /** */ function(module, exports, __webpack_require__) {
      const $ = __webpack_require__(6)

      const $padStart = __webpack_require__(200).start

      const WEBKIT_BUG = __webpack_require__(202) // `String.prototype.padStart` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.padstart

      $(
        {
          target: 'String',
          proto: true,
          forced: WEBKIT_BUG,
        },
        {
          padStart: function padStart(
            maxLength
            /* , fillString = ' ' */
          ) {
            return $padStart(
              this,
              maxLength,
              arguments.length > 1 ? arguments[1] : undefined
            )
          },
        }
      )

      /** */
    },
    /* 200 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          2
        )

        // https://github.com/tc39/proposal-string-pad-start-end
        const toLength = __webpack_require__(22)

        const repeat = __webpack_require__(201)

        const requireObjectCoercible = __webpack_require__(26)

        const {ceil} = Math // `String.prototype.{ padStart, padEnd }` methods implementation

        const createMethod = function createMethod(IS_END) {
          return function($this, maxLength, fillString) {
            const S = String(requireObjectCoercible($this))
            const stringLength = S.length
            const fillString_ =
              fillString === undefined ? ' ' : String(fillString)
            const intMaxLength = toLength(maxLength)
            let fillLength
            let stringFiller
            if (intMaxLength <= stringLength || fillString_ == '') {
              return S
            }
            fillLength = intMaxLength - stringLength
            stringFiller = repeat.call(
              fillString_,
              ceil(fillLength / fillString_.length)
            )
            if (stringFiller.length > fillLength) {
              stringFiller = stringFiller.slice(0, fillLength)
            }
            return IS_END ? S + stringFiller : stringFiller + S
          }
        }

        module.exports = {
          // `String.prototype.padStart` method
          // https://tc39.github.io/ecma262/#sec-string.prototype.padstart
          start: createMethod(false),
          // `String.prototype.padEnd` method
          // https://tc39.github.io/ecma262/#sec-string.prototype.padend
          end: createMethod(true),
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 201 */
    /** */ function(module, exports, __webpack_require__) {
      const toInteger = __webpack_require__(39)

      const requireObjectCoercible = __webpack_require__(26) // `String.prototype.repeat` method implementation
      // https://tc39.github.io/ecma262/#sec-string.prototype.repeat

      module.exports =
        ''.repeat ||
        function repeat(count) {
          let string = String(requireObjectCoercible(this))
          let result = ''
          let n = toInteger(count)
          if (n < 0 || n == Infinity) {
            throw new RangeError('Wrong number of repetitions')
          }

          for (; n > 0; (n >>>= 1) && (string += string)) {
            if (n & 1) {
              result += string
            }
          }

          return result
        }

      /** */
    },
    /* 202 */
    /** */ function(module, exports, __webpack_require__) {
      // https://github.com/zloirock/core-js/issues/280
      const userAgent = __webpack_require__(105) // eslint-disable-next-line unicorn/no-unsafe-regex

      module.exports = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(
        userAgent
      )

      /** */
    },
    /* 203 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          11
        )
        /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          13
        )
        /* harmony import */ const core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          27
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5__
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_array_sort__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          42
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          43
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_8___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_8__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
          3
        )
        /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
          37
        )
        /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_11___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_11__
        )
        /*!
         * to-regex-range <https://github.com/micromatch/to-regex-range>
         *
         * Copyright (c) 2015-present, Jon Schlinkert.
         * Released under the MIT License.
         */

        function _slicedToArray(array, i) {
          return (
            _arrayWithHoles(array) ||
            _iterableToArrayLimit(array, i) ||
            _nonIterableRest()
          )
        }

        function _nonIterableRest() {
          throw new TypeError(
            'Invalid attempt to destructure non-iterable instance'
          )
        }

        function _iterableToArrayLimit(array, i) {
          if (
            !(
              Symbol.iterator in new Object(array) ||
              Object.prototype.toString.call(array) === '[object Arguments]'
            )
          ) {
            return
          }
          const _array = []
          let _n = true
          let _d = false
          let _e
          try {
            for (
              var _i = array[Symbol.iterator](), _s;
              !(_n = (_s = _i.next()).done);
              _n = true
            ) {
              _array.push(_s.value)
              if (i && _array.length === i) {
                break
              }
            }
          } catch (error) {
            _d = true
            _e = error
          } finally {
            try {
              if (!_n && _i.return != null) {
                _i.return()
              }
            } finally {
              if (_d) {
                throw _e
              }
            }
          }
          return _array
        }

        function _arrayWithHoles(array) {
          if (Array.isArray(array)) {
            return array
          }
        }

        function _toConsumableArray(array) {
          return (
            _arrayWithoutHoles(array) ||
            _iterableToArray(array) ||
            _nonIterableSpread()
          )
        }

        function _nonIterableSpread() {
          throw new TypeError('Invalid attempt to spread non-iterable instance')
        }

        function _iterableToArray(iter) {
          if (
            Symbol.iterator in new Object(iter) ||
            Object.prototype.toString.call(iter) === '[object Arguments]'
          ) {
            return Array.from(iter)
          }
        }

        function _arrayWithoutHoles(array) {
          if (Array.isArray(array)) {
            for (
              var i = 0, array2 = new Array(array.length);
              i < array.length;
              i++
            ) {
              array2[i] = array[i]
            }
            return array2
          }
        }

        function ownKeys(object, enumerableOnly) {
          const keys = Object.keys(object)
          if (Object.getOwnPropertySymbols) {
            let symbols = Object.getOwnPropertySymbols(object)
            if (enumerableOnly) {
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable
              })
            }
            keys.push.apply(keys, symbols)
          }
          return keys
        }

        function _objectSpread(target) {
          for (let i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {}
            if (i % 2) {
              ownKeys(source, true).forEach(function(key) {
                _defineProperty(target, key, source[key])
              })
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(
                target,
                Object.getOwnPropertyDescriptors(source)
              )
            } else {
              ownKeys(source).forEach(function(key) {
                Object.defineProperty(
                  target,
                  key,
                  Object.getOwnPropertyDescriptor(source, key)
                )
              })
            }
          }
          return target
        }

        function _defineProperty(object, key, value) {
          if (key in object) {
            Object.defineProperty(object, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true,
            })
          } else {
            object[key] = value
          }
          return object
        }

        const isNumber = __webpack_require__(204)

        const toRegexRange = function toRegexRange(min, max, options) {
          if (isNumber(min) === false) {
            throw new TypeError(
              'toRegexRange: expected the first argument to be a number'
            )
          }

          if (max === void 0 || min === max) {
            return String(min)
          }

          if (isNumber(max) === false) {
            throw new TypeError(
              'toRegexRange: expected the second argument to be a number.'
            )
          }

          const options_ = _objectSpread(
            {
              relaxZeros: true,
            },
            options
          )

          if (typeof options_.strictZeros === 'boolean') {
            options_.relaxZeros = options_.strictZeros === false
          }

          const relax = String(options_.relaxZeros)
          const shorthand = String(options_.shorthand)
          const capture = String(options_.capture)
          const wrap = String(options_.wrap)
          const cacheKey = `${min}:${max}=${relax}${shorthand}${capture}${wrap}`

          if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
            return toRegexRange.cache[cacheKey].result
          }

          let a = Math.min(min, max)
          const b = Math.max(min, max)

          if (Math.abs(a - b) === 1) {
            const result = `${min}|${max}`

            if (options_.capture) {
              return `(${result})`
            }

            if (options_.wrap === false) {
              return result
            }

            return `(?:${result})`
          }

          const isPadded = hasPadding(min) || hasPadding(max)
          const state = {
            min,
            max,
            a,
            b,
          }
          let positives = []
          let negatives = []

          if (isPadded) {
            state.isPadded = isPadded
            state.maxLen = String(state.max).length
          }

          if (a < 0) {
            const newMin = b < 0 ? Math.abs(b) : 1
            negatives = splitToPatterns(newMin, Math.abs(a), state, options_)
            a = state.a = 0
          }

          if (b >= 0) {
            positives = splitToPatterns(a, b, state, options_)
          }

          state.negatives = negatives
          state.positives = positives
          state.result = collatePatterns(negatives, positives, options_)

          if (options_.capture === true) {
            state.result = `(${state.result})`
          } else if (
            options_.wrap !== false &&
            positives.length + negatives.length > 1
          ) {
            state.result = `(?:${state.result})`
          }

          toRegexRange.cache[cacheKey] = state
          return state.result
        }

        function collatePatterns(neg, pos, options) {
          const onlyNegative =
            filterPatterns(neg, pos, '-', false, options) || []
          const onlyPositive =
            filterPatterns(pos, neg, '', false, options) || []
          const intersected =
            filterPatterns(neg, pos, '-?', true, options) || []
          const subpatterns = onlyNegative
            .concat(intersected)
            .concat(onlyPositive)
          return subpatterns.join('|')
        }

        function splitToRanges(min, max) {
          let nines = 1
          let zeros = 1
          let stop = countNines(min, nines)
          let stops = new Set([max])

          while (min <= stop && stop <= max) {
            stops.add(stop)
            nines += 1
            stop = countNines(min, nines)
          }

          stop = countZeros(max + 1, zeros) - 1

          while (min < stop && stop <= max) {
            stops.add(stop)
            zeros += 1
            stop = countZeros(max + 1, zeros) - 1
          }

          stops = _toConsumableArray(stops)
          stops.sort(compare)
          return stops
        }
        /**
         * Convert a range to a regex pattern
         * @param {Number} `start`
         * @param {Number} `stop`
         * @return {String}
         */

        function rangeToPattern(start, stop, options) {
          if (start === stop) {
            return {
              pattern: start,
              count: [],
              digits: 0,
            }
          }

          const zipped = zip(start, stop)
          const digits = zipped.length
          let pattern = ''
          let count = 0

          for (let i = 0; i < digits; i++) {
            const _zipped$i = _slicedToArray(zipped[i], 2)
            const startDigit = _zipped$i[0]
            const stopDigit = _zipped$i[1]

            if (startDigit === stopDigit) {
              pattern += startDigit
            } else if (startDigit !== '0' || stopDigit !== '9') {
              pattern += toCharacterClass(startDigit, stopDigit, options)
            } else {
              count++
            }
          }

          if (count) {
            pattern += options.shorthand === true ? '\\d' : '[0-9]'
          }

          return {
            pattern,
            count: [count],
            digits,
          }
        }

        function splitToPatterns(min, max, tok, options) {
          const ranges = splitToRanges(min, max)
          const tokens = []
          let start = min
          let previous

          for (const _max of ranges) {
            const object = rangeToPattern(String(start), String(_max), options)
            let zeros = ''

            if (
              !tok.isPadded &&
              previous &&
              previous.pattern === object.pattern
            ) {
              if (previous.count.length > 1) {
                previous.count.pop()
              }

              previous.count.push(object.count[0])
              previous.string = previous.pattern + toQuantifier(previous.count)
              start = _max + 1
              continue
            }

            if (tok.isPadded) {
              zeros = padZeros(_max, tok, options)
            }

            object.string = zeros + object.pattern + toQuantifier(object.count)
            tokens.push(object)
            start = _max + 1
            previous = object
          }

          return tokens
        }

        function filterPatterns(
          array,
          comparison,
          prefix,
          intersection,
          options
        ) {
          const result = []
          let _iteratorNormalCompletion = true
          let _didIteratorError = false
          let _iteratorError

          try {
            for (
              var _iterator = array[Symbol.iterator](), _step;
              !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
              _iteratorNormalCompletion = true
            ) {
              const ele = _step.value
              const {string} = ele // only push if _both_ are negative...

              if (!intersection && !contains(comparison, 'string', string)) {
                result.push(prefix + string)
              } // or _both_ are positive

              if (intersection && contains(comparison, 'string', string)) {
                result.push(prefix + string)
              }
            }
          } catch (error) {
            _didIteratorError = true
            _iteratorError = error
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return()
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError
              }
            }
          }

          return result
        }
        /**
         * Zip strings
         */

        function zip(a, b) {
          const array = []

          for (const [i, element] of a.entries()) {
            array.push([element, b[i]])
          }

          return array
        }

        function compare(a, b) {
          return a > b ? 1 : b > a ? -1 : 0
        }

        function contains(array, key, value) {
          return array.some(function(ele) {
            return ele[key] === value
          })
        }

        function countNines(min, length_) {
          return Number(String(min).slice(0, -length_) + '9'.repeat(length_))
        }

        function countZeros(integer, zeros) {
          return integer - (integer % 10 ** zeros)
        }

        function toQuantifier(digits) {
          const _digits = _slicedToArray(digits, 2)
          const _digits$ = _digits[0]
          const start = _digits$ === void 0 ? 0 : _digits$
          const _digits$2 = _digits[1]
          const stop = _digits$2 === void 0 ? '' : _digits$2

          if (stop || start > 1) {
            return `{${start + (stop ? `,${stop}` : '')}}`
          }

          return ''
        }

        function toCharacterClass(a, b, options) {
          return `[${a}${b - a === 1 ? '' : '-'}${b}]`
        }

        function hasPadding(string) {
          return /^-?(0+)\d/.test(string)
        }

        function padZeros(value, tok, options) {
          if (!tok.isPadded) {
            return value
          }

          const diff = Math.abs(tok.maxLen - String(value).length)
          const relax = options.relaxZeros !== false

          switch (diff) {
            case 0:
              return ''

            case 1:
              return relax ? '0?' : '0'

            case 2:
              return relax ? '0{0,2}' : '00'

            default: {
              return relax ? `0{0,${diff}}` : `0{${diff}}`
            }
          }
        }
        /**
         * Cache
         */

        toRegexRange.cache = {}

        toRegexRange.clearCache = function() {
          return (toRegexRange.cache = {})
        }
        /**
         * Expose `toRegexRange`
         */

        module.exports = toRegexRange
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 204 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_string_trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          46
        )
        /*!
         * is-number <https://github.com/jonschlinkert/is-number>
         *
         * Copyright (c) 2014-present, Jon Schlinkert.
         * Released under the MIT License.
         */

        module.exports = function(number) {
          if (typeof number === 'number') {
            return number - number === 0
          }

          if (typeof number === 'string' && number.trim() !== '') {
            return Number.isFinite
              ? Number.isFinite(Number(number))
              : isFinite(Number(number))
          }

          return false
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 205 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          11
        )
        /* harmony import */ const core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          27
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4__
        )
        /* harmony import */ const core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          23
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          3
        )

        function _toConsumableArray(array) {
          return (
            _arrayWithoutHoles(array) ||
            _iterableToArray(array) ||
            _nonIterableSpread()
          )
        }

        function _nonIterableSpread() {
          throw new TypeError('Invalid attempt to spread non-iterable instance')
        }

        function _iterableToArray(iter) {
          if (
            Symbol.iterator in new Object(iter) ||
            Object.prototype.toString.call(iter) === '[object Arguments]'
          ) {
            return Array.from(iter)
          }
        }

        function _arrayWithoutHoles(array) {
          if (Array.isArray(array)) {
            for (
              var i = 0, array2 = new Array(array.length);
              i < array.length;
              i++
            ) {
              array2[i] = array[i]
            }
            return array2
          }
        }

        const fill = __webpack_require__(149)

        const stringify = __webpack_require__(107)

        const utils = __webpack_require__(108)

        const append = function append() {
          let queue =
            arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : ''
          let stash =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : ''
          const enclose =
            arguments.length > 2 && arguments[2] !== undefined
              ? arguments[2]
              : false
          const result = []
          queue = [].concat(queue)
          stash = [].concat(stash)
          if (!stash.length) {
            return queue
          }

          if (!queue.length) {
            return enclose
              ? utils.flatten(stash).map(function(ele) {
                  return `{${ele}}`
                })
              : stash
          }

          let _iteratorNormalCompletion = true
          let _didIteratorError = false
          let _iteratorError

          try {
            for (
              var _iterator = queue[Symbol.iterator](), _step;
              !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
              _iteratorNormalCompletion = true
            ) {
              const item = _step.value

              if (Array.isArray(item)) {
                let _iteratorNormalCompletion2 = true
                let _didIteratorError2 = false
                let _iteratorError2

                try {
                  for (
                    var _iterator2 = item[Symbol.iterator](), _step2;
                    !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next())
                      .done);
                    _iteratorNormalCompletion2 = true
                  ) {
                    const {value} = _step2
                    result.push(append(value, stash, enclose))
                  }
                } catch (error) {
                  _didIteratorError2 = true
                  _iteratorError2 = error
                } finally {
                  try {
                    if (
                      !_iteratorNormalCompletion2 &&
                      _iterator2.return != null
                    ) {
                      _iterator2.return()
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2
                    }
                  }
                }
              } else {
                let _iteratorNormalCompletion3 = true
                let _didIteratorError3 = false
                let _iteratorError3

                try {
                  for (
                    var _iterator3 = stash[Symbol.iterator](), _step3;
                    !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next())
                      .done);
                    _iteratorNormalCompletion3 = true
                  ) {
                    let ele = _step3.value
                    if (enclose === true && typeof ele === 'string') {
                      ele = `{${ele}}`
                    }
                    result.push(
                      Array.isArray(ele)
                        ? append(item, ele, enclose)
                        : item + ele
                    )
                  }
                } catch (error) {
                  _didIteratorError3 = true
                  _iteratorError3 = error
                } finally {
                  try {
                    if (
                      !_iteratorNormalCompletion3 &&
                      _iterator3.return != null
                    ) {
                      _iterator3.return()
                    }
                  } finally {
                    if (_didIteratorError3) {
                      throw _iteratorError3
                    }
                  }
                }
              }
            }
          } catch (error) {
            _didIteratorError = true
            _iteratorError = error
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return()
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError
              }
            }
          }

          return utils.flatten(result)
        }

        const expand = function expand(ast) {
          const options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}
          const rangeLimit =
            options.rangeLimit === void 0 ? 1000 : options.rangeLimit

          const walk = function walk(node) {
            const parent =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : {}
            node.queue = []
            let p = parent
            let q = parent.queue

            while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
              p = p.parent
              q = p.queue
            }

            if (node.invalid || node.dollar) {
              q.push(append(q.pop(), stringify(node, options)))
              return
            }

            if (
              node.type === 'brace' &&
              node.invalid !== true &&
              node.nodes.length === 2
            ) {
              q.push(append(q.pop(), ['{}']))
              return
            }

            if (node.nodes && node.ranges > 0) {
              const arguments_ = utils.reduce(node.nodes)

              if (
                utils.exceedsLimit.apply(
                  utils,
                  _toConsumableArray(arguments_).concat([
                    options.step,
                    rangeLimit,
                  ])
                )
              ) {
                throw new RangeError(
                  'expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.'
                )
              }

              let range = fill.apply(
                void 0,
                _toConsumableArray(arguments_).concat([options])
              )

              if (range.length === 0) {
                range = stringify(node, options)
              }

              q.push(append(q.pop(), range))
              node.nodes = []
              return
            }

            const enclose = utils.encloseBrace(node)
            let {queue} = node
            let block = node

            while (
              block.type !== 'brace' &&
              block.type !== 'root' &&
              block.parent
            ) {
              block = block.parent
              queue = block.queue
            }

            for (let i = 0; i < node.nodes.length; i++) {
              const child = node.nodes[i]

              if (child.type === 'comma' && node.type === 'brace') {
                if (i === 1) {
                  queue.push('')
                }
                queue.push('')
                continue
              }

              if (child.type === 'close') {
                q.push(append(q.pop(), queue, enclose))
                continue
              }

              if (child.value && child.type !== 'open') {
                queue.push(append(queue.pop(), child.value))
                continue
              }

              if (child.nodes) {
                walk(child, node)
              }
            }

            return queue
          }

          return utils.flatten(walk(ast))
        }

        module.exports = expand
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 206 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          11
        )
        /* harmony import */ const core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          27
        )
        /* harmony import */ const core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          21
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_5__
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_array_splice__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          94
        )
        /* harmony import */ const core_js_modules_es_array_splice__WEBPACK_IMPORTED_MODULE_7___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_splice__WEBPACK_IMPORTED_MODULE_7__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          3
        )

        function _toConsumableArray(array) {
          return (
            _arrayWithoutHoles(array) ||
            _iterableToArray(array) ||
            _nonIterableSpread()
          )
        }

        function _nonIterableSpread() {
          throw new TypeError('Invalid attempt to spread non-iterable instance')
        }

        function _iterableToArray(iter) {
          if (
            Symbol.iterator in new Object(iter) ||
            Object.prototype.toString.call(iter) === '[object Arguments]'
          ) {
            return Array.from(iter)
          }
        }

        function _arrayWithoutHoles(array) {
          if (Array.isArray(array)) {
            for (
              var i = 0, array2 = new Array(array.length);
              i < array.length;
              i++
            ) {
              array2[i] = array[i]
            }
            return array2
          }
        }

        const stringify = __webpack_require__(107)
        /**
         * Constants
         */

        const _require = __webpack_require__(207)
        const {MAX_LENGTH} = _require
        const {CHAR_BACKSLASH} = _require
        const {CHAR_BACKTICK} = _require
        const {CHAR_COMMA} = _require
        const {CHAR_DOT} = _require
        const {CHAR_LEFT_PARENTHESES} = _require
        const {CHAR_RIGHT_PARENTHESES} = _require
        const {CHAR_LEFT_CURLY_BRACE} = _require
        const {CHAR_RIGHT_CURLY_BRACE} = _require
        const {CHAR_LEFT_SQUARE_BRACKET} = _require
        const {CHAR_RIGHT_SQUARE_BRACKET} = _require
        const {CHAR_DOUBLE_QUOTE} = _require
        const {CHAR_SINGLE_QUOTE} = _require
        const {CHAR_NO_BREAK_SPACE} = _require
        const {CHAR_ZERO_WIDTH_NOBREAK_SPACE} = _require
        /**
         * parse
         */

        const parse = function parse(input) {
          const options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

          if (typeof input !== 'string') {
            throw new TypeError('Expected a string')
          }

          const options_ = options || {}
          const max =
            typeof options_.maxLength === 'number'
              ? Math.min(MAX_LENGTH, options_.maxLength)
              : MAX_LENGTH

          if (input.length > max) {
            throw new SyntaxError(
              `Input length (${input.length}), exceeds max characters (${max})`
            )
          }

          const ast = {
            type: 'root',
            input,
            nodes: [],
          }
          const stack = [ast]
          let block = ast
          let previous = ast
          let brackets = 0
          const {length} = input
          let index = 0
          let depth = 0
          let value
          const memo = {}
          /**
           * Helpers
           */

          const advance = function advance() {
            return input[index++]
          }

          const push = function push(node) {
            if (node.type === 'text' && previous.type === 'dot') {
              previous.type = 'text'
            }

            if (previous && previous.type === 'text' && node.type === 'text') {
              previous.value += node.value
              return
            }

            block.nodes.push(node)
            node.parent = block
            node.prev = previous
            previous = node
            return node
          }

          push({
            type: 'bos',
          })

          while (index < length) {
            block = stack[stack.length - 1]
            value = advance()
            /**
             * Invalid chars
             */

            if (
              value === CHAR_ZERO_WIDTH_NOBREAK_SPACE ||
              value === CHAR_NO_BREAK_SPACE
            ) {
              continue
            }
            /**
             * Escaped chars
             */

            if (value === CHAR_BACKSLASH) {
              push({
                type: 'text',
                value: (options.keepEscaping ? value : '') + advance(),
              })
              continue
            }
            /**
             * Right square bracket (literal): ']'
             */

            if (value === CHAR_RIGHT_SQUARE_BRACKET) {
              push({
                type: 'text',
                value: `\\${value}`,
              })
              continue
            }
            /**
             * Left square bracket: '['
             */

            if (value === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++
              const closed = true
              let next = void 0

              while (index < length && (next = advance())) {
                value += next

                if (next === CHAR_LEFT_SQUARE_BRACKET) {
                  brackets++
                  continue
                }

                if (next === CHAR_BACKSLASH) {
                  value += advance()
                  continue
                }

                if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                  brackets--

                  if (brackets === 0) {
                    break
                  }
                }
              }

              push({
                type: 'text',
                value,
              })
              continue
            }
            /**
             * Parentheses
             */

            if (value === CHAR_LEFT_PARENTHESES) {
              block = push({
                type: 'paren',
                nodes: [],
              })
              stack.push(block)
              push({
                type: 'text',
                value,
              })
              continue
            }

            if (value === CHAR_RIGHT_PARENTHESES) {
              if (block.type !== 'paren') {
                push({
                  type: 'text',
                  value,
                })
                continue
              }

              block = stack.pop()
              push({
                type: 'text',
                value,
              })
              block = stack[stack.length - 1]
              continue
            }
            /**
             * Quotes: '|"|`
             */

            if (
              value === CHAR_DOUBLE_QUOTE ||
              value === CHAR_SINGLE_QUOTE ||
              value === CHAR_BACKTICK
            ) {
              const open = value

              let _next = void 0

              if (options.keepQuotes !== true) {
                value = ''
              }

              while (index < length && (_next = advance())) {
                if (_next === CHAR_BACKSLASH) {
                  value += _next + advance()
                  continue
                }

                if (_next === open) {
                  if (options.keepQuotes === true) {
                    value += _next
                  }
                  break
                }

                value += _next
              }

              push({
                type: 'text',
                value,
              })
              continue
            }
            /**
             * Left curly brace: '{'
             */

            if (value === CHAR_LEFT_CURLY_BRACE) {
              depth++
              const dollar =
                (previous.value && previous.value.slice(-1) === '$') ||
                block.dollar === true
              const brace = {
                type: 'brace',
                open: true,
                close: false,
                dollar,
                depth,
                commas: 0,
                ranges: 0,
                nodes: [],
              }
              block = push(brace)
              stack.push(block)
              push({
                type: 'open',
                value,
              })
              continue
            }
            /**
             * Right curly brace: '}'
             */

            if (value === CHAR_RIGHT_CURLY_BRACE) {
              if (block.type !== 'brace') {
                push({
                  type: 'text',
                  value,
                })
                continue
              }

              const type = 'close'
              block = stack.pop()
              block.close = true
              push({
                type,
                value,
              })
              depth--
              block = stack[stack.length - 1]
              continue
            }
            /**
             * Comma: ','
             */

            if (value === CHAR_COMMA && depth > 0) {
              if (block.ranges > 0) {
                block.ranges = 0

                const _open = block.nodes.shift()

                block.nodes = [
                  _open,
                  {
                    type: 'text',
                    value: stringify(block),
                  },
                ]
              }

              push({
                type: 'comma',
                value,
              })
              block.commas++
              continue
            }
            /**
             * Dot: '.'
             */

            if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
              const siblings = block.nodes

              if (depth === 0 || siblings.length === 0) {
                push({
                  type: 'text',
                  value,
                })
                continue
              }

              if (previous.type === 'dot') {
                block.range = []
                previous.value += value
                previous.type = 'range'

                if (block.nodes.length !== 3 && block.nodes.length !== 5) {
                  block.invalid = true
                  block.ranges = 0
                  previous.type = 'text'
                  continue
                }

                block.ranges++
                block.args = []
                continue
              }

              if (previous.type === 'range') {
                siblings.pop()
                const before = siblings[siblings.length - 1]
                before.value += previous.value + value
                previous = before
                block.ranges--
                continue
              }

              push({
                type: 'dot',
                value,
              })
              continue
            }
            /**
             * Text
             */

            push({
              type: 'text',
              value,
            })
          } // Mark imbalanced braces and brackets as invalid

          do {
            block = stack.pop()

            if (block.type !== 'root') {
              var _parent$nodes

              block.nodes.forEach(function(node) {
                if (!node.nodes) {
                  if (node.type === 'open') {
                    node.isOpen = true
                  }
                  if (node.type === 'close') {
                    node.isClose = true
                  }
                  if (!node.nodes) {
                    node.type = 'text'
                  }
                  node.invalid = true
                }
              }) // get the location of the block on parent.nodes (block's siblings)

              const parent = stack[stack.length - 1]

              const _index = parent.nodes.indexOf(block) // replace the (invalid) block with it's nodes

              ;(_parent$nodes = parent.nodes).splice.apply(
                _parent$nodes,
                [_index, 1].concat(_toConsumableArray(block.nodes))
              )
            }
          } while (stack.length > 0)

          push({
            type: 'eos',
          })
          return ast
        }

        module.exports = parse
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 207 */
    /** */ function(module, exports, __webpack_require__) {
      module.exports = {
        MAX_LENGTH: 1024 * 64,
        // Digits
        CHAR_0: '0',

        /* 0 */
        CHAR_9: '9',

        /* 9 */
        // Alphabet chars.
        CHAR_UPPERCASE_A: 'A',

        /* A */
        CHAR_LOWERCASE_A: 'a',

        /* a */
        CHAR_UPPERCASE_Z: 'Z',

        /* Z */
        CHAR_LOWERCASE_Z: 'z',

        /* z */
        CHAR_LEFT_PARENTHESES: '(',

        /* ( */
        CHAR_RIGHT_PARENTHESES: ')',

        /* ) */
        CHAR_ASTERISK: '*',

        /* * */
        // Non-alphabetic chars.
        CHAR_AMPERSAND: '&',

        /* & */
        CHAR_AT: '@',

        /* @ */
        CHAR_BACKSLASH: '\\',

        /* \ */
        CHAR_BACKTICK: '`',

        /* ` */
        CHAR_CARRIAGE_RETURN: '\r',

        /* \r */
        CHAR_CIRCUMFLEX_ACCENT: '^',

        /* ^ */
        CHAR_COLON: ':',

        /* : */
        CHAR_COMMA: ',',

        /* , */
        CHAR_DOLLAR: '$',

        /* . */
        CHAR_DOT: '.',

        /* . */
        CHAR_DOUBLE_QUOTE: '"',

        /* " */
        CHAR_EQUAL: '=',

        /* = */
        CHAR_EXCLAMATION_MARK: '!',

        /* ! */
        CHAR_FORM_FEED: '\f',

        /* \f */
        CHAR_FORWARD_SLASH: '/',

        /* / */
        CHAR_HASH: '#',

        /* # */
        CHAR_HYPHEN_MINUS: '-',

        /* - */
        CHAR_LEFT_ANGLE_BRACKET: '<',

        /* < */
        CHAR_LEFT_CURLY_BRACE: '{',

        /* { */
        CHAR_LEFT_SQUARE_BRACKET: '[',

        /* [ */
        CHAR_LINE_FEED: '\n',

        /* \n */
        CHAR_NO_BREAK_SPACE: '\u00A0',

        /* \u00A0 */
        CHAR_PERCENT: '%',

        /* % */
        CHAR_PLUS: '+',

        /* + */
        CHAR_QUESTION_MARK: '?',

        /* ? */
        CHAR_RIGHT_ANGLE_BRACKET: '>',

        /* > */
        CHAR_RIGHT_CURLY_BRACE: '}',

        /* } */
        CHAR_RIGHT_SQUARE_BRACKET: ']',

        /* ] */
        CHAR_SEMICOLON: ';',

        /* ; */
        CHAR_SINGLE_QUOTE: "'",

        /* ' */
        CHAR_SPACE: ' ',

        /*   */
        CHAR_TAB: '\t',

        /* \t */
        CHAR_UNDERSCORE: '_',

        /* _ */
        CHAR_VERTICAL_LINE: '|',

        /* | */
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF',
        /* \uFEFF */
      }

      /** */
    },
    /* 208 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          13
        )
        /* harmony import */ const core_js_modules_es_array_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          34
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_2___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_2__
        )
        /* harmony import */ const core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          74
        )
        /* harmony import */ const core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_3___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_3__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          44
        )
        /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          37
        )
        /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_6___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_6__
        )
        /* harmony import */ const core_js_modules_es_string_includes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          41
        )
        /* harmony import */ const regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          75
        )

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function')
          }
        }

        function _defineProperties(target, properties) {
          for (const descriptor of properties) {
            descriptor.enumerable = descriptor.enumerable || false
            descriptor.configurable = true
            if ('value' in descriptor) {
              descriptor.writable = true
            }
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }

        function _createClass(Constructor, protoProperties, staticProperties) {
          if (protoProperties) {
            _defineProperties(Constructor.prototype, protoProperties)
          }
          if (staticProperties) {
            _defineProperties(Constructor, staticProperties)
          }
          return Constructor
        }

        function asyncGeneratorStep(
          gen,
          resolve,
          reject,
          _next,
          _throw,
          key,
          argument
        ) {
          try {
            var info = gen[key](argument)
            var {value} = info
          } catch (error) {
            reject(error)
            return
          }
          if (info.done) {
            resolve(value)
          } else {
            Promise.resolve(value).then(_next, _throw)
          }
        }

        function _asyncToGenerator(fn) {
          return function() {
            const self = this
            const arguments_ = arguments
            return new Promise(function(resolve, reject) {
              const gen = fn.apply(self, arguments_)
              function _next(value) {
                asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  'next',
                  value
                )
              }
              function _throw(error) {
                asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  'throw',
                  error
                )
              }
              _next(undefined)
            })
          }
        }

        const fs = __webpack_require__(35)

        const sysPath = __webpack_require__(15)

        const isBinaryPath = __webpack_require__(209)

        const _require = __webpack_require__(36)
        const {promisify} = _require

        const _require2 = __webpack_require__(109)
        const {isWindows} = _require2
        const {EMPTY_FN} = _require2
        const {EMPTY_STR} = _require2
        const {KEY_LISTENERS} = _require2
        const {KEY_ERR} = _require2
        const {KEY_RAW} = _require2
        const {HANDLER_KEYS} = _require2
        const {EV_CHANGE} = _require2
        const {EV_ADD} = _require2
        const {EV_ADD_DIR} = _require2
        const {EV_ERROR} = _require2
        const {STR_DATA} = _require2
        const {STR_END} = _require2

        const THROTTLE_MODE_WATCH = 'watch'
        const open = promisify(fs.open)
        const stat = promisify(fs.stat)
        const lstat = promisify(fs.lstat)
        const close = promisify(fs.close)
        const fsrealpath = promisify(fs.realpath)
        const statMethods = {
          lstat,
          stat,
        } // TODO: emit errors properly. Example: EMFILE on Macos.

        const foreach = function foreach(value, fn) {
          if (value instanceof Set) {
            value.forEach(fn)
          } else {
            fn(value)
          }
        }

        const addAndConvert = function addAndConvert(main, property, item) {
          let container = main[property]

          if (!(container instanceof Set)) {
            main[property] = container = new Set([container])
          }

          container.add(item)
        }

        const clearItem = function clearItem(cont) {
          return function(key) {
            const set = cont[key]

            if (set instanceof Set) {
              set.clear()
            } else {
              delete cont[key]
            }
          }
        }

        const delFromSet = function delFromSet(main, property, item) {
          const container = main[property]

          if (!(container instanceof Set)) {
            if (container === item) {
              delete main[property]
            }
          } else {
            container.delete(item)
          }
        }

        const isEmptySet = function isEmptySet(value) {
          return value instanceof Set ? value.size === 0 : !value
        }
        /**
         * @typedef {String} Path
         */
        // fs_watch helpers
        // object to hold per-process fs_watch instances
        // (may be shared across chokidar FSWatcher instances)

        /**
         * @typedef {Object} FsWatchContainer
         * @property {Set} listeners
         * @property {Set} errHandlers
         * @property {Set} rawEmitters
         * @property {fs.FSWatcher=} watcher
         * @property {Boolean=} watcherUnusable
         */

        /**
         * @type {Map<String,FsWatchContainer>}
         */

        const FsWatchInstances = new Map()
        /**
         * Instantiates the fs_watch interface
         * @param {String} path to be watched
         * @param {Object} options to be passed to fs_watch
         * @param {Function} listener main event handler
         * @param {Function} errHandler emits info about errors
         * @param {Function} emitRaw emits raw event data
         * @returns {fs.FSWatcher} new fsevents instance
         */

        function createFsWatchInstance(
          path,
          options,
          listener,
          errorHandler,
          emitRaw
        ) {
          const handleEvent = function handleEvent(rawEvent, evPath) {
            listener(path)
            emitRaw(rawEvent, evPath, {
              watchedPath: path,
            }) // emit based on events occurring for files from a directory's watcher in
            // case the file's watcher misses it (and rely on throttling to de-dupe)

            if (evPath && path !== evPath) {
              fsWatchBroadcast(
                sysPath.resolve(path, evPath),
                KEY_LISTENERS,
                sysPath.join(path, evPath)
              )
            }
          }

          try {
            return fs.watch(path, options, handleEvent)
          } catch (error) {
            errorHandler(error)
          }
        }
        /**
         * Helper for passing fs_watch event data to a collection of listeners
         * @param {Path} fullPath absolute path bound to fs_watch instance
         * @param {String} type listener type
         * @param {*=} val1 arguments to be passed to listeners
         * @param {*=} val2
         * @param {*=} val3
         */

        var fsWatchBroadcast = function fsWatchBroadcast(
          fullPath,
          type,
          value1,
          value2,
          value3
        ) {
          const cont = FsWatchInstances.get(fullPath)
          if (!cont) {
            return
          }
          foreach(cont[type], function(listener) {
            listener(value1, value2, value3)
          })
        }
        /**
         * Instantiates the fs_watch interface or binds listeners
         * to an existing one covering the same file system entry
         * @param {String} path
         * @param {String} fullPath absolute path
         * @param {Object} options to be passed to fs_watch
         * @param {Object} handlers container for event listener functions
         */

        const setFsWatchListener = function setFsWatchListener(
          path,
          fullPath,
          options,
          handlers
        ) {
          const {listener} = handlers
          const {errorHandler} = handlers
          const {rawEmitter} = handlers
          let cont = FsWatchInstances.get(fullPath)
          /** @type {fs.FSWatcher=} */

          let watcher

          if (!options.persistent) {
            watcher = createFsWatchInstance(
              path,
              options,
              listener,
              errorHandler,
              rawEmitter
            )
            return watcher.close.bind(watcher)
          }

          if (cont) {
            addAndConvert(cont, KEY_LISTENERS, listener)
            addAndConvert(cont, KEY_ERR, errorHandler)
            addAndConvert(cont, KEY_RAW, rawEmitter)
          } else {
            watcher = createFsWatchInstance(
              path,
              options,
              fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
              errorHandler, // no need to use broadcast here
              fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
            )
            if (!watcher) {
              return
            }
            watcher.on(
              EV_ERROR,
              /* #__PURE__ */
              (function() {
                const _reference = _asyncToGenerator(
                  /* #__PURE__ */
                  regeneratorRuntime.mark(function _callee(error) {
                    let broadcastError
                    let fd
                    return regeneratorRuntime.wrap(
                      function _callee$(_context) {
                        while (1) {
                          switch ((_context.prev = _context.next)) {
                            case 0:
                              broadcastError = fsWatchBroadcast.bind(
                                null,
                                fullPath,
                                KEY_ERR
                              )
                              cont.watcherUnusable = true // documented since Node 10.4.1
                              // Workaround for https://github.com/joyent/node/issues/4337

                              if (!(isWindows && error.code === 'EPERM')) {
                                _context.next = 16
                                break
                              }

                              _context.prev = 3
                              _context.next = 6
                              return open(path, 'r')

                            case 6:
                              fd = _context.sent
                              _context.next = 9
                              return close(fd)

                            case 9:
                              broadcastError(error)
                              _context.next = 14
                              break

                            case 12:
                              _context.prev = 12
                              _context.t0 = _context.catch(3)

                            case 14:
                              _context.next = 17
                              break

                            case 16:
                              broadcastError(error)

                            case 17:
                            case 'end':
                              return _context.stop()
                          }
                        }
                      },
                      _callee,
                      null,
                      [[3, 12]]
                    )
                  })
                )

                return function(_x) {
                  return Reflect.apply(_reference, this, arguments)
                }
              })()
            )
            cont = {
              listeners: listener,
              errHandlers: errorHandler,
              rawEmitters: rawEmitter,
              watcher,
            }
            FsWatchInstances.set(fullPath, cont)
          } // const index = cont.listeners.indexOf(listener);
          // removes this instance's listeners and closes the underlying fs_watch
          // instance if there are no more listeners left

          return function() {
            delFromSet(cont, KEY_LISTENERS, listener)
            delFromSet(cont, KEY_ERR, errorHandler)
            delFromSet(cont, KEY_RAW, rawEmitter)

            if (isEmptySet(cont.listeners)) {
              // Check to protect against issue gh-730.
              // if (cont.watcherUnusable) {
              cont.watcher.close() // }

              FsWatchInstances.delete(fullPath)
              HANDLER_KEYS.forEach(clearItem(cont))
              cont.watcher = undefined
              Object.freeze(cont)
            }
          }
        } // fs_watchFile helpers
        // object to hold per-process fs_watchFile instances
        // (may be shared across chokidar FSWatcher instances)

        const FsWatchFileInstances = new Map()
        /**
         * Instantiates the fs_watchFile interface or binds listeners
         * to an existing one covering the same file system entry
         * @param {String} path to be watched
         * @param {String} fullPath absolute path
         * @param {Object} options options to be passed to fs_watchFile
         * @param {Object} handlers container for event listener functions
         * @returns {Function} closer
         */

        const setFsWatchFileListener = function setFsWatchFileListener(
          path,
          fullPath,
          options,
          handlers
        ) {
          const {listener} = handlers
          const {rawEmitter} = handlers
          let cont = FsWatchFileInstances.get(fullPath)
          let listeners = new Set()
          let rawEmitters = new Set()
          const copts = cont && cont.options

          if (
            copts &&
            (copts.persistent < options.persistent ||
              copts.interval > options.interval)
          ) {
            // "Upgrade" the watcher to persistence or a quicker interval.
            // This creates some unlikely edge case issues if the user mixes
            // settings in a very weird way, but solving for those cases
            // doesn't seem worthwhile for the added complexity.
            listeners = cont.listeners
            rawEmitters = cont.rawEmitters
            fs.unwatchFile(fullPath)
            cont = undefined
          }

          if (cont) {
            addAndConvert(cont, KEY_LISTENERS, listener)
            addAndConvert(cont, KEY_RAW, rawEmitter)
          } else {
            // TODO
            // listeners.add(listener);
            // rawEmitters.add(rawEmitter);
            cont = {
              listeners: listener,
              rawEmitters: rawEmitter,
              options,
              watcher: fs.watchFile(fullPath, options, function(
                current,
                previous
              ) {
                foreach(cont.rawEmitters, function(rawEmitter) {
                  rawEmitter(EV_CHANGE, fullPath, {
                    current,
                    previous,
                  })
                })
                const currmtime = current.mtimeMs

                if (
                  current.size !== previous.size ||
                  currmtime > previous.mtimeMs ||
                  currmtime === 0
                ) {
                  foreach(cont.listeners, function(listener) {
                    return listener(path, current)
                  })
                }
              }),
            }
            FsWatchFileInstances.set(fullPath, cont)
          } // const index = cont.listeners.indexOf(listener);
          // Removes this instance's listeners and closes the underlying fs_watchFile
          // instance if there are no more listeners left.

          return function() {
            delFromSet(cont, KEY_LISTENERS, listener)
            delFromSet(cont, KEY_RAW, rawEmitter)

            if (isEmptySet(cont.listeners)) {
              FsWatchFileInstances.delete(fullPath)
              fs.unwatchFile(fullPath)
              cont.options = cont.watcher = undefined
              Object.freeze(cont)
            }
          }
        }
        /**
         * @mixin
         */

        const NodeFsHandler =
          /* #__PURE__ */
          (function() {
            /**
             * @param {import("../index").FSWatcher} fsW
             */
            function NodeFsHandler(fsW) {
              _classCallCheck(this, NodeFsHandler)

              this.fsw = fsW

              this._boundHandleError = function(error) {
                return fsW._handleError(error)
              }
            }
            /**
             * Watch file for changes with fs_watchFile or fs_watch.
             * @param {String} path to file or dir
             * @param {Function} listener on fs change
             * @returns {Function} closer for the watcher instance
             */

            _createClass(NodeFsHandler, [
              {
                key: '_watchWithNodeFs',
                value: function _watchWithNodeFs(path, listener) {
                  const options_ = this.fsw.options
                  const directory = sysPath.dirname(path)
                  const basename = sysPath.basename(path)

                  const parent = this.fsw._getWatchedDir(directory)

                  parent.add(basename)
                  const absolutePath = sysPath.resolve(path)
                  const options = {
                    persistent: options_.persistent,
                  }
                  if (!listener) {
                    listener = EMPTY_FN
                  }
                  let closer

                  if (options_.usePolling) {
                    options.interval =
                      options_.enableBinaryInterval && isBinaryPath(basename)
                        ? options_.binaryInterval
                        : options_.interval
                    closer = setFsWatchFileListener(
                      path,
                      absolutePath,
                      options,
                      {
                        listener,
                        rawEmitter: this.fsw._emitRaw,
                      }
                    )
                  } else {
                    closer = setFsWatchListener(path, absolutePath, options, {
                      listener,
                      errHandler: this._boundHandleError,
                      rawEmitter: this.fsw._emitRaw,
                    })
                  }

                  return closer
                },
                /**
                 * Watch a file and emit add event if warranted.
                 * @param {Path} file Path
                 * @param {fs.Stats} stats result of fs_stat
                 * @param {Boolean} initialAdd was the file added at watch instantiation?
                 * @returns {Function} closer for the watcher instance
                 */
              },
              {
                key: '_handleFile',
                value: function _handleFile(file, stats, initialAdd) {
                  const _this = this

                  if (this.fsw.closed) {
                    return
                  }

                  const dirname = sysPath.dirname(file)
                  const basename = sysPath.basename(file)

                  const parent = this.fsw._getWatchedDir(dirname) // stats is always present

                  let previousStats = stats // if the file is already being watched, do nothing

                  if (parent.has(basename)) {
                    return
                  } // kick off the watcher

                  const closer = this._watchWithNodeFs(
                    file,
                    /* #__PURE__ */
                    (function() {
                      const _reference2 = _asyncToGenerator(
                        /* #__PURE__ */
                        regeneratorRuntime.mark(function _callee2(
                          path,
                          newStats
                        ) {
                          let _newStats
                          let at
                          let mt
                          let _at
                          let _mt

                          return regeneratorRuntime.wrap(
                            function _callee2$(_context2) {
                              while (1) {
                                switch ((_context2.prev = _context2.next)) {
                                  case 0:
                                    if (
                                      _this.fsw._throttle(
                                        THROTTLE_MODE_WATCH,
                                        file,
                                        5
                                      )
                                    ) {
                                      _context2.next = 2
                                      break
                                    }

                                    return _context2.abrupt('return')

                                  case 2:
                                    if (
                                      !(
                                        !newStats ||
                                        (newStats && newStats.mtimeMs === 0)
                                      )
                                    ) {
                                      _context2.next = 20
                                      break
                                    }

                                    _context2.prev = 3
                                    _context2.next = 6
                                    return stat(file)

                                  case 6:
                                    _newStats = _context2.sent

                                    if (!_this.fsw.closed) {
                                      _context2.next = 9
                                      break
                                    }

                                    return _context2.abrupt('return')

                                  case 9:
                                    // Check that change event was not fired because of changed only accessTime.
                                    at = _newStats.atimeMs
                                    mt = _newStats.mtimeMs

                                    if (
                                      !at ||
                                      at <= mt ||
                                      mt !== previousStats.mtimeMs
                                    ) {
                                      _this.fsw._emit(
                                        EV_CHANGE,
                                        file,
                                        _newStats
                                      )
                                    }

                                    previousStats = _newStats
                                    _context2.next = 18
                                    break

                                  case 15:
                                    _context2.prev = 15
                                    _context2.t0 = _context2.catch(3)

                                    // Fix issues where mtime is null but file is still present
                                    _this.fsw._remove(dirname, basename)

                                  case 18:
                                    _context2.next = 21
                                    break

                                  case 20:
                                    if (parent.has(basename)) {
                                      // Check that change event was not fired because of changed only accessTime.
                                      _at = newStats.atimeMs
                                      _mt = newStats.mtimeMs

                                      if (
                                        !_at ||
                                        _at <= _mt ||
                                        _mt !== previousStats.mtimeMs
                                      ) {
                                        _this.fsw._emit(
                                          EV_CHANGE,
                                          file,
                                          newStats
                                        )
                                      }

                                      previousStats = newStats
                                    }

                                  case 21:
                                  case 'end':
                                    return _context2.stop()
                                }
                              }
                            },
                            _callee2,
                            null,
                            [[3, 15]]
                          )
                        })
                      )

                      return function(_x2, _x3) {
                        return Reflect.apply(_reference2, this, arguments)
                      }
                    })()
                  ) // emit an add event if we're supposed to

                  if (
                    !(initialAdd && this.fsw.options.ignoreInitial) &&
                    this.fsw._isntIgnored(file)
                  ) {
                    if (!this.fsw._throttle(EV_ADD, file, 0)) {
                      return
                    }

                    this.fsw._emit(EV_ADD, file, stats)
                  }

                  return closer
                },
                /**
                 * Handle symlinks encountered while reading a dir.
                 * @param {Object} entry returned by readdirp
                 * @param {String} directory path of dir being read
                 * @param {String} path of this item
                 * @param {String} item basename of this item
                 * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
                 */
              },
              {
                key: '_handleSymlink',
                value: (function() {
                  const _handleSymlink2 = _asyncToGenerator(
                    /* #__PURE__ */
                    regeneratorRuntime.mark(function _callee3(
                      entry,
                      directory,
                      path,
                      item
                    ) {
                      let full
                      let dir
                      let linkPath
                      return regeneratorRuntime.wrap(
                        function _callee3$(_context3) {
                          while (1) {
                            switch ((_context3.prev = _context3.next)) {
                              case 0:
                                if (!this.fsw.closed) {
                                  _context3.next = 2
                                  break
                                }

                                return _context3.abrupt('return')

                              case 2:
                                full = entry.fullPath
                                dir = this.fsw._getWatchedDir(directory)

                                if (this.fsw.options.followSymlinks) {
                                  _context3.next = 14
                                  break
                                }

                                // watch symlink directly (don't follow) and detect changes
                                this.fsw._incrReadyCount()

                                _context3.next = 8
                                return fsrealpath(path)

                              case 8:
                                linkPath = _context3.sent

                                if (!this.fsw.closed) {
                                  _context3.next = 11
                                  break
                                }

                                return _context3.abrupt('return')

                              case 11:
                                if (dir.has(item)) {
                                  if (
                                    this.fsw._symlinkPaths.get(full) !==
                                    linkPath
                                  ) {
                                    this.fsw._symlinkPaths.set(full, linkPath)

                                    this.fsw._emit(EV_CHANGE, path, entry.stats)
                                  }
                                } else {
                                  dir.add(item)

                                  this.fsw._symlinkPaths.set(full, linkPath)

                                  this.fsw._emit(EV_ADD, path, entry.stats)
                                }

                                this.fsw._emitReady()

                                return _context3.abrupt('return', true)

                              case 14:
                                if (!this.fsw._symlinkPaths.has(full)) {
                                  _context3.next = 18
                                  break
                                }

                                return _context3.abrupt('return', true)

                              case 18:
                                this.fsw._symlinkPaths.set(full, true)

                              case 19:
                              case 'end':
                                return _context3.stop()
                            }
                          }
                        },
                        _callee3,
                        this
                      )
                    })
                  )

                  function _handleSymlink(_x4, _x5, _x6, _x7) {
                    return Reflect.apply(_handleSymlink2, this, arguments)
                  }

                  return _handleSymlink
                })(),
              },
              {
                key: '_handleRead',
                value: function _handleRead(
                  directory,
                  initialAdd,
                  wh,
                  target,
                  dir,
                  depth,
                  throttler
                ) {
                  const _this2 = this

                  // Normalize the directory name on Windows
                  directory = sysPath.join(directory, EMPTY_STR)

                  if (!wh.hasGlob) {
                    // throttler = this.fsw._throttle('readdir', directory, 1000);
                    // if (!throttler) return;
                  }

                  const previous = this.fsw._getWatchedDir(wh.path)

                  const current = new Set()

                  var stream = this.fsw
                    ._readdirp(directory, {
                      fileFilter: function fileFilter(entry) {
                        return wh.filterPath(entry)
                      },
                      directoryFilter: function directoryFilter(entry) {
                        return wh.filterDir(entry)
                      },
                      depth: 0,
                    })
                    .on(
                      STR_DATA,
                      /* #__PURE__ */
                      (function() {
                        const _reference3 = _asyncToGenerator(
                          /* #__PURE__ */
                          regeneratorRuntime.mark(function _callee4(entry) {
                            let item
                            let path
                            return regeneratorRuntime.wrap(function _callee4$(
                              _context4
                            ) {
                              while (1) {
                                switch ((_context4.prev = _context4.next)) {
                                  case 0:
                                    if (!_this2.fsw.closed) {
                                      _context4.next = 3
                                      break
                                    }

                                    stream = undefined
                                    return _context4.abrupt('return')

                                  case 3:
                                    item = entry.path
                                    path = sysPath.join(directory, item)
                                    current.add(item)
                                    _context4.t0 = entry.stats.isSymbolicLink()

                                    if (!_context4.t0) {
                                      _context4.next = 11
                                      break
                                    }

                                    _context4.next = 10
                                    return _this2._handleSymlink(
                                      entry,
                                      directory,
                                      path,
                                      item
                                    )

                                  case 10:
                                    _context4.t0 = _context4.sent

                                  case 11:
                                    if (!_context4.t0) {
                                      _context4.next = 13
                                      break
                                    }

                                    return _context4.abrupt('return')

                                  case 13:
                                    if (!_this2.fsw.closed) {
                                      _context4.next = 16
                                      break
                                    }

                                    stream = undefined
                                    return _context4.abrupt('return')

                                  case 16:
                                    // Files that present in current directory snapshot
                                    // but absent in previous are added to watch list and
                                    // emit `add` event.
                                    if (
                                      item === target ||
                                      (!target && !previous.has(item))
                                    ) {
                                      _this2.fsw._incrReadyCount() // ensure relativeness of path is preserved in case of watcher reuse

                                      path = sysPath.join(
                                        dir,
                                        sysPath.relative(dir, path)
                                      )

                                      _this2._addToNodeFs(
                                        path,
                                        initialAdd,
                                        wh,
                                        depth + 1
                                      )
                                    }

                                  case 17:
                                  case 'end':
                                    return _context4.stop()
                                }
                              }
                            },
                            _callee4)
                          })
                        )

                        return function(_x8) {
                          return Reflect.apply(_reference3, this, arguments)
                        }
                      })()
                    )
                    .on(EV_ERROR, this._boundHandleError)

                  return new Promise(function(resolve) {
                    return stream.once(STR_END, function() {
                      if (_this2.fsw.closed) {
                        stream = undefined
                        return
                      }

                      const wasThrottled = throttler ? throttler.clear() : false
                      resolve() // Files that absent in current directory snapshot
                      // but present in previous emit `remove` event
                      // and are removed from @watched[directory].

                      previous
                        .getChildren()
                        .filter(function(item) {
                          return (
                            item !== directory &&
                            !current.has(item) && // in case of intersecting globs;
                            // a path may have been filtered out of this readdir, but
                            // shouldn't be removed because it matches a different glob
                            (!wh.hasGlob ||
                              wh.filterPath({
                                fullPath: sysPath.resolve(directory, item),
                              }))
                          )
                        })
                        .forEach(function(item) {
                          _this2.fsw._remove(directory, item)
                        })
                      stream = undefined // one more time for any missed in case changes came in extremely quickly

                      if (wasThrottled) {
                        _this2._handleRead(
                          directory,
                          false,
                          wh,
                          target,
                          dir,
                          depth,
                          throttler
                        )
                      }
                    })
                  })
                },
                /**
                 * Read directory to add / remove files from `@watched` list and re-read it on change.
                 * @param {String} dir fs path
                 * @param {fs.Stats} stats
                 * @param {Boolean} initialAdd
                 * @param {Number} depth relative to user-supplied path
                 * @param {String} target child path targetted for watch
                 * @param {Object} wh Common watch helpers for this path
                 * @param {String} realpath
                 * @returns {Promise<Function>} closer for the watcher instance.
                 */
              },
              {
                key: '_handleDir',
                value: (function() {
                  const _handleDir2 = _asyncToGenerator(
                    /* #__PURE__ */
                    regeneratorRuntime.mark(function _callee5(
                      dir,
                      stats,
                      initialAdd,
                      depth,
                      target,
                      wh,
                      realpath
                    ) {
                      const _this3 = this

                      let parentDir
                      let tracked
                      let throttler
                      let closer
                      let oDepth
                      return regeneratorRuntime.wrap(
                        function _callee5$(_context5) {
                          while (1) {
                            switch ((_context5.prev = _context5.next)) {
                              case 0:
                                parentDir = this.fsw._getWatchedDir(
                                  sysPath.dirname(dir)
                                )
                                tracked = parentDir.has(sysPath.basename(dir))

                                if (
                                  !(
                                    initialAdd && this.fsw.options.ignoreInitial
                                  ) &&
                                  !target &&
                                  !tracked
                                ) {
                                  if (!wh.hasGlob || wh.globFilter(dir)) {
                                    this.fsw._emit(EV_ADD_DIR, dir, stats)
                                  }
                                } // ensure dir is tracked (harmless if redundant)

                                parentDir.add(sysPath.basename(dir))

                                this.fsw._getWatchedDir(dir)

                                oDepth = this.fsw.options.depth

                                if (
                                  !(
                                    (oDepth == null || depth <= oDepth) &&
                                    !this.fsw._symlinkPaths.has(realpath)
                                  )
                                ) {
                                  _context5.next = 13
                                  break
                                }

                                if (target) {
                                  _context5.next = 12
                                  break
                                }

                                _context5.next = 10
                                return this._handleRead(
                                  dir,
                                  initialAdd,
                                  wh,
                                  target,
                                  dir,
                                  depth,
                                  throttler
                                )

                              case 10:
                                if (!this.fsw.closed) {
                                  _context5.next = 12
                                  break
                                }

                                return _context5.abrupt('return')

                              case 12:
                                closer = this._watchWithNodeFs(dir, function(
                                  dirPath,
                                  stats
                                ) {
                                  // if current directory is removed, do nothing
                                  if (stats && stats.mtimeMs === 0) {
                                    return
                                  }

                                  _this3._handleRead(
                                    dirPath,
                                    false,
                                    wh,
                                    target,
                                    dir,
                                    depth,
                                    throttler
                                  )
                                })

                              case 13:
                                return _context5.abrupt('return', closer)

                              case 14:
                              case 'end':
                                return _context5.stop()
                            }
                          }
                        },
                        _callee5,
                        this
                      )
                    })
                  )

                  function _handleDir(_x9, _x10, _x11, _x12, _x13, _x14, _x15) {
                    return Reflect.apply(_handleDir2, this, arguments)
                  }

                  return _handleDir
                })(),
                /**
                 * Handle added file, directory, or glob pattern.
                 * Delegates call to _handleFile / _handleDir after checks.
                 * @param {String} path to file or ir
                 * @param {Boolean} initialAdd was the file added at watch instantiation?
                 * @param {Object} priorWh depth relative to user-supplied path
                 * @param {Number} depth Child path actually targetted for watch
                 * @param {String=} target Child path actually targeted for watch
                 * @returns {Promise}
                 */
              },
              {
                key: '_addToNodeFs',
                value: (function() {
                  const _addToNodeFs2 = _asyncToGenerator(
                    /* #__PURE__ */
                    regeneratorRuntime.mark(function _callee6(
                      path,
                      initialAdd,
                      priorWh,
                      depth,
                      target
                    ) {
                      let ready
                      let wh
                      let stats
                      let follow
                      let closer
                      let targetPath
                      let _targetPath
                      let parent

                      return regeneratorRuntime.wrap(
                        function _callee6$(_context6) {
                          while (1) {
                            switch ((_context6.prev = _context6.next)) {
                              case 0:
                                ready = this.fsw._emitReady

                                if (
                                  !(
                                    this.fsw._isIgnored(path) || this.fsw.closed
                                  )
                                ) {
                                  _context6.next = 4
                                  break
                                }

                                ready()
                                return _context6.abrupt('return', false)

                              case 4:
                                wh = this.fsw._getWatchHelpers(path, depth)

                                if (!wh.hasGlob && priorWh) {
                                  wh.hasGlob = priorWh.hasGlob
                                  wh.globFilter = priorWh.globFilter

                                  wh.filterPath = function(entry) {
                                    return priorWh.filterPath(entry)
                                  }

                                  wh.filterDir = function(entry) {
                                    return priorWh.filterDir(entry)
                                  }
                                } // evaluate what is at the path we're being asked to watch

                                _context6.prev = 6
                                _context6.next = 9
                                return statMethods[wh.statMethod](wh.watchPath)

                              case 9:
                                stats = _context6.sent

                                if (!this.fsw.closed) {
                                  _context6.next = 12
                                  break
                                }

                                return _context6.abrupt('return')

                              case 12:
                                if (!this.fsw._isIgnored(wh.watchPath, stats)) {
                                  _context6.next = 15
                                  break
                                }

                                ready()
                                return _context6.abrupt('return', false)

                              case 15:
                                follow =
                                  this.fsw.options.followSymlinks &&
                                  !path.includes('*') &&
                                  !path.includes('{')

                                if (!stats.isDirectory()) {
                                  _context6.next = 35
                                  break
                                }

                                if (!follow) {
                                  _context6.next = 23
                                  break
                                }

                                _context6.next = 20
                                return fsrealpath(path)

                              case 20:
                                _context6.t0 = _context6.sent
                                _context6.next = 24
                                break

                              case 23:
                                _context6.t0 = path

                              case 24:
                                targetPath = _context6.t0

                                if (!this.fsw.closed) {
                                  _context6.next = 27
                                  break
                                }

                                return _context6.abrupt('return')

                              case 27:
                                _context6.next = 29
                                return this._handleDir(
                                  wh.watchPath,
                                  stats,
                                  initialAdd,
                                  depth,
                                  target,
                                  wh,
                                  targetPath
                                )

                              case 29:
                                closer = _context6.sent

                                if (!this.fsw.closed) {
                                  _context6.next = 32
                                  break
                                }

                                return _context6.abrupt('return')

                              case 32:
                                // preserve this symlink's target path
                                if (
                                  path !== targetPath &&
                                  targetPath !== undefined
                                ) {
                                  this.fsw._symlinkPaths.set(targetPath, true)
                                }

                                _context6.next = 58
                                break

                              case 35:
                                if (!stats.isSymbolicLink()) {
                                  _context6.next = 57
                                  break
                                }

                                if (!follow) {
                                  _context6.next = 42
                                  break
                                }

                                _context6.next = 39
                                return fsrealpath(path)

                              case 39:
                                _context6.t1 = _context6.sent
                                _context6.next = 43
                                break

                              case 42:
                                _context6.t1 = path

                              case 43:
                                _targetPath = _context6.t1

                                if (!this.fsw.closed) {
                                  _context6.next = 46
                                  break
                                }

                                return _context6.abrupt('return')

                              case 46:
                                parent = sysPath.dirname(wh.watchPath)

                                this.fsw
                                  ._getWatchedDir(parent)
                                  .add(wh.watchPath)

                                this.fsw._emit(EV_ADD, wh.watchPath, stats)

                                _context6.next = 51
                                return this._handleDir(
                                  parent,
                                  stats,
                                  initialAdd,
                                  depth,
                                  path,
                                  wh,
                                  _targetPath
                                )

                              case 51:
                                closer = _context6.sent

                                if (!this.fsw.closed) {
                                  _context6.next = 54
                                  break
                                }

                                return _context6.abrupt('return')

                              case 54:
                                // preserve this symlink's target path
                                if (_targetPath !== undefined) {
                                  this.fsw._symlinkPaths.set(
                                    sysPath.resolve(path),
                                    _targetPath
                                  )
                                }

                                _context6.next = 58
                                break

                              case 57:
                                closer = this._handleFile(
                                  wh.watchPath,
                                  stats,
                                  initialAdd
                                )

                              case 58:
                                ready()

                                this.fsw._addPathCloser(path, closer)

                                return _context6.abrupt('return', false)

                              case 63:
                                _context6.prev = 63
                                _context6.t2 = _context6.catch(6)

                                if (!this.fsw._handleError(_context6.t2)) {
                                  _context6.next = 68
                                  break
                                }

                                ready()
                                return _context6.abrupt('return', path)

                              case 68:
                              case 'end':
                                return _context6.stop()
                            }
                          }
                        },
                        _callee6,
                        this,
                        [[6, 63]]
                      )
                    })
                  )

                  function _addToNodeFs(_x16, _x17, _x18, _x19, _x20) {
                    return Reflect.apply(_addToNodeFs2, this, arguments)
                  }

                  return _addToNodeFs
                })(),
              },
            ])

            return NodeFsHandler
          })()

        module.exports = NodeFsHandler
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 209 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__
        )
        /* harmony import */ const core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          2
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          37
        )
        /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_3___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_3__
        )

        const path = __webpack_require__(15)

        const binaryExtensions = __webpack_require__(210)

        const extensions = new Set(binaryExtensions)

        module.exports = function(filePath) {
          return extensions.has(
            path
              .extname(filePath)
              .slice(1)
              .toLowerCase()
          )
        }
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 210 */
    /** */ function(module, exports, __webpack_require__) {
      module.exports = __webpack_require__(211)

      /** */
    },
    /* 211 */
    /** */ function(module) {
      module.exports = JSON.parse(
        '["3dm","3ds","3g2","3gp","7z","a","aac","adp","ai","aif","aiff","alz","ape","apk","ar","arj","asf","au","avi","bak","baml","bh","bin","bk","bmp","btif","bz2","bzip2","cab","caf","cgm","class","cmx","cpio","cr2","cur","dat","dcm","deb","dex","djvu","dll","dmg","dng","doc","docm","docx","dot","dotm","dra","DS_Store","dsk","dts","dtshd","dvb","dwg","dxf","ecelp4800","ecelp7470","ecelp9600","egg","eol","eot","epub","exe","f4v","fbs","fh","fla","flac","fli","flv","fpx","fst","fvt","g3","gh","gif","graffle","gz","gzip","h261","h263","h264","icns","ico","ief","img","ipa","iso","jar","jpeg","jpg","jpgv","jpm","jxr","key","ktx","lha","lib","lvp","lz","lzh","lzma","lzo","m3u","m4a","m4v","mar","mdi","mht","mid","midi","mj2","mka","mkv","mmr","mng","mobi","mov","movie","mp3","mp4","mp4a","mpeg","mpg","mpga","mxu","nef","npx","numbers","nupkg","o","oga","ogg","ogv","otf","pages","pbm","pcx","pdb","pdf","pea","pgm","pic","png","pnm","pot","potm","potx","ppa","ppam","ppm","pps","ppsm","ppsx","ppt","pptm","pptx","psd","pya","pyc","pyo","pyv","qt","rar","ras","raw","resources","rgb","rip","rlc","rmf","rmvb","rtf","rz","s3m","s7z","scpt","sgi","shar","sil","sketch","slk","smv","snk","so","stl","suo","sub","swf","tar","tbz","tbz2","tga","tgz","thmx","tif","tiff","tlz","ttc","ttf","txz","udf","uvh","uvi","uvm","uvp","uvs","uvu","viv","vob","war","wav","wax","wbmp","wdp","weba","webm","webp","whl","wim","wm","wma","wmv","wmx","woff","woff2","wrm","wvx","xbm","xif","xla","xlam","xls","xlsb","xlsm","xlsx","xlt","xltm","xltx","xm","xmind","xpi","xpm","xwd","xz","z","zip","zipx"]'
      )

      /** */
    },
    /* 212 */
    /** */ function(module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__)
      /* WEBPACK VAR INJECTION */
      ;(function(module) {
        /* harmony import */ const core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          5
        )
        /* harmony import */ const core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          10
        )
        /* harmony import */ const core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          13
        )
        /* harmony import */ const core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          21
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          4
        )
        /* harmony import */ const core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4__
        )
        /* harmony import */ const core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          74
        )
        /* harmony import */ const core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_5___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_5__
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          43
        )
        /* harmony import */ const core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6__
        )
        /* harmony import */ const core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          1
        )
        /* harmony import */ const core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          44
        )
        /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          37
        )
        /* harmony import */ const core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_9___default = /* #__PURE__ */ __webpack_require__.n(
          core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_9__
        )
        /* harmony import */ const core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
          28
        )
        /* harmony import */ const core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
          14
        )
        /* harmony import */ const regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
          75
        )

        function ownKeys(object, enumerableOnly) {
          const keys = Object.keys(object)
          if (Object.getOwnPropertySymbols) {
            let symbols = Object.getOwnPropertySymbols(object)
            if (enumerableOnly) {
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable
              })
            }
            keys.push.apply(keys, symbols)
          }
          return keys
        }

        function _objectSpread(target) {
          for (let i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {}
            if (i % 2) {
              ownKeys(source, true).forEach(function(key) {
                _defineProperty(target, key, source[key])
              })
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(
                target,
                Object.getOwnPropertyDescriptors(source)
              )
            } else {
              ownKeys(source).forEach(function(key) {
                Object.defineProperty(
                  target,
                  key,
                  Object.getOwnPropertyDescriptor(source, key)
                )
              })
            }
          }
          return target
        }

        function _defineProperty(object, key, value) {
          if (key in object) {
            Object.defineProperty(object, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true,
            })
          } else {
            object[key] = value
          }
          return object
        }

        function asyncGeneratorStep(
          gen,
          resolve,
          reject,
          _next,
          _throw,
          key,
          argument
        ) {
          try {
            var info = gen[key](argument)
            var {value} = info
          } catch (error) {
            reject(error)
            return
          }
          if (info.done) {
            resolve(value)
          } else {
            Promise.resolve(value).then(_next, _throw)
          }
        }

        function _asyncToGenerator(fn) {
          return function() {
            const self = this
            const arguments_ = arguments
            return new Promise(function(resolve, reject) {
              const gen = fn.apply(self, arguments_)
              function _next(value) {
                asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  'next',
                  value
                )
              }
              function _throw(error) {
                asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  'throw',
                  error
                )
              }
              _next(undefined)
            })
          }
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function')
          }
        }

        function _defineProperties(target, properties) {
          for (const descriptor of properties) {
            descriptor.enumerable = descriptor.enumerable || false
            descriptor.configurable = true
            if ('value' in descriptor) {
              descriptor.writable = true
            }
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }

        function _createClass(Constructor, protoProperties, staticProperties) {
          if (protoProperties) {
            _defineProperties(Constructor.prototype, protoProperties)
          }
          if (staticProperties) {
            _defineProperties(Constructor, staticProperties)
          }
          return Constructor
        }

        const fs = __webpack_require__(35)

        const sysPath = __webpack_require__(15)

        const _require = __webpack_require__(36)
        const {promisify} = _require

        let fsevents

        try {
          fsevents = __webpack_require__(213)
        } catch (error) {
          if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) {
            console.error(error)
          }
        }

        if (fsevents) {
          // TODO: real check
          const mtch = process.version.match(/v(\d+)\.(\d+)/)

          if (mtch && mtch[1] && mtch[2]) {
            const maj = Number.parseInt(mtch[1])
            const min = Number.parseInt(mtch[2])

            if (maj === 8 && min < 16) {
              fsevents = undefined
            }
          }
        }

        const _require2 = __webpack_require__(109)
        const {EV_ADD} = _require2
        const {EV_CHANGE} = _require2
        const {EV_ADD_DIR} = _require2
        const {EV_UNLINK} = _require2
        const {EV_ERROR} = _require2
        const {STR_DATA} = _require2
        const {STR_END} = _require2
        const {FSEVENT_CREATED} = _require2
        const {FSEVENT_MODIFIED} = _require2
        const {FSEVENT_DELETED} = _require2
        const {FSEVENT_MOVED} = _require2
        const {FSEVENT_UNKNOWN} = _require2
        const {FSEVENT_TYPE_DIRECTORY} = _require2
        const {FSEVENT_TYPE_SYMLINK} = _require2
        const {ROOT_GLOBSTAR} = _require2
        const {DIR_SUFFIX} = _require2
        const {DOT_SLASH} = _require2
        const {FUNCTION_TYPE} = _require2
        const {EMPTY_FN} = _require2
        const {IDENTITY_FN} = _require2

        const FS_MODE_READ = 'r'

        const Depth = function Depth(value) {
          return isNaN(value)
            ? {}
            : {
                depth: value,
              }
        }

        const stat = promisify(fs.stat)
        const open = promisify(fs.open)
        const close = promisify(fs.close)
        const lstat = promisify(fs.lstat)
        const realpath = promisify(fs.realpath)
        const statMethods = {
          stat,
          lstat,
        }
        /**
         * @typedef {String} Path
         */

        /**
         * @typedef {Object} FsEventsWatchContainer
         * @property {Set<Function>} listeners
         * @property {Function} rawEmitter
         * @property {{stop: Function}} watcher
         */
        // fsevents instance helper functions

        /**
         * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)
         * @type {Map<Path,FsEventsWatchContainer>}
         */

        const FSEventsWatchers = new Map() // Threshold of duplicate path prefixes at which to start
        // consolidating going forward

        const consolidateThreshhold = 10
        const wrongEventFlags = new Set([
          69888,
          70400,
          71424,
          72704,
          73472,
          131328,
          131840,
          262912,
        ])
        /**
         * Instantiates the fsevents interface
         * @param {Path} path path to be watched
         * @param {Function} callback called when fsevents is bound and ready
         * @returns {{stop: Function}} new fsevents instance
         */

        const createFSEventsInstance = function createFSEventsInstance(
          path,
          callback
        ) {
          const stop = fsevents.watch(path, callback)
          return {
            stop,
          }
        }
        /**
         * Instantiates the fsevents interface or binds listeners to an existing one covering
         * the same file tree.
         * @param {Path} path           - to be watched
         * @param {Path} realPath       - real path for symlinks
         * @param {Function} listener   - called when fsevents emits events
         * @param {Function} rawEmitter - passes data to listeners of the 'raw' event
         * @returns {Function} closer
         */

        function setFSEventsListener(
          path,
          realPath,
          listener,
          rawEmitter,
          fsw
        ) {
          let watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path
          const parentPath = sysPath.dirname(watchPath)
          let cont = FSEventsWatchers.get(watchPath) // If we've accumulated a substantial number of paths that
          // could have been consolidated by watching one directory
          // above the current one, create a watcher on the parent
          // path instead, so that we do consolidate going forward.

          if (couldConsolidate(parentPath)) {
            watchPath = parentPath
          }

          const resolvedPath = sysPath.resolve(path)
          const hasSymlink = resolvedPath !== realPath

          const filteredListener = function filteredListener(
            fullPath,
            flags,
            info
          ) {
            if (hasSymlink) {
              fullPath = fullPath.replace(realPath, resolvedPath)
            }
            if (
              fullPath === resolvedPath ||
              !fullPath.indexOf(resolvedPath + sysPath.sep)
            ) {
              listener(fullPath, flags, info)
            }
          } // check if there is already a watcher on a parent path
          // modifies `watchPath` to the parent path when it finds a match

          let watchedParent = false
          let _iteratorNormalCompletion = true
          let _didIteratorError = false
          let _iteratorError

          try {
            for (
              var _iterator = FSEventsWatchers.keys()[Symbol.iterator](), _step;
              !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
              _iteratorNormalCompletion = true
            ) {
              const watchedPath = _step.value

              if (
                realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) ===
                0
              ) {
                watchPath = watchedPath
                cont = FSEventsWatchers.get(watchPath)
                watchedParent = true
                break
              }
            }
          } catch (error) {
            _didIteratorError = true
            _iteratorError = error
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return()
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError
              }
            }
          }

          if (cont || watchedParent) {
            cont.listeners.add(filteredListener)
          } else {
            cont = {
              listeners: new Set([filteredListener]),
              rawEmitter,
              watcher: createFSEventsInstance(watchPath, function(
                fullPath,
                flags
              ) {
                if (fsw.closed) {
                  return
                }
                const info = fsevents.getInfo(fullPath, flags)
                cont.listeners.forEach(function(list) {
                  list(fullPath, flags, info)
                })
                cont.rawEmitter(info.event, fullPath, info)
              }),
            }
            FSEventsWatchers.set(watchPath, cont)
          } // removes this instance's listeners and closes the underlying fsevents
          // instance if there are no more listeners left

          return function() {
            const lst = cont.listeners
            lst.delete(filteredListener)

            if (!lst.size) {
              FSEventsWatchers.delete(watchPath)
              cont.watcher.stop()
              cont.rawEmitter = cont.watcher = undefined
              Object.freeze(cont)
            }
          }
        } // Decide whether or not we should start a new higher-level
        // parent watcher

        var couldConsolidate = function couldConsolidate(path) {
          let count = 0
          let _iteratorNormalCompletion2 = true
          let _didIteratorError2 = false
          let _iteratorError2

          try {
            for (
              var _iterator2 = FSEventsWatchers.keys()[Symbol.iterator](),
                _step2;
              !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done);
              _iteratorNormalCompletion2 = true
            ) {
              const watchPath = _step2.value

              if (watchPath.indexOf(path) === 0) {
                count++

                if (count >= consolidateThreshhold) {
                  return true
                }
              }
            }
          } catch (error) {
            _didIteratorError2 = true
            _iteratorError2 = error
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return()
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2
              }
            }
          }

          return false
        } // returns boolean indicating whether fsevents can be used

        const canUse = function canUse() {
          return fsevents && FSEventsWatchers.size < 128
        } // determines subdirectory traversal levels from root to path

        const calcDepth = function calcDepth(path, root) {
          let i = 0

          while (
            !path.indexOf(root) &&
            (path = sysPath.dirname(path)) !== root
          ) {
            i++
          }

          return i
        }
        /**
         * @mixin
         */

        const FsEventsHandler =
          /* #__PURE__ */
          (function() {
            /**
             * @param {import('../index').FSWatcher} fsw
             */
            function FsEventsHandler(fsw) {
              _classCallCheck(this, FsEventsHandler)

              this.fsw = fsw
            }

            _createClass(FsEventsHandler, [
              {
                key: 'checkIgnored',
                value: function checkIgnored(path, stats) {
                  const ipaths = this.fsw._ignoredPaths

                  if (this.fsw._isIgnored(path, stats)) {
                    ipaths.add(path)

                    if (stats && stats.isDirectory()) {
                      ipaths.add(path + ROOT_GLOBSTAR)
                    }

                    return true
                  }
                  ipaths.delete(path)
                  ipaths.delete(path + ROOT_GLOBSTAR)
                },
              },
              {
                key: 'addOrChange',
                value: function addOrChange(
                  path,
                  fullPath,
                  realPath,
                  parent,
                  watchedDir,
                  item,
                  info,
                  options
                ) {
                  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD
                  this.handleEvent(
                    event,
                    path,
                    fullPath,
                    realPath,
                    parent,
                    watchedDir,
                    item,
                    info,
                    options
                  )
                },
              },
              {
                key: 'checkFd',
                value: (function() {
                  const _checkFd = _asyncToGenerator(
                    /* #__PURE__ */
                    regeneratorRuntime.mark(function _callee(
                      path,
                      fullPath,
                      realPath,
                      parent,
                      watchedDir,
                      item,
                      info,
                      options
                    ) {
                      let fd
                      return regeneratorRuntime.wrap(
                        function _callee$(_context) {
                          while (1) {
                            switch ((_context.prev = _context.next)) {
                              case 0:
                                _context.prev = 0
                                _context.next = 3
                                return open(path, FS_MODE_READ)

                              case 3:
                                fd = _context.sent

                                if (!this.fsw.closed) {
                                  _context.next = 6
                                  break
                                }

                                return _context.abrupt('return')

                              case 6:
                                _context.next = 8
                                return close(fd)

                              case 8:
                                if (!this.fsw.closed) {
                                  _context.next = 10
                                  break
                                }

                                return _context.abrupt('return')

                              case 10:
                                this.addOrChange(
                                  path,
                                  fullPath,
                                  realPath,
                                  parent,
                                  watchedDir,
                                  item,
                                  info,
                                  options
                                )
                                _context.next = 16
                                break

                              case 13:
                                _context.prev = 13
                                _context.t0 = _context.catch(0)

                                if (_context.t0.code === 'EACCES') {
                                  this.addOrChange(
                                    path,
                                    fullPath,
                                    realPath,
                                    parent,
                                    watchedDir,
                                    item,
                                    info,
                                    options
                                  )
                                } else {
                                  this.handleEvent(
                                    EV_UNLINK,
                                    path,
                                    fullPath,
                                    realPath,
                                    parent,
                                    watchedDir,
                                    item,
                                    info,
                                    options
                                  )
                                }

                              case 16:
                              case 'end':
                                return _context.stop()
                            }
                          }
                        },
                        _callee,
                        this,
                        [[0, 13]]
                      )
                    })
                  )

                  function checkFd(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {
                    return Reflect.apply(_checkFd, this, arguments)
                  }

                  return checkFd
                })(),
              },
              {
                key: 'handleEvent',
                value: function handleEvent(
                  event,
                  path,
                  fullPath,
                  realPath,
                  parent,
                  watchedDir,
                  item,
                  info,
                  options
                ) {
                  if (this.fsw.closed || this.checkIgnored(path)) {
                    return
                  }

                  if (event === EV_UNLINK) {
                    // suppress unlink events on never before seen files
                    if (
                      info.type === FSEVENT_TYPE_DIRECTORY ||
                      watchedDir.has(item)
                    ) {
                      this.fsw._remove(parent, item)
                    }
                  } else {
                    if (event === EV_ADD) {
                      // track new directories
                      if (info.type === FSEVENT_TYPE_DIRECTORY) {
                        this.fsw._getWatchedDir(path)
                      }

                      if (
                        info.type === FSEVENT_TYPE_SYMLINK &&
                        options.followSymlinks
                      ) {
                        // push symlinks back to the top of the stack to get handled
                        const currentDepth =
                          options.depth === undefined
                            ? undefined
                            : calcDepth(fullPath, realPath) + 1
                        return this._addToFsEvents(
                          path,
                          false,
                          true,
                          currentDepth
                        )
                      }
                      // track new paths
                      // (other than symlinks being followed, which will be tracked soon)
                      this.fsw._getWatchedDir(parent).add(item)
                    }
                    /**
                     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}
                     */

                    const eventName =
                      info.type === FSEVENT_TYPE_DIRECTORY
                        ? event + DIR_SUFFIX
                        : event

                    this.fsw._emit(eventName, path)

                    if (eventName === EV_ADD_DIR) {
                      this._addToFsEvents(path, false, true)
                    }
                  }
                },
                /**
                 * Handle symlinks encountered during directory scan
                 * @param {String} watchPath  - file/dir path to be watched with fsevents
                 * @param {String} realPath   - real path (in case of symlinks)
                 * @param {Function} transform  - path transformer
                 * @param {Function} globFilter - path filter in case a glob pattern was provided
                 * @returns {Function} closer for the watcher instance
                 */
              },
              {
                key: '_watchWithFsEvents',
                value: function _watchWithFsEvents(
                  watchPath,
                  realPath,
                  transform,
                  globFilter
                ) {
                  const _this = this

                  if (this.fsw.closed) {
                    return
                  }
                  if (this.fsw._isIgnored(watchPath)) {
                    return
                  }
                  const {options} = this.fsw

                  const watchCallback =
                    /* #__PURE__ */
                    (function() {
                      const _reference = _asyncToGenerator(
                        /* #__PURE__ */
                        regeneratorRuntime.mark(function _callee2(
                          fullPath,
                          flags,
                          info
                        ) {
                          let path
                          let parent
                          let item
                          let watchedDir
                          let stats
                          return regeneratorRuntime.wrap(
                            function _callee2$(_context2) {
                              while (1) {
                                switch ((_context2.prev = _context2.next)) {
                                  case 0:
                                    if (!_this.fsw.closed) {
                                      _context2.next = 2
                                      break
                                    }

                                    return _context2.abrupt('return')

                                  case 2:
                                    if (
                                      !(
                                        options.depth !== undefined &&
                                        calcDepth(fullPath, realPath) >
                                          options.depth
                                      )
                                    ) {
                                      _context2.next = 4
                                      break
                                    }

                                    return _context2.abrupt('return')

                                  case 4:
                                    path = transform(
                                      sysPath.join(
                                        watchPath,
                                        sysPath.relative(watchPath, fullPath)
                                      )
                                    )

                                    if (!(globFilter && !globFilter(path))) {
                                      _context2.next = 7
                                      break
                                    }

                                    return _context2.abrupt('return')

                                  case 7:
                                    // ensure directories are tracked
                                    parent = sysPath.dirname(path)
                                    item = sysPath.basename(path)
                                    watchedDir = _this.fsw._getWatchedDir(
                                      info.type === FSEVENT_TYPE_DIRECTORY
                                        ? path
                                        : parent
                                    ) // correct for wrong events emitted

                                    if (
                                      !(
                                        wrongEventFlags.has(flags) ||
                                        info.event === FSEVENT_UNKNOWN
                                      )
                                    ) {
                                      _context2.next = 30
                                      break
                                    }

                                    if (
                                      !(
                                        typeof options.ignored === FUNCTION_TYPE
                                      )
                                    ) {
                                      _context2.next = 27
                                      break
                                    }

                                    _context2.prev = 12
                                    _context2.next = 15
                                    return stat(path)

                                  case 15:
                                    stats = _context2.sent
                                    _context2.next = 20
                                    break

                                  case 18:
                                    _context2.prev = 18
                                    _context2.t0 = _context2.catch(12)

                                  case 20:
                                    if (!_this.fsw.closed) {
                                      _context2.next = 22
                                      break
                                    }

                                    return _context2.abrupt('return')

                                  case 22:
                                    if (!_this.checkIgnored(path, stats)) {
                                      _context2.next = 24
                                      break
                                    }

                                    return _context2.abrupt('return')

                                  case 24:
                                    if (stats) {
                                      _this.addOrChange(
                                        path,
                                        fullPath,
                                        realPath,
                                        parent,
                                        watchedDir,
                                        item,
                                        info,
                                        options
                                      )
                                    } else {
                                      _this.handleEvent(
                                        EV_UNLINK,
                                        path,
                                        fullPath,
                                        realPath,
                                        parent,
                                        watchedDir,
                                        item,
                                        info,
                                        options
                                      )
                                    }

                                    _context2.next = 28
                                    break

                                  case 27:
                                    _this.checkFd(
                                      path,
                                      fullPath,
                                      realPath,
                                      parent,
                                      watchedDir,
                                      item,
                                      info,
                                      options
                                    )

                                  case 28:
                                    _context2.next = 35
                                    break

                                  case 30:
                                    _context2.t1 = info.event
                                    _context2.next =
                                      _context2.t1 === FSEVENT_CREATED
                                        ? 33
                                        : _context2.t1 === FSEVENT_MODIFIED
                                        ? 33
                                        : _context2.t1 === FSEVENT_DELETED
                                        ? 34
                                        : _context2.t1 === FSEVENT_MOVED
                                        ? 34
                                        : 35
                                    break

                                  case 33:
                                    return _context2.abrupt(
                                      'return',
                                      _this.addOrChange(
                                        path,
                                        fullPath,
                                        realPath,
                                        parent,
                                        watchedDir,
                                        item,
                                        info,
                                        options
                                      )
                                    )

                                  case 34:
                                    return _context2.abrupt(
                                      'return',
                                      _this.checkFd(
                                        path,
                                        fullPath,
                                        realPath,
                                        parent,
                                        watchedDir,
                                        item,
                                        info,
                                        options
                                      )
                                    )

                                  case 35:
                                  case 'end':
                                    return _context2.stop()
                                }
                              }
                            },
                            _callee2,
                            null,
                            [[12, 18]]
                          )
                        })
                      )

                      return function watchCallback(_x9, _x10, _x11) {
                        return Reflect.apply(_reference, this, arguments)
                      }
                    })()

                  const closer = setFSEventsListener(
                    watchPath,
                    realPath,
                    watchCallback,
                    this.fsw._emitRaw,
                    this.fsw
                  )

                  this.fsw._emitReady()

                  return closer
                },
                /**
                 * Handle symlinks encountered during directory scan
                 * @param {String} linkPath path to symlink
                 * @param {String} fullPath absolute path to the symlink
                 * @param {Function} transform pre-existing path transformer
                 * @param {Number} curDepth level of subdirectories traversed to where symlink is
                 * @returns {Promise<void>}
                 */
              },
              {
                key: '_handleFsEventsSymlink',
                value: (function() {
                  const _handleFsEventsSymlink2 = _asyncToGenerator(
                    /* #__PURE__ */
                    regeneratorRuntime.mark(function _callee3(
                      linkPath,
                      fullPath,
                      transform,
                      currentDepth
                    ) {
                      let linkTarget
                      return regeneratorRuntime.wrap(
                        function _callee3$(_context3) {
                          while (1) {
                            switch ((_context3.prev = _context3.next)) {
                              case 0:
                                if (
                                  !(
                                    this.fsw.closed ||
                                    this.fsw._symlinkPaths.has(fullPath)
                                  )
                                ) {
                                  _context3.next = 2
                                  break
                                }

                                return _context3.abrupt('return')

                              case 2:
                                this.fsw._symlinkPaths.set(fullPath, true)

                                this.fsw._incrReadyCount()

                                _context3.prev = 4
                                _context3.next = 7
                                return realpath(linkPath)

                              case 7:
                                linkTarget = _context3.sent

                                if (!this.fsw.closed) {
                                  _context3.next = 10
                                  break
                                }

                                return _context3.abrupt('return')

                              case 10:
                                if (!this.fsw._isIgnored(linkTarget)) {
                                  _context3.next = 12
                                  break
                                }

                                return _context3.abrupt(
                                  'return',
                                  this.fsw._emitReady()
                                )

                              case 12:
                                this.fsw._incrReadyCount() // add the linkTarget for watching with a wrapper for transform
                                // that causes emitted paths to incorporate the link's path

                                this._addToFsEvents(
                                  linkTarget || linkPath,
                                  function(path) {
                                    let aliasedPath = linkPath

                                    if (
                                      linkTarget &&
                                      linkTarget !== DOT_SLASH
                                    ) {
                                      aliasedPath = path.replace(
                                        linkTarget,
                                        linkPath
                                      )
                                    } else if (path !== DOT_SLASH) {
                                      aliasedPath = sysPath.join(linkPath, path)
                                    }

                                    return transform(aliasedPath)
                                  },
                                  false,
                                  currentDepth
                                )

                                _context3.next = 20
                                break

                              case 16:
                                _context3.prev = 16
                                _context3.t0 = _context3.catch(4)

                                if (!this.fsw._handleError(_context3.t0)) {
                                  _context3.next = 20
                                  break
                                }

                                return _context3.abrupt(
                                  'return',
                                  this.fsw._emitReady()
                                )

                              case 20:
                              case 'end':
                                return _context3.stop()
                            }
                          }
                        },
                        _callee3,
                        this,
                        [[4, 16]]
                      )
                    })
                  )

                  function _handleFsEventsSymlink(_x12, _x13, _x14, _x15) {
                    return Reflect.apply(
                      _handleFsEventsSymlink2,
                      this,
                      arguments
                    )
                  }

                  return _handleFsEventsSymlink
                })(),
                /**
                 *
                 * @param {Path} newPath
                 * @param {fs.Stats} stats
                 */
              },
              {
                key: 'emitAdd',
                value: function emitAdd(
                  newPath,
                  stats,
                  processPath,
                  options,
                  forceAdd
                ) {
                  const pp = processPath(newPath)
                  const isDir = stats.isDirectory()

                  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp))

                  const base = sysPath.basename(pp) // ensure empty dirs get tracked

                  if (isDir) {
                    this.fsw._getWatchedDir(pp)
                  }
                  if (dirObj.has(base)) {
                    return
                  }
                  dirObj.add(base)

                  if (!options.ignoreInitial || forceAdd === true) {
                    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats)
                  }
                },
              },
              {
                key: 'initWatch',
                value: function initWatch(realPath, path, wh, processPath) {
                  if (this.fsw.closed) {
                    return
                  }

                  const closer = this._watchWithFsEvents(
                    wh.watchPath,
                    sysPath.resolve(realPath || wh.watchPath),
                    processPath,
                    wh.globFilter
                  )

                  this.fsw._addPathCloser(path, closer)
                },
                /**
                 * Handle added path with fsevents
                 * @param {String} path file/dir path or glob pattern
                 * @param {Function|Boolean=} transform converts working path to what the user expects
                 * @param {Boolean=} forceAdd ensure add is emitted
                 * @param {Number=} priorDepth Level of subdirectories already traversed.
                 * @returns {Promise<void>}
                 */
              },
              {
                key: '_addToFsEvents',
                value: (function() {
                  const _addToFsEvents2 = _asyncToGenerator(
                    /* #__PURE__ */
                    regeneratorRuntime.mark(function _callee4(
                      path,
                      transform,
                      forceAdd,
                      priorDepth
                    ) {
                      const _this2 = this

                      let options
                      let processPath
                      let wh
                      let stats
                      let realPath
                      return regeneratorRuntime.wrap(
                        function _callee4$(_context4) {
                          while (1) {
                            switch ((_context4.prev = _context4.next)) {
                              case 0:
                                if (!this.fsw.closed) {
                                  _context4.next = 2
                                  break
                                }

                                return _context4.abrupt('return')

                              case 2:
                                options = this.fsw.options
                                processPath =
                                  typeof transform === FUNCTION_TYPE
                                    ? transform
                                    : IDENTITY_FN
                                wh = this.fsw._getWatchHelpers(path) // evaluate what is at the path we're being asked to watch

                                _context4.prev = 5
                                _context4.next = 8
                                return statMethods[wh.statMethod](wh.watchPath)

                              case 8:
                                stats = _context4.sent

                                if (!this.fsw.closed) {
                                  _context4.next = 11
                                  break
                                }

                                return _context4.abrupt('return')

                              case 11:
                                if (!this.fsw._isIgnored(wh.watchPath, stats)) {
                                  _context4.next = 13
                                  break
                                }

                                throw null

                              case 13:
                                if (!stats.isDirectory()) {
                                  _context4.next = 20
                                  break
                                }

                                // emit addDir unless this is a glob parent
                                if (!wh.globFilter) {
                                  this.emitAdd(
                                    processPath(path),
                                    stats,
                                    processPath,
                                    options,
                                    forceAdd
                                  )
                                } // don't recurse further if it would exceed depth setting

                                if (
                                  !(priorDepth && priorDepth > options.depth)
                                ) {
                                  _context4.next = 17
                                  break
                                }

                                return _context4.abrupt('return')

                              case 17:
                                // scan the contents of the dir
                                this.fsw
                                  ._readdirp(
                                    wh.watchPath,
                                    _objectSpread(
                                      {
                                        fileFilter: function fileFilter(entry) {
                                          return wh.filterPath(entry)
                                        },
                                        directoryFilter: function directoryFilter(
                                          entry
                                        ) {
                                          return wh.filterDir(entry)
                                        },
                                      },
                                      Depth(options.depth - (priorDepth || 0))
                                    )
                                  )
                                  .on(STR_DATA, function(entry) {
                                    // need to check filterPath on dirs b/c filterDir is less restrictive
                                    if (_this2.fsw.closed) {
                                      return
                                    }

                                    if (
                                      entry.stats.isDirectory() &&
                                      !wh.filterPath(entry)
                                    ) {
                                      return
                                    }
                                    const joinedPath = sysPath.join(
                                      wh.watchPath,
                                      entry.path
                                    )
                                    const {fullPath} = entry

                                    if (
                                      wh.followSymlinks &&
                                      entry.stats.isSymbolicLink()
                                    ) {
                                      // preserve the current depth here since it can't be derived from
                                      // real paths past the symlink
                                      const currentDepth =
                                        options.depth === undefined
                                          ? undefined
                                          : calcDepth(
                                              joinedPath,
                                              sysPath.resolve(wh.watchPath)
                                            ) + 1

                                      _this2._handleFsEventsSymlink(
                                        joinedPath,
                                        fullPath,
                                        processPath,
                                        currentDepth
                                      )
                                    } else {
                                      _this2.emitAdd(
                                        joinedPath,
                                        entry.stats,
                                        processPath,
                                        options,
                                        forceAdd
                                      )
                                    }
                                  })
                                  .on(EV_ERROR, EMPTY_FN)
                                  .on(STR_END, function() {
                                    _this2.fsw._emitReady()
                                  })

                                _context4.next = 22
                                break

                              case 20:
                                this.emitAdd(
                                  wh.watchPath,
                                  stats,
                                  processPath,
                                  options,
                                  forceAdd
                                )

                                this.fsw._emitReady()

                              case 22:
                                _context4.next = 27
                                break

                              case 24:
                                _context4.prev = 24
                                _context4.t0 = _context4.catch(5)

                                if (
                                  !_context4.t0 ||
                                  this.fsw._handleError(_context4.t0)
                                ) {
                                  // TODO: Strange thing: "should not choke on an ignored watch path" will be failed without 2 ready calls -__-
                                  this.fsw._emitReady()

                                  this.fsw._emitReady()
                                }

                              case 27:
                                if (
                                  !(options.persistent && forceAdd !== true)
                                ) {
                                  _context4.next = 41
                                  break
                                }

                                if (!(typeof transform === FUNCTION_TYPE)) {
                                  _context4.next = 32
                                  break
                                }

                                // realpath has already been resolved
                                this.initWatch(undefined, path, wh, processPath)
                                _context4.next = 41
                                break

                              case 32:
                                _context4.prev = 32
                                _context4.next = 35
                                return realpath(wh.watchPath)

                              case 35:
                                realPath = _context4.sent
                                _context4.next = 40
                                break

                              case 38:
                                _context4.prev = 38
                                _context4.t1 = _context4.catch(32)

                              case 40:
                                this.initWatch(realPath, path, wh, processPath)

                              case 41:
                              case 'end':
                                return _context4.stop()
                            }
                          }
                        },
                        _callee4,
                        this,
                        [[5, 24], [32, 38]]
                      )
                    })
                  )

                  function _addToFsEvents(_x16, _x17, _x18, _x19) {
                    return Reflect.apply(_addToFsEvents2, this, arguments)
                  }

                  return _addToFsEvents
                })(),
              },
            ])

            return FsEventsHandler
          })()

        module.exports = FsEventsHandler
        module.exports.canUse = canUse
        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(0)(module)))

      /** */
    },
    /* 213 */
    /** */ function(module, exports) {
      module.exports = require('fsevents')

      /** */
    },
    /* 214 */
    /** */ function(module) {
      module.exports = JSON.parse(
        '{"name":"@typescript-eslint/typescript-estree","version":"2.4.0","description":"A parser that converts TypeScript source code into an ESTree compatible form","main":"dist/parser.js","types":"dist/parser.d.ts","files":["dist","README.md","LICENSE"],"engines":{"node":"^8.10.0 || ^10.13.0 || >=11.10.1"},"repository":{"type":"git","url":"https://github.com/typescript-eslint/typescript-eslint.git","directory":"packages/typescript-estree"},"bugs":{"url":"https://github.com/typescript-eslint/typescript-eslint/issues"},"license":"BSD-2-Clause","keywords":["ast","estree","ecmascript","javascript","typescript","parser","syntax"],"scripts":{"build":"tsc -b tsconfig.build.json","clean":"tsc -b tsconfig.build.json --clean","format":"prettier --write \\"./**/*.{ts,js,json,md}\\" --ignore-path ../../.prettierignore","lint":"eslint . --ext .js,.ts --ignore-path=\'../../.eslintignore\'","test":"jest --coverage","typecheck":"tsc -p tsconfig.json --noEmit"},"dependencies":{"chokidar":"^3.0.2","glob":"^7.1.4","is-glob":"^4.0.1","lodash.unescape":"4.0.1","semver":"^6.3.0"},"devDependencies":{"@babel/code-frame":"7.5.5","@babel/parser":"7.5.5","@babel/types":"^7.3.2","@types/babel-code-frame":"^6.20.1","@types/glob":"^7.1.1","@types/is-glob":"^4.0.1","@types/lodash.isplainobject":"^4.0.4","@types/lodash.unescape":"^4.0.4","@types/semver":"^6.0.1","@types/tmp":"^0.1.0","@typescript-eslint/shared-fixtures":"2.4.0","babel-code-frame":"^6.26.0","glob":"^7.1.4","lodash.isplainobject":"4.0.6","tmp":"^0.1.0","typescript":"*"},"gitHead":"111ecc668eb8a332d7311dacf196fceec83316cb"}'
      )

      /** */
    },
    /** *** */
  ]
)
